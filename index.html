<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KOV - Fixed & Data Integrated</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ... (Í∏∞Ï°¥ Ïä§ÌÉÄÏùº Ïú†ÏßÄ) ... */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background-color: #000; touch-action: none; font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; width: 100vw; height: 100dvh; }
        #game-container { position: relative; background-color: #4e342e; box-shadow: 0 0 50px rgba(0,0,0,0.5); width: 100%; height: 100%; max-width: 56.25vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Header */
        .header-panel { flex: 0 0 auto; background: linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.0)); color: white; padding: 8px 12px; padding-top: max(8px, env(safe-area-inset-top)); z-index: 20; }
        .res-pill { background: rgba(0,0,0,0.6); border: 1px solid #555; border-radius: 99px; padding: 4px 10px; display: flex; align-items: center; gap: 6px; font-weight: bold; font-size: 12px; color: #fff; cursor: pointer; transition: transform 0.1s; }
        .res-pill:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }
        .res-icon { width: 18px; height: 18px; object-fit: contain; }

        /* Canvas */
        #canvas-wrapper { flex: 1; position: relative; overflow: hidden; background-color: #3e2723; width: 100%; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* Footer */
        .footer-panel { flex: 0 0 auto; background: #d7ccc8; border-top: 4px solid #8d6e63; padding: 8px 12px; padding-bottom: max(10px, env(safe-area-inset-bottom)); display: flex; align-items: center; justify-content: space-between; min-height: 90px; z-index: 20; }
        .info-box { flex: 1; background: #f5f5f5; border: 1px solid #8d6e63; border-radius: 6px; padding: 4px 8px; height: 60px; display: flex; flex-direction: column; justify-content: center; color: #3e2723; margin: 0 6px; overflow: hidden; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; font-size: 10px; font-weight: bold; color: #444; margin-top: 2px; }
        
        /* Action Buttons */
        .action-btn { 
            width: 56px; 
            height: 56px; 
            background: linear-gradient(to bottom, #ffca28, #ff6f00); 
            border: 1px solid #e65100; 
            border-radius: 10px; 
            color: white; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            box-shadow: 0 3px 0 #bf360c, 0 5px 5px rgba(0,0,0,0.3); 
            transition: all 0.1s;
            position: relative;
            padding-bottom: 2px;
        }
        .action-btn:active { transform: translateY(3px); box-shadow: 0 0 0 #bf360c, 0 0 0 rgba(0,0,0,0); border-bottom-width: 0; }
        .world-btn { background: linear-gradient(to bottom, #42a5f5, #1565c0); border-color: #0d47a1; box-shadow: 0 3px 0 #0d47a1, 0 5px 5px rgba(0,0,0,0.3); }
        .world-btn:active { box-shadow: 0 0 0 #0d47a1; }
        .build-btn { background: linear-gradient(to bottom, #8d6e63, #5d4037); border-color: #3e2723; box-shadow: 0 3px 0 #3e2723, 0 5px 5px rgba(0,0,0,0.3); }
        .build-btn:active { box-shadow: 0 0 0 #3e2723; }
        
        .btn-icon { font-size: 22px; line-height: 1; margin-bottom: 2px; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2)); }
        .btn-label { font-size: 11px; font-weight: bold; line-height: 1; text-shadow: 0 1px 1px rgba(0,0,0,0.4); letter-spacing: -0.5px; }

        /* Modals & Popups */
        .modal-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.8); z-index: 100; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.2s; backdrop-filter: blur(2px); }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-content { background: #3e2723; border: 2px solid #8d6e63; border-radius: 12px; padding: 20px; width: 85%; max-width: 320px; text-align: center; color: white; transform: scale(0.9); transition: transform 0.2s; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .modal-overlay.open .modal-content { transform: scale(1); }
        
        #field-modal { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; background: #222; z-index: 90; transform: translateY(100%); transition: transform 0.3s ease-out; display: flex; flex-direction: column; color: white; }
        #field-modal.open { transform: translateY(0); }
        
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; overflow-y: auto; padding: 10px; }
        .shop-item { background: #4e342e; border: 2px solid #8d6e63; border-radius: 10px; padding: 10px; display: flex; flex-direction: column; align-items: center; position: relative; }
        .toggle-switch { width: 40px; height: 20px; background: #555; border-radius: 20px; position: relative; transition: 0.3s; }
        .toggle-switch.on { background: #4caf50; }
        .toggle-knob { width: 16px; height: 16px; background: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: 0.3s; }
        .toggle-switch.on .toggle-knob { left: 22px; }

        /* Field Styles */
        .field-cell { width: 12px; height: 12px; transition: all 0.2s; border-radius: 1px; position: relative; }
        .field-occupied { border: 1px solid #42a5f5; box-shadow: 0 0 2px #42a5f5; z-index: 10; opacity: 1.0 !important; }
        
        /* Fog of War */
        .field-fog { background-color: #000 !important; border: none; cursor: default; z-index: 100; opacity: 1 !important; }
        .field-fog::after { content: ''; }
        
        .field-gate { border: 1px solid #ef4444; }
        .field-gate.locked::after { content: 'üîí'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-gate.unlocked::after { content: 'üëê'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-castle::after { content: 'üè∞'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-fortress::after { content: 'üèØ'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        
        #income-float { position:absolute; color:#ffd700; font-weight:bold; font-size:12px; pointer-events:none; animation: floatUp 1s forwards; z-index: 200; text-shadow: 1px 1px 0 #000; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity:1; } 100% { transform: translateY(-20px); opacity:0; } }
        
        #toast { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; opacity: 0; transition: opacity 0.3s; z-index: 200; border: 2px solid #ffd700; white-space: nowrap; pointer-events: none; }
        
        /* Army Marker & Selector */
        .army-marker { 
            position: absolute; width: 12px; height: 12px; 
            box-shadow: 0 0 4px rgba(0,0,0,0.5); 
            transition: transform 0.1s linear; 
            z-index: 50; pointer-events: none; 
            display: flex; justify-content: center; align-items: center; 
            font-size: 8px; font-weight: bold; color: black; 
            overflow: visible; background-size: contain; background-repeat: no-repeat; background-position: center;
        }
        .army-marker.selected { box-shadow: 0 0 15px 2px #ffd700; transform: scale(1.3); z-index: 51; }
        
        .squad-selector { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.95); border: 2px solid #8d6e63; border-radius: 12px; padding: 10px; display: flex; gap: 10px; z-index: 100; width: 90%; max-width: 300px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .squad-card { flex: 1; background: #3e2723; border: 1px solid #555; border-radius: 8px; padding: 8px; text-align: center; cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden; }
        .squad-card:active { transform: scale(0.95); }
        .squad-card.disabled { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        .squad-status { font-size: 10px; color: #aaa; margin-top: 2px; }
        
        .selected-army-hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.9); border: 1px solid #ffd700; border-radius: 30px; padding: 8px 20px; z-index: 95; display: flex; gap: 15px; align-items: center; color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.6); }
        .hud-name { font-weight: bold; color: #ffd700; font-size: 14px; }
        .hud-btn { background: #d32f2f; border: none; border-radius: 12px; padding: 4px 12px; font-size: 10px; font-weight: bold; cursor: pointer; color: white; }
        
        #levelup-banner { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) scale(0); z-index: 150; pointer-events: none; transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #levelup-banner.show { transform: translate(-50%, -50%) scale(1); }
        .levelup-stat { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .levelup-old { color: #aaa; }
        .levelup-arrow { color: #fbbf24; margin: 0 10px; }
        .levelup-new { color: #4ade80; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="levelup-banner"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/levelup.png" onerror="this.style.display='none'"></div>

    <!-- Header -->
    <div class="header-panel">
        <div class="flex justify-between mb-1">
            <div class="res-pill" onclick="game.openRefill('energy')">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/energy.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='‚ö°'+this.nextElementSibling.innerText">
                <span id="energy-display">50/50</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
            <div class="res-pill" onclick="game.openRefill('gold')">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/gold.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üí∞'+this.nextElementSibling.innerText">
                <span id="gold-display">3000</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
            <div class="res-pill" onclick="game.openRefill('crystal')">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/crystal.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üíé'+this.nextElementSibling.innerText">
                <span id="gem-display">50</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
        </div>
        <div class="flex flex-col w-full">
            <div class="flex justify-between items-end px-1">
                <span class="font-bold text-yellow-400 text-xs" id="level-display">LORD LV.1</span>
                <span class="font-bold text-gray-300 text-xs flex items-center gap-1"><span id="xp-text">0 / 10</span> XP</span>
            </div>
            <div class="w-full bg-gray-800 h-2 mt-1 rounded-full overflow-hidden border border-gray-600 relative">
                <div id="xp-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
            </div>
        </div>
        <!-- Dev Tools -->
        <div class="flex gap-2 mt-1 opacity-30 hover:opacity-100 transition-opacity justify-end items-center">
            <button onclick="game.resetGame()" class="bg-red-800 text-white px-2 py-1 rounded text-[10px] border border-red-500 hover:bg-red-600">üîÑÎ¶¨ÏÖã</button>
            <button onclick="game.cheatEnergy()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚ö°+30</button>
            <button onclick="game.spawnChest()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">üéÅÏÉÅÏûê</button>
            <button onclick="game.cheatLevelUp()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚¨ÜÔ∏èLvUP</button>
        </div>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Footer -->
    <div class="footer-panel">
        <button class="action-btn chat-btn bg-gray-700 border-gray-600" onclick="game.openSettings()">
            <span class="text-2xl filter drop-shadow">‚öôÔ∏è</span>
        </button>
        
        <div class="info-box" id="info-panel">
            <div class="flex justify-between items-center"><span class="font-bold text-sm truncate" id="info-name">ÏÑ†ÌÉù ÏóÜÏùå</span><span class="text-[10px] text-gray-500 font-bold" id="info-class"></span></div>
            <div class="stat-grid hidden" id="unit-stats-grid">
                <div class="stat-item">‚ù§<span id="st-hp">0</span></div>
                <div class="stat-item">‚öî<span id="st-atk">0</span></div>
                <div class="stat-item">üõ°Ô∏è<span id="st-def">0</span></div>
                <div class="stat-item">ü¶∂<span id="st-spd">0</span></div>
                <div class="stat-item">üéØ<span id="st-rng">0</span></div>
                <div class="stat-item">üèÉ<span id="st-mov">0</span></div>
            </div>
            <div class="text-[10px] text-gray-600 truncate mt-1" id="info-desc">Ïò§Î∏åÏ†ùÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>
        </div>
        
        <button class="action-btn" id="btn-action" onclick="game.handleAction()">
            <span class="btn-icon" id="action-icon">üí∞</span>
            <span class="btn-label" id="action-label">Sell</span>
        </button>
        <button class="action-btn build-btn" style="margin-left:5px;" onclick="game.toggleShop()">
            <span class="btn-icon">üè†</span>
            <span class="btn-label">Í±¥ÏÑ§</span>
        </button>
        <button class="action-btn world-btn" style="margin-left:5px;" onclick="game.toggleField()">
            <span class="btn-icon">üåç</span>
            <span class="btn-label">ÌïÑÎìú</span>
        </button>
    </div>

    <!-- Modals -->
    <div id="field-modal">
        <div class="flex justify-between items-center p-4 border-b border-gray-600 bg-gray-900">
            <h2 class="text-xl font-bold text-yellow-400" id="modal-title">Î©îÎâ¥</h2>
            <button onclick="game.closeModal()" class="w-8 h-8 text-gray-400 font-bold">‚úñ</button>
        </div>
        <div class="flex-1 overflow-auto bg-gray-800 p-2 relative" id="modal-content"></div>
    </div>
    
    <div id="modal-levelup" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-yellow-400 mb-4">LEVEL UP!</h2>
            <div class="text-6xl mb-4">üÜô</div>
            <div class="bg-gray-800 rounded p-4 mb-4 text-left text-sm">
                <div class="levelup-stat">
                    <span>Î†àÎ≤® (Lord Level)</span>
                    <span><span id="lv-old" class="levelup-old">1</span> <span class="levelup-arrow">‚ñ∂</span> <span id="lv-new" class="levelup-new">2</span></span>
                </div>
                <div class="levelup-stat" style="border:none">
                    <span>ÏµúÎåÄ ÏóêÎÑàÏßÄ</span>
                    <span><span id="en-old" class="levelup-old">50</span> <span class="levelup-arrow">‚ñ∂</span> <span id="en-new" class="levelup-new">52</span></span>
                </div>
            </div>
            <button onclick="document.getElementById('modal-levelup').classList.remove('open')" class="w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-lg font-bold">ÌôïÏù∏</button>
        </div>
    </div>

    <div id="modal-refill" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold text-white" id="refill-title">Î¶¨ÏÜåÏä§ Ï∂©Ï†Ñ</h2>
                <button onclick="document.getElementById('modal-refill').classList.remove('open')" class="text-gray-400">‚úñ</button>
            </div>
            <div id="refill-options" class="grid gap-3"></div>
        </div>
    </div>

    <div id="modal-settings" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold text-gray-200 mb-6">ÏÑ§Ï†ï (Settings)</h2>
            <div class="space-y-4 text-left">
                <div class="flex justify-between items-center bg-gray-800 p-3 rounded">
                    <span>Î∞∞Í≤ΩÏùåÏïÖ (BGM)</span>
                    <div class="toggle-switch on" onclick="game.toggleSetting('bgm', this)"><div class="toggle-knob"></div></div>
                </div>
                <div class="flex justify-between items-center bg-gray-800 p-3 rounded">
                    <span>Ìö®Í≥ºÏùå (SFX)</span>
                    <div class="toggle-switch on" onclick="game.toggleSetting('sfx', this)"><div class="toggle-knob"></div></div>
                </div>
                <div class="bg-gray-800 p-3 rounded text-xs text-gray-400">
                    <p>UID: <span id="settings-uid" class="text-gray-200">User_1234</span></p>
                    <p>Version: 0.3.1 (Hotfix: Data Restore)</p>
                </div>
            </div>
            <div class="mt-6 flex gap-2">
                <button onclick="game.resetGame()" class="flex-1 bg-red-800 py-2 rounded text-xs text-red-200 border border-red-600 hover:bg-red-700">Í≥ÑÏ†ï Ï¥àÍ∏∞Ìôî</button>
                <button onclick="document.getElementById('modal-settings').classList.remove('open')" class="flex-1 bg-gray-600 py-2 rounded text-xs border border-gray-500 hover:bg-gray-500">Îã´Í∏∞</button>
            </div>
        </div>
    </div>

    <div id="toast">Î©îÏãúÏßÄ</div>
</div>

<script>
// --- CONFIGURATION ---
const GITHUB_REPO = "nod-sean/bmo";
const GITHUB_BRANCH = "main";
const ASSET_KEYS = [
    '1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110',
    '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210',
    '1301', '1302', '1303', '1304', '1305', '1306', '1307', '1308', '1309', '1310',
    '2101', '2102', '2103', '2104', '2105', '2201', '2204', '2205',
    '2301', '2302', '2303', '2304', '2801', '2802', '2803', '2804', '2805',
    '3101', '3102', '3103', '3104', '3105',
    '1801', '1802', '1803', '1804', '1805', '1811', '1812', '1813', '1814', '1815',
    '1821', '1822', '1823', '1824', '1825', 'lock', 'gold', 'energy', 'crystal', 'xp', 'levelup', 'field_bg'
];

const CONFIG = { gridCols: 8, gridRows: 8, gridTopY: 520, gridPadding: 20, squadCols: 3, squadRows: 3, squadTopY: 55, squadGap: 80, squadCellSize: 130 };
const ITEM_TYPE = { EMPTY: 0, BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3, BUILDING_CHEST: 4, BUILDING_CAMP: 5, UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12, ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22 };
const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2' };
const BUILDING_LIMITS = { [ITEM_TYPE.BUILDING_BARRACKS]: 3, [ITEM_TYPE.BUILDING_RANGE]: 2, [ITEM_TYPE.BUILDING_STABLE]: 2, [ITEM_TYPE.BUILDING_CAMP]: 2, [ITEM_TYPE.BUILDING_CHEST]: 99 };
const SHOP_DATA = [ { type: ITEM_TYPE.BUILDING_BARRACKS, name: "Î≥ëÏòÅ", price: 100, icon: "üè†" }, { type: ITEM_TYPE.BUILDING_RANGE, name: "ÏÇ¨Í≤©Ïû•", price: 200, icon: "üéØ" }, { type: ITEM_TYPE.BUILDING_STABLE, name: "ÎßàÍµ¨Í∞Ñ", price: 500, icon: "üê¥" }, { type: ITEM_TYPE.BUILDING_CAMP, name: "Ï∫†ÌîÑ", price: 300, icon: "‚õ∫" }, { type: ITEM_TYPE.BUILDING_CHEST, name: "Î≥¥Î¨ºÏÉÅÏûê", price: 500, icon: "üéÅ" } ];
const CAMP_CAPACITY = {1:4, 2:6, 3:8, 4:12, 5:16};

// --- LEVEL COLORS ---
const LEVEL_COLORS = {
    1: "#FFFFFF", 2: "#BDBDBD", 3: "#6D4C41", 4: "#2E7D32", 5: "#00897B",
    6: "#1E88E5", 7: "#6A1B9A", 8: "#F57C00", 9: "#C62828", 10: "#212121"
};

// --- GAME DATA (Restored) ---
const LEVEL_DATA = [
    { level: 1, xp: 0, maxEnergy: 50 }, { level: 2, xp: 10, maxEnergy: 52 }, { level: 3, xp: 25, maxEnergy: 54 },
    { level: 4, xp: 43, maxEnergy: 56 }, { level: 5, xp: 65, maxEnergy: 58 }, { level: 6, xp: 91, maxEnergy: 60 },
    { level: 7, xp: 122, maxEnergy: 62 }, { level: 8, xp: 157, maxEnergy: 64 }, { level: 9, xp: 197, maxEnergy: 66 },
    { level: 10, xp: 242, maxEnergy: 68 }, { level: 11, xp: 292, maxEnergy: 70 }, { level: 12, xp: 347, maxEnergy: 72 },
    { level: 13, xp: 408, maxEnergy: 74 }, { level: 14, xp: 474, maxEnergy: 76 }, { level: 15, xp: 546, maxEnergy: 78 }
];

const REFILL_DATA = {
    energy: [
        { cost: 10, amount: 30, currency: 'crystal', name: "‚ö° 30 Ï∂©Ï†Ñ" },
        { cost: 30, amount: 100, currency: 'crystal', name: "‚ö° 100 Ï∂©Ï†Ñ" }
    ],
    gold: [
        { cost: 10, amount: 1000, currency: 'crystal', name: "üí∞ 1,000 Ï∂©Ï†Ñ" },
        { cost: 50, amount: 6000, currency: 'crystal', name: "üí∞ 6,000 Ï∂©Ï†Ñ" }
    ],
    crystal: [
        { cost: 0.99, amount: 100, currency: 'usd', name: "üíé 100 (ÏÜåÎß§)" },
        { cost: 4.99, amount: 550, currency: 'usd', name: "üíé 550 (Ìè¨ÎåÄ)" }
    ]
};

// --- DATA INTEGRATION (From CSV) ---
const UNIT_STATS = {
    1101: { name: "ÎØºÎ≥ë", hp: 10, atk: 5, def: 10, spd: 5, rng: 1, mov: 1, sell: 0 },
    1102: { name: "Î≥¥Î≥ë", hp: 20, atk: 7, def: 15, spd: 7, rng: 1, mov: 1, sell: 1 },
    1103: { name: "Í≤ÄÎ≥ë", hp: 30, atk: 9, def: 20, spd: 9, rng: 1, mov: 1, sell: 1 },
    1104: { name: "Î∞©Ìå®Î≥ë", hp: 40, atk: 11, def: 25, spd: 11, rng: 1, mov: 1, sell: 2 },
    1105: { name: "Ï§ëÍ∞ëÎ≥ë", hp: 50, atk: 13, def: 30, spd: 13, rng: 1, mov: 1, sell: 3 },
    1106: { name: "Ï†ïÏòàÎ≥ë", hp: 60, atk: 15, def: 35, spd: 15, rng: 1, mov: 1, sell: 6 },
    1107: { name: "Í∑ºÏúÑÎ≥ë", hp: 70, atk: 17, def: 40, spd: 17, rng: 1, mov: 1, sell: 12 },
    1108: { name: "ÌÖúÌîåÎü¨", hp: 80, atk: 19, def: 45, spd: 19, rng: 1, mov: 1, sell: 25 },
    1109: { name: "ÌåîÎùºÎîò", hp: 90, atk: 21, def: 50, spd: 21, rng: 1, mov: 1, sell: 50 },
    1110: { name: "ÏòÅÏõÖ", hp: 100, atk: 23, def: 55, spd: 23, rng: 1, mov: 1, sell: 100 },
    1201: { name: "Ï¥àÎ≥¥ Í∂ÅÏàò", hp: 8, atk: 8, def: 5, spd: 7, rng: 3, mov: 1, sell: 0 },
    1202: { name: "Í∂ÅÏàò", hp: 16, atk: 11, def: 7, spd: 9, rng: 3, mov: 1, sell: 1 },
    1203: { name: "ÏÇ¨ÎÉ•Íæº", hp: 24, atk: 14, def: 9, spd: 11, rng: 3, mov: 1, sell: 1 },
    1204: { name: "Î™ÖÏÇ¨Ïàò", hp: 32, atk: 17, def: 11, spd: 13, rng: 4, mov: 1, sell: 2 },
    1205: { name: "Ï†ÄÍ≤©Ïàò", hp: 40, atk: 20, def: 13, spd: 15, rng: 4, mov: 1, sell: 3 },
    1206: { name: "Ï†ïÏòà Í∂ÅÏàò", hp: 48, atk: 23, def: 15, spd: 17, rng: 4, mov: 1, sell: 6 },
    1207: { name: "Îç∞ÎìúÏïÑÏù¥", hp: 56, atk: 26, def: 17, spd: 19, rng: 5, mov: 1, sell: 12 },
    1208: { name: "Ìå®Ïä§ÌååÏù∏Îçî", hp: 64, atk: 29, def: 19, spd: 21, rng: 5, mov: 1, sell: 25 },
    1209: { name: "Î≥¥Ïö∞ÎßàÏä§ÌÑ∞", hp: 72, atk: 32, def: 21, spd: 23, rng: 5, mov: 1, sell: 50 },
    1210: { name: "Ïã†Í∂Å", hp: 80, atk: 35, def: 23, spd: 25, rng: 6, mov: 1, sell: 100 },
    1301: { name: "Í∏∞Î≥ë", hp: 12, atk: 6, def: 8, spd: 10, rng: 1, mov: 2, sell: 0 },
    1302: { name: "Í≤ΩÍ∏∞Î≥ë", hp: 24, atk: 9, def: 12, spd: 12, rng: 1, mov: 1, sell: 1 },
    1303: { name: "Ï∞ΩÍ∏∞Î≥ë", hp: 36, atk: 12, def: 16, spd: 14, rng: 1, mov: 2, sell: 1 },
    1304: { name: "Í∏∞ÏÇ¨", hp: 48, atk: 15, def: 20, spd: 16, rng: 1, mov: 2, sell: 2 },
    1305: { name: "Ï§ëÍ∏∞Î≥ë", hp: 60, atk: 18, def: 24, spd: 18, rng: 1, mov: 2, sell: 3 },
    1306: { name: "Ï†ïÏòà Í∏∞Î≥ë", hp: 72, atk: 21, def: 28, spd: 20, rng: 1, mov: 2, sell: 6 },
    1307: { name: "Î°úÏñÑ ÎÇòÏù¥Ìä∏", hp: 84, atk: 24, def: 32, spd: 22, rng: 1, mov: 2, sell: 12 },
    1308: { name: "ÎìúÎûòÍ≥§ ÎÇòÏù¥Ìä∏", hp: 96, atk: 27, def: 36, spd: 24, rng: 1, mov: 2, sell: 25 },
    1309: { name: "Î∞úÌÇ§Î¶¨", hp: 108, atk: 30, def: 40, spd: 26, rng: 1, mov: 2, sell: 50 },
    1310: { name: "Ï†ÑÏÑ§Ïùò Í∏∞ÏÇ¨", hp: 120, atk: 33, def: 44, spd: 28, rng: 1, mov: 2, sell: 100 }
};

const BUILDING_DATA = {
    [ITEM_TYPE.BUILDING_BARRACKS]: {
        1: { merge_max: 6, energy: 1, probs: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] },
        2: { merge_max: 7, energy: 2, probs: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        3: { merge_max: 8, energy: 3, probs: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] },
        4: { merge_max: 9, energy: 4, probs: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        5: { merge_max: 10, energy: 5, probs: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] }
    },
    [ITEM_TYPE.BUILDING_RANGE]: {
        1: { merge_max: 6, energy: 1, probs: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] },
        2: { merge_max: 7, energy: 2, probs: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        3: { merge_max: 8, energy: 3, probs: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] },
        4: { merge_max: 9, energy: 4, probs: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        5: { merge_max: 10, energy: 5, probs: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] }
    },
    [ITEM_TYPE.BUILDING_STABLE]: {
        1: { merge_max: 6, energy: 1, probs: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] },
        2: { merge_max: 7, energy: 2, probs: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        3: { merge_max: 8, energy: 3, probs: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] },
        4: { merge_max: 9, energy: 4, probs: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        5: { merge_max: 10, energy: 5, probs: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] }
    }
};

const MERGE_XP_DATA = { 1:1, 2:2, 3:4, 4:5, 5:6, 6:8, 7:10, 8:15, 9:20, 10:0 };
const ITEM_VALUES = { 1: 1, 2: 2, 3: 6, 4: 14, 5: 32 };
const UNLOCK_GOLD_MAP = [[100, 50, 30, 20, 20, 30, 50, 100], [50, 40, 10, 5, 5, 10, 40, 50], [30, 10, 0, 0, 0, 0, 10, 30], [20, 5, 0, 0, 0, 0, 5, 20], [20, 5, 0, 0, 0, 0, 5, 20], [30, 10, 0, 0, 0, 0, 10, 30], [50, 40, 10, 5, 5, 10, 40, 50], [100, 50, 30, 20, 20, 30, 50, 100]];
const UNLOCK_LEVEL_MAP = [[24, 20, 14, 10, 10, 14, 20, 24], [23, 18, 6, 2, 2, 6, 18, 21], [17, 8, 0, 0, 0, 0, 9, 15], [13, 5, 0, 0, 0, 0, 3, 11], [13, 5, 0, 0, 0, 0, 3, 11], [17, 8, 0, 0, 0, 0, 9, 15], [23, 19, 7, 4, 4, 7, 19, 21], [25, 22, 16, 12, 12, 16, 22, 25]];
const CHEST_DROP_TABLE = { 1: [ {code: 1801, prob: 50}, {code: 1811, prob: 50} ], 2: [ {code: 1801, prob: 25}, {code: 1802, prob: 25}, {code: 1811, prob: 25}, {code: 1812, prob: 25} ], 3: [ {code: 1801, prob: 20}, {code: 1802, prob: 20}, {code: 1803, prob: 10}, {code: 1811, prob: 20}, {code: 1812, prob: 20}, {code: 1813, prob: 10} ], 4: [ {code: 1802, prob: 20}, {code: 1803, prob: 20}, {code: 1804, prob: 5}, {code: 1812, prob: 20}, {code: 1813, prob: 20}, {code: 1814, prob: 5}, {code: 1821, prob: 10} ], 5: [ {code: 1802, prob: 15}, {code: 1803, prob: 20}, {code: 1804, prob: 10}, {code: 1812, prob: 15}, {code: 1813, prob: 20}, {code: 1814, prob: 10}, {code: 1821, prob: 5}, {code: 1825, prob: 5} ] };

// --- PHASE 2 MAP DATA (RESTORED) ---
const FIELD_MAP_DATA = [];
const MAP_SIZE = 25;
const PLAYER_START = { r: 22, c: 7 };

function initFieldData() {
    for(let i=0; i<MAP_SIZE; i++) FIELD_MAP_DATA.push(new Array(MAP_SIZE).fill(0));
    const row22 = [0,0,3,4,2,4,4,1,4,4,2,4,3,4,2,4,4,1,4,4,2,0,3,0,0];
    for(let c=0; c<row22.length; c++) FIELD_MAP_DATA[22][c] = row22[c];
    for(let r=0; r<MAP_SIZE; r++) {
        if(r === 22) continue;
        for(let c=0; c<MAP_SIZE; c++) {
            let type = 0;
            if (r >= 10 && r <= 14 && c >= 10 && c <= 14) {
                if (r===12 && c===12) type = 3; else type = 4;
            } else if (r % 5 === 2 || c % 5 === 2) {
                type = 4;
                if (r % 5 === 2 && c % 5 === 2) type = (Math.random() > 0.7) ? 3 : 2; 
            }
            FIELD_MAP_DATA[r][c] = type;
        }
    }
}
initFieldData();

// Helper Functions
function getCode(type, level) {
    if (type === ITEM_TYPE.UNIT_INFANTRY) return 1100 + level;
    if (type === ITEM_TYPE.UNIT_ARCHER) return 1200 + level;
    if (type === ITEM_TYPE.UNIT_CAVALRY) return 1300 + level;
    if (type === ITEM_TYPE.BUILDING_BARRACKS) return 2100 + level;
    if (type === ITEM_TYPE.BUILDING_RANGE) return 2200 + level;
    if (type === ITEM_TYPE.BUILDING_STABLE) return 2300 + level;
    if (type === ITEM_TYPE.BUILDING_CHEST) return 2800 + level;
    if (type === ITEM_TYPE.BUILDING_CAMP) return 3100 + level;
    if (type === ITEM_TYPE.ITEM_GOLD) return 1800 + level;
    if (type === ITEM_TYPE.ITEM_ENERGY) return 1810 + level;
    if (type === ITEM_TYPE.ITEM_CRYSTAL) return 1820 + level;
    return 0;
}
function getInfoFromCode(code) {
    if (code >= 1100 && code < 1200) return { type: ITEM_TYPE.UNIT_INFANTRY, level: code % 100 };
    if (code >= 1200 && code < 1300) return { type: ITEM_TYPE.UNIT_ARCHER, level: code % 100 };
    if (code >= 1300 && code < 1400) return { type: ITEM_TYPE.UNIT_CAVALRY, level: code % 100 };
    if (code >= 1800 && code < 1810) return { type: ITEM_TYPE.ITEM_GOLD, level: code - 1800 };
    if (code >= 1810 && code < 1820) return { type: ITEM_TYPE.ITEM_ENERGY, level: code - 1810 };
    if (code >= 1820 && code < 1830) return { type: ITEM_TYPE.ITEM_CRYSTAL, level: code - 1820 };
    return { type: ITEM_TYPE.ITEM_GOLD, level: 1 };
}
function getData(type, level) {
    if (type >= 20) {
        if(type === ITEM_TYPE.ITEM_GOLD) return { name: "Í≥®Îìú", earn: ITEM_VALUES[level] };
        if(type === ITEM_TYPE.ITEM_ENERGY) return { name: "ÏóêÎÑàÏßÄ", earn: ITEM_VALUES[level] };
        if(type === ITEM_TYPE.ITEM_CRYSTAL) return { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: ITEM_VALUES[level] };
    }
    if (type < 10) {
        if(type === ITEM_TYPE.BUILDING_BARRACKS) return { name: "Î≥ëÏòÅ", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_BARRACKS][level]?.energy };
        if(type === ITEM_TYPE.BUILDING_RANGE) return { name: "ÏÇ¨Í≤©Ïû•", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_RANGE][level]?.energy };
        if(type === ITEM_TYPE.BUILDING_STABLE) return { name: "ÎßàÍµ¨Í∞Ñ", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_STABLE][level]?.energy };
        if(type === ITEM_TYPE.BUILDING_CHEST) return { name: "Î≥¥Î¨ºÏÉÅÏûê" };
        if(type === ITEM_TYPE.BUILDING_CAMP) return { name: "ÎßâÏÇ¨" };
    }
    if (type >= 10 && type < 20) {
        const code = getCode(type, level);
        const stat = UNIT_STATS[code];
        if (stat) return { name: stat.name, class: type===10?"Î≥¥Î≥ë":(type===11?"Í∂ÅÎ≥ë":"Í∏∞Î≥ë"), hp: stat.hp, atk: stat.atk, def: stat.def, spd: stat.spd, rng: stat.rng, mov: stat.mov, sell: stat.sell };
    }
    return { name: "Unknown", earn: 0, sell: 0 };
}

// --- CLASSES ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true; this.bgmStarted = false;
        const BASE = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/audio/`;
        this.files = { bgm: new Audio(BASE+'bgm.mp3'), merge: new Audio(BASE+'merge.mp3'), coin: new Audio(BASE+'coin.mp3'), pop: new Audio(BASE+'pop.mp3') };
        this.files.bgm.loop = true; this.files.bgm.volume = 0.5;
    }
    resume() { if(this.ctx.state==='suspended')this.ctx.resume(); if(this.enabled&&!this.bgmStarted){this.files.bgm.play().then(()=>this.bgmStarted=true).catch(()=>{});} }
    playFile(n, v=1.0) { if(!this.enabled||!this.files[n])return; const s=this.files[n].cloneNode(); s.crossOrigin="anonymous"; s.volume=v; s.play().catch(()=>{}); }
    playTone(f, t, d) { if(!this.enabled)return; const o=this.ctx.createOscillator(), g=this.ctx.createGain(); o.type=t; o.frequency.value=f; g.gain.setValueAtTime(0.1,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); }
    playClick() { this.playFile('pop', 0.6); }
    playError() { this.playTone(150, 'sawtooth', 0.3); }
    playSpawn() { this.playFile('pop', 0.5); }
    playMerge() { this.playFile('merge', 0.8); }
    playCollect() { this.playFile('coin', 0.6); }
    playUnlock() { this.playFile('merge', 0.8); }
    playLevelUp() { [440,554,659,880].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.3),i*100)); }
}

class AssetLoader {
    constructor() { this.images = {}; }
    loadAll(cb) {
        let loaded = 0;
        ASSET_KEYS.forEach(key => {
            const img = new Image(); img.crossOrigin = "Anonymous";
            img.onload = () => { this.images[key] = img; loaded++; if(loaded===ASSET_KEYS.length) cb(); };
            img.onerror = () => { 
                const ext = key === 'field_bg' ? '.jpg' : '.png';
                img.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/img/${key}${ext}`;
                loaded++; if(loaded===ASSET_KEYS.length) cb();
            };
            img.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/img/${key}.png`;
        });
        setTimeout(cb, 2000); 
    }
    getImage(type, level) {
        if(typeof type === 'string') return this.images[type];
        const code = getCode(type, level);
        return this.images[code] || (level > 1 ? this.getImage(type, level - 1) : null);
    }
}

class Particle {
    constructor(x, y, color, type) {
        this.x = x; this.y = y; this.vx = (Math.random()-0.5)*8; this.vy = (Math.random()-0.5)*8;
        this.life = 1.0; this.decay = Math.random()*0.03+0.02; this.color = color; this.size = Math.random()*6+4; this.type = type;
        if(type==='smoke') { this.vy = -Math.abs(this.vy)*0.5; this.decay=0.015; }
    }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; if(this.type==='smoke')this.size+=0.3; else this.vy+=0.2; }
    draw(ctx) { ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color; if(this.type==='confetti'){ ctx.translate(this.x,this.y); ctx.rotate(this.life*5); ctx.fillRect(-this.size/2,-this.size/2,this.size,this.size); ctx.resetTransform(); const s=ctx.canvas.width/1080; ctx.scale(s,s); } else if(this.type==='smoke'){ ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); } else ctx.fillRect(this.x,this.y,this.size,this.size); ctx.globalAlpha=1.0; }
}

class AStar {
    static findPath(start, end, mapData, occupiedTiles) {
        const rows = MAP_SIZE, cols = MAP_SIZE;
        const openSet = [], closedSet = new Set();
        const startNode = { r: start.r, c: start.c, g: 0, h: 0, f: 0, parent: null };
        openSet.push(startNode);
        
        while(openSet.length > 0) {
            let lowInd = 0;
            for(let i=0; i<openSet.length; i++) if(openSet[i].f < openSet[lowInd].f) lowInd = i;
            const current = openSet[lowInd];
            
            if(current.r === end.r && current.c === end.c) {
                const path = []; let temp = current;
                while(temp) { path.push({r: temp.r, c: temp.c}); temp = temp.parent; }
                return path.reverse();
            }
            
            openSet.splice(lowInd, 1);
            closedSet.add(`${current.r},${current.c}`);
            
            const neighbors = [[0,1], [0,-1], [1,0], [-1,0]];
            for(let i=0; i<neighbors.length; i++) {
                const nr = current.r + neighbors[i][0], nc = current.c + neighbors[i][1];
                if(nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    if(closedSet.has(`${nr},${nc}`)) continue;
                    
                    const type = mapData[nr][nc];
                    const isTarget = (nr === end.r && nc === end.c);
                    const isOccupied = occupiedTiles.has(`${nr},${nc}`);
                    
                    let isWalkable = true;
                    if ((type === 2 || type === 3) && !isOccupied && !isTarget) isWalkable = false;
                    
                    if(!isWalkable) continue;
                    
                    const gScore = current.g + 1;
                    let neighbor = openSet.find(n => n.r === nr && n.c === nc);
                    
                    if(!neighbor) {
                        neighbor = { r: nr, c: nc, g: gScore, h: Math.abs(nr-end.r)+Math.abs(nc-end.c), f: 0, parent: current };
                        neighbor.f = neighbor.g + neighbor.h;
                        openSet.push(neighbor);
                    } else if(gScore < neighbor.g) {
                        neighbor.g = gScore; neighbor.f = neighbor.g + neighbor.h; neighbor.parent = current;
                    }
                }
            }
        }
        return null;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        this.width = 1080; this.height = 1920; this.assets = new AssetLoader(); this.sound = new SoundManager();
        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null); this.squad2 = Array(9).fill(null);
        this.particles = [];
        this.lordLevel = 1; this.currentXp = 0; 
        this.energy = 50; this.gold = 3000; this.gem = 50; 
        
        this.occupiedTiles = new Set();
        this.occupiedTiles.add(`${PLAYER_START.r},${PLAYER_START.c}`); 
        this.income = 0;
        
        this.selectedArmyId = null;

        this.visibilityMap = new Set();
        this.revealFog(PLAYER_START.r, PLAYER_START.c, 3);
        
        this.grassTexture = this.createGrassPattern();

        this.settings = { bgm: true, sfx: true };

        this.drag = null; this.hover = null; this.selectedItem = null; this.potentialDrag = null; this.dpr = window.devicePixelRatio || 1;
        
        this.armies = [
            { id: 0, name: "Ï†ú1Î∂ÄÎåÄ", color: "#4caf50", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 },
            { id: 1, name: "Ï†ú2Î∂ÄÎåÄ", color: "#2196f3", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 }
        ];

        this.calcLayout(); 
        if(!this.loadGame()) this.initGame();
        else { this.updateLevelStats(); this.updateUI(); }

        setInterval(() => this.regenEnergy(), 1000);
        setInterval(() => this.collectTerritoryIncome(), 3000); 
        window.addEventListener('resize', () => { this.resize(); this.requestRender(); });
        this.resize(); this.setupInput();
        this.assets.loadAll(() => { this.requestRender(); });
        this.loop(); this.updateUI();
        
        if(!localStorage.getItem('kov_uid')) localStorage.setItem('kov_uid', 'U' + Math.floor(Math.random()*1000000));
        document.getElementById('settings-uid').innerText = localStorage.getItem('kov_uid');
    }
    
    createGrassPattern() {
        const c = document.createElement('canvas');
        c.width = 32; c.height = 32;
        const x = c.getContext('2d');
        x.fillStyle = '#4a6e3a';
        x.fillRect(0,0,32,32);
        for(let i=0; i<30; i++) {
            x.fillStyle = Math.random() > 0.5 ? '#567d46' : '#3e5c30'; 
            const px = Math.floor(Math.random()*32);
            const py = Math.floor(Math.random()*32);
            x.fillRect(px, py, 1, 1);
        }
        return c.toDataURL();
    }

    saveGame() {
        try {
            const data = {
                grid: this.grid, gridState: this.gridState, squad1: this.squad1, squad2: this.squad2,
                lordLevel: this.lordLevel, currentXp: this.currentXp, energy: this.energy, gold: this.gold, gem: this.gem,
                occupiedTiles: Array.from(this.occupiedTiles), settings: this.settings,
                visibilityMap: Array.from(this.visibilityMap),
                armies: this.armies 
            };
            localStorage.setItem('kov_save_v1', JSON.stringify(data));
        } catch(e) {}
    }
    loadGame() {
        try {
            const saved = localStorage.getItem('kov_save_v1'); if(!saved) return false;
            const data = JSON.parse(saved);
            this.grid = data.grid || this.grid; this.gridState = data.gridState || this.gridState;
            this.squad1 = data.squad1 || this.squad1; this.squad2 = data.squad2 || this.squad2;
            this.lordLevel = data.lordLevel || 1; this.currentXp = data.currentXp || 0;
            this.energy = data.energy ?? 50; this.gold = data.gold ?? 3000; this.gem = data.gem ?? 50;
            if(data.occupiedTiles) this.occupiedTiles = new Set(data.occupiedTiles);
            if(data.visibilityMap) this.visibilityMap = new Set(data.visibilityMap);
            if(data.settings) { this.settings = data.settings; this.applySettings(); }
            if(data.armies) this.armies = data.armies;
            this.revealFog(PLAYER_START.r, PLAYER_START.c, 3);
            return true;
        } catch(e) { return false; }
    }
    resetGame() {
        if(confirm("Ï†ïÎßê Í≤åÏûÑÏùÑ Ï¥àÍ∏∞Ìôî ÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) { 
            localStorage.removeItem('kov_save_v1'); 
            window.location.reload(); 
        }
    }

    openSettings() { document.getElementById('modal-settings').classList.add('open'); }
    toggleSetting(key, el) {
        this.settings[key] = !this.settings[key]; el.classList.toggle('on');
        const knob = el.querySelector('.toggle-knob'); knob.style.left = this.settings[key] ? '22px' : '2px';
        if (key === 'bgm') { if(this.settings.bgm) this.sound.files.bgm.play().catch(()=>{}); else this.sound.files.bgm.pause(); }
        this.sound.enabled = this.settings.sfx; this.saveGame();
    }
    applySettings() { this.sound.enabled = this.settings.sfx; }
    openRefill(type) {
        const modal = document.getElementById('modal-refill'); const content = document.getElementById('refill-options'); const title = document.getElementById('refill-title');
        content.innerHTML = ""; modal.classList.add('open');
        let data = REFILL_DATA[type]; title.innerText = type === 'energy' ? "ÏóêÎÑàÏßÄ Ï∂©Ï†Ñ" : (type === 'gold' ? "Í≥®Îìú Íµ¨Îß§" : "ÌÅ¨Î¶¨Ïä§ÌÉà ÏÉÅÏ†ê");
        data.forEach(item => {
            const btn = document.createElement('button'); btn.className = "bg-gray-700 hover:bg-gray-600 p-4 rounded-lg flex justify-between items-center text-white border border-gray-600";
            btn.innerHTML = `<span class="font-bold">${item.name}</span><span class="bg-blue-600 px-3 py-1 rounded text-sm">${item.currency==='usd'?'$'+item.cost:'üíé '+item.cost}</span>`;
            btn.onclick = () => {
                if (item.currency === 'crystal') {
                    if (this.gem >= item.cost) { this.gem -= item.cost; if (type === 'energy') this.energy += item.amount; else this.gold += item.amount; this.sound.playCollect(); this.updateUI(); modal.classList.remove('open'); }
                    else { this.showToast("üíé ÌÅ¨Î¶¨Ïä§ÌÉàÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); this.sound.playError(); }
                } else this.showToast("Ïù∏Ïï± Í≤∞Ï†ú Ï§ÄÎπÑ Ï§ëÏûÖÎãàÎã§.");
            }; content.appendChild(btn);
        });
    }
    showLevelUpModal(prevLv, prevEn) {
        document.getElementById('lv-old').innerText = prevLv; document.getElementById('lv-new').innerText = this.lordLevel;
        document.getElementById('en-old').innerText = prevEn; const d = LEVEL_DATA.find(d => d.level === this.lordLevel); document.getElementById('en-new').innerText = d ? d.maxEnergy : 50;
        document.getElementById('modal-levelup').classList.add('open'); const banner = document.getElementById('levelup-banner'); banner.classList.remove('show'); void banner.offsetWidth; banner.classList.add('show'); setTimeout(() => banner.classList.remove('show'), 2500);
    }

    requestRender() { this.isDirty = true; }
    spawnParticles(x, y, color, count, type) { for(let i=0;i<count;i++) this.particles.push(new Particle(x,y,color,type)); this.isDirty=true; }
    regenEnergy() { if (this.energy < this.maxEnergy) { this.energyRegenAcc = (this.energyRegenAcc || 0) + 1; if(this.energyRegenAcc >= 5) { this.energy++; this.energyRegenAcc = 0; this.updateUI(); } } }
    getTaxRate(type) { if (type === 2) return 3; if (type === 3) return 5; return 1; }
    collectTerritoryIncome() {
        if (this.occupiedTiles.size > 0) {
            let totalTax = 0; this.occupiedTiles.forEach(key => { const [r, c] = key.split(',').map(Number); totalTax += this.getTaxRate(FIELD_MAP_DATA[r][c]); });
            this.income = totalTax; this.gold += totalTax; this.updateUI(); if (document.getElementById('field-modal').classList.contains('open')) this.showFloatingText(`+${totalTax} G (Tax)`, this.width/2, this.height/4, '#ffd700');
        }
    }
    calcLayout() {
        const gw = this.width - (CONFIG.gridPadding * 2); this.gridTileSize = Math.floor(gw / CONFIG.gridCols);
        this.gridStartX = CONFIG.gridPadding; this.gridStartY = CONFIG.gridTopY; this.squadCellSize = CONFIG.squadCellSize; 
        const sw = this.squadCellSize * 3; const totalSw = (sw * 2) + CONFIG.squadGap; const sx = Math.floor((this.width - totalSw) / 2);
        this.squad1Rect = { x: sx, y: CONFIG.squadTopY, w: sw, h: sw }; this.squad2Rect = { x: sx + sw + CONFIG.squadGap, y: CONFIG.squadTopY, w: sw, h: sw };
    }
    initGame() {
        this.refreshLockState(); this.grid[3][3] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1, usage: 5 };
        this.grid[5][5] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnits: [] }; // Added storedUnits
        this.updateLevelStats();
    }
    refreshLockState() {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if (this.gridState[r][c] && this.gridState[r][c].type === LOCK_TYPE.OPEN) continue;
            const lvlReq = UNLOCK_LEVEL_MAP[r][c], goldReq = UNLOCK_GOLD_MAP[r][c];
            if (this.lordLevel < lvlReq) this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: lvlReq };
            else if (goldReq > 0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: goldReq };
            else this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
        }
        this.requestRender();
    }
    toggleShop() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        title.innerText = "Í±¥ÏÑ§ ÏÉÅÏ†ê"; content.innerHTML = "";
        if (modal.classList.contains('open') && modal.dataset.mode === 'shop') { this.closeModal(); return; }
        modal.dataset.mode = 'shop'; modal.classList.add('open');
        const grid = document.createElement('div'); grid.className = 'shop-grid';
        SHOP_DATA.forEach(item => {
            const div = document.createElement('div'); div.className = 'shop-item';
            div.innerHTML = `<div class="text-2xl">${item.icon}</div><div class="font-bold text-sm text-white">${item.name}</div><button class="bg-yellow-600 text-white px-3 py-1 mt-2 rounded font-bold text-xs" onclick="game.buyBuilding(${item.type}, ${item.price})">üí∞ ${item.price}</button>`;
            grid.appendChild(div);
        });
        content.appendChild(grid);
    }
    toggleField() {
        const modal = document.getElementById('field-modal');
        if (modal.classList.contains('open') && modal.dataset.mode === 'field') { this.closeModal(); return; }
        this.camera = null; this.renderFieldMap();
    }

    revealFog(r, c, radius = 3) {
        for(let i = -radius; i <= radius; i++) {
            for(let j = -radius; j <= radius; j++) {
                const nr = r + i, nc = c + j;
                if(nr >= 0 && nr < MAP_SIZE && nc >= 0 && nc < MAP_SIZE) {
                    const key = `${nr},${nc}`;
                    if(!this.visibilityMap.has(key)) {
                        this.visibilityMap.add(key);
                        const cell = document.getElementById(`field-cell-${nr}-${nc}`);
                        if(cell) {
                            cell.classList.remove('field-fog');
                            if (!cell.classList.contains('field-occupied') && !cell.classList.contains('field-adjacent')) cell.style.opacity = 0.3;
                            else if (cell.classList.contains('field-adjacent')) cell.style.opacity = 0.6;
                        }
                    }
                }
            }
        }
    }

    renderFieldMap() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        modal.dataset.mode = 'field'; modal.classList.add('open'); title.innerText = "ÏõîÎìú Îßµ (Field)"; content.innerHTML = ""; content.style.overflow = "hidden";
        
        if (this.selectedArmyId !== null) {
            const existingHud = document.querySelector('.selected-army-hud');
            if (existingHud) existingHud.remove();
            
            const armyName = this.armies[this.selectedArmyId].name;
            const hud = document.createElement('div');
            hud.className = 'selected-army-hud';
            hud.innerHTML = `<span class="hud-name">${armyName} ÏÑ†ÌÉùÎê®</span><button class="hud-btn" onclick="game.deselectArmy()">ÏÑ†ÌÉù Ìï¥Ï†ú</button>`;
            content.appendChild(hud);
        }

        const headerDiv = document.createElement('div'); headerDiv.className = "flex justify-between items-center bg-gray-700 p-2 rounded mb-2 text-xs sticky top-0 z-30 shadow-md";
        headerDiv.innerHTML = `<div>üö© Ï†êÎ†π: <span class="text-white font-bold">${this.occupiedTiles.size}</span></div><div>üí∞ ÏÑ∏Í∏à: <span class="text-yellow-400 font-bold">+${this.income}/3sec</span></div>`; content.appendChild(headerDiv);
        const viewport = document.createElement('div'); viewport.id = 'map-viewport'; viewport.style.position = 'relative'; viewport.style.width = '100%'; viewport.style.height = 'calc(100% - 50px)'; viewport.style.overflow = 'hidden'; 
        viewport.style.backgroundColor = '#2e3b23'; 
        viewport.style.touchAction = 'none';
        
        const mapLayer = document.createElement('div'); mapLayer.id = 'map-layer'; mapLayer.style.position = 'absolute'; mapLayer.style.transformOrigin = '0 0'; mapLayer.style.display = 'grid'; mapLayer.style.gridTemplateColumns = `repeat(${MAP_SIZE}, 12px)`; mapLayer.style.gap = '1px'; mapLayer.style.padding = '50px';
        
        const bgImg = this.assets.getImage('field_bg');
        if(bgImg && bgImg.src) {
             mapLayer.style.backgroundImage = `url(${bgImg.src})`;
        } else {
             mapLayer.style.backgroundImage = `url(${this.grassTexture})`;
        }
        mapLayer.style.backgroundRepeat = 'repeat';

        const armyLayer = document.createElement('div'); armyLayer.id = 'army-layer'; armyLayer.style.position = 'absolute'; armyLayer.style.top = '0'; armyLayer.style.left = '0'; armyLayer.style.width = '100%'; armyLayer.style.height = '100%'; armyLayer.style.pointerEvents = 'none'; armyLayer.style.zIndex = '50'; mapLayer.appendChild(armyLayer);

        this.armies.forEach(army => {
            const marker = document.createElement('div'); 
            marker.className = 'army-marker'; 
            if (this.selectedArmyId === army.id) marker.classList.add('selected');
            marker.id = `army-marker-${army.id}`; 
            
            const squadData = army.id === 0 ? this.squad1 : this.squad2;
            let maxLevel = -1;
            let bestUnit = null;
            
            squadData.forEach(u => {
                if (u && u.level > maxLevel) {
                    maxLevel = u.level;
                    bestUnit = u;
                }
            });
            
            if (bestUnit) {
                const img = this.assets.getImage(bestUnit.type, bestUnit.level);
                if (img && img.src) {
                    marker.style.backgroundImage = `url(${img.src})`;
                    marker.innerText = "";
                } else {
                     marker.style.backgroundColor = army.color; 
                     marker.innerText = army.id + 1;
                }
            } else {
                 marker.style.backgroundColor = army.color; 
                 marker.innerText = army.id + 1;
            }

            const TILE_SIZE = 13, x = 50 + (army.c * TILE_SIZE), y = 50 + (army.r * TILE_SIZE); marker.style.transform = `translate(${x}px, ${y}px)`; armyLayer.appendChild(marker);
        });

        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const cell = document.createElement('div'); cell.className = 'field-cell'; cell.id = `field-cell-${r}-${c}`;
                const type = FIELD_MAP_DATA[r][c], key = `${r},${c}`, isOccupied = this.occupiedTiles.has(key), isVisible = this.visibilityMap.has(key);
                let isAdjacent = false; const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                if (!isOccupied) { for (let d of dirs) { const nr = r + d[0], nc = c + d[1]; if (this.occupiedTiles.has(`${nr},${nc}`)) { isAdjacent = true; break; } } }
                
                if (!isVisible) { 
                    cell.classList.add('field-fog'); 
                    mapLayer.appendChild(cell);
                    continue;
                }

                let color = 'rgba(0, 0, 0, 0)'; 
                if (type === 1) { color = '#4285f4'; cell.classList.add('field-castle'); }
                else if (type === 2) { color = '#ea4335'; cell.classList.add('field-gate'); if(isOccupied) cell.classList.add('unlocked'); else cell.classList.add('locked'); }
                else if (type === 3) { color = '#fbbc05'; cell.classList.add('field-fortress'); }
                else if (type === 4) { color = 'rgba(139, 69, 19, 0.4)'; }
                else { color = 'transparent'; }
                
                cell.style.backgroundColor = color;

                if (isOccupied) {
                    cell.classList.add('field-occupied');
                    cell.style.opacity = 1.0;
                } else if (isAdjacent) { 
                    cell.classList.add('field-adjacent'); 
                    cell.style.opacity = 0.6;
                } else { 
                    cell.style.opacity = 1.0;
                }

                cell.onclick = (e) => {
                    e.stopPropagation();
                    if(!this.isDraggingMap) {
                        if (this.selectedArmyId !== null) {
                            this.commandArmy(this.selectedArmyId, r, c, type);
                        } else {
                            this.openSquadSelector(r, c, type);
                        }
                    }
                };

                mapLayer.appendChild(cell);
            }
        }
        viewport.appendChild(mapLayer); content.appendChild(viewport); this.initFieldCamera(viewport, mapLayer);
    }
    
    deselectArmy() {
        this.selectedArmyId = null;
        this.renderFieldMap();
    }

    commandArmy(armyId, targetR, targetC, tileType) {
        const army = this.armies[armyId];
        if (army.state !== 'IDLE') { this.showToast("Î∂ÄÎåÄÍ∞Ä Ïù¥Îèô Ï§ëÏûÖÎãàÎã§."); return; }
        
        let energyCost = 1; let goldCost = 0;
        if (tileType === 2) { energyCost = 5; goldCost = 100; }
        
        const squadData = army.id === 0 ? this.squad1 : this.squad2;
        const stats = this.getSquadStats(squadData);
        
        if (stats.power < 10) { this.showToast("Î≥ëÎ†•Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); return; }

        const path = AStar.findPath({r: army.r, c: army.c}, {r: targetR, c: targetC}, FIELD_MAP_DATA, this.occupiedTiles);
        
        if (!path) { this.showToast("Í∞à Ïàò ÏóÜÎäî ÏßÄÏó≠ÏûÖÎãàÎã§."); return; }
        const dist = path.length - 1;
        if (dist > stats.range) { this.showToast(`Í±∞Î¶¨ Ï¥àÍ≥º (${dist}/${stats.range})`); return; }

        this.startMarch(armyId, targetR, targetC, tileType, energyCost, goldCost, path, stats.speed);
    }

    getSquadStats(squadData) {
        let count = 0, totalMov = 0, minMov = 99;
        squadData.forEach(u => {
            if(u) {
                count++;
                const stats = getData(u.type, u.level);
                if(stats.mov) {
                    totalMov += stats.mov;
                    minMov = Math.min(minMov, stats.mov);
                }
            }
        });
        if(count === 0) return { power: 0, range: 0, speed: 0 };
        
        const baseRange = 4;
        const range = baseRange + (minMov * 2);
        const speed = (minMov >= 2) ? 300 : 500;
        
        return { power: this.getSquadPower(squadData), range, speed };
    }

    getHighestBuildingLevel(unitType) {
        let buildingType = -1;
        if (unitType === ITEM_TYPE.UNIT_INFANTRY) buildingType = ITEM_TYPE.BUILDING_BARRACKS;
        else if (unitType === ITEM_TYPE.UNIT_ARCHER) buildingType = ITEM_TYPE.BUILDING_RANGE;
        else if (unitType === ITEM_TYPE.UNIT_CAVALRY) buildingType = ITEM_TYPE.BUILDING_STABLE;

        if (buildingType === -1) return 10;

        let maxLvl = 0;
        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                const item = this.grid[r][c];
                if (item && item.type === buildingType) {
                    maxLvl = Math.max(maxLvl, item.level);
                }
            }
        }
        return maxLvl || 1;
    }

    openSquadSelector(targetR, targetC, tileType) {
        const existing = document.querySelector('.squad-selector'); if(existing) existing.remove();
        const viewport = document.getElementById('map-viewport'); const selector = document.createElement('div'); selector.className = 'squad-selector';
        
        this.armies.forEach(army => {
            const card = document.createElement('div'); card.className = 'squad-card';
            const isIdle = army.state === 'IDLE';
            const squadData = army.id === 0 ? this.squad1 : this.squad2;
            const stats = this.getSquadStats(squadData);
            
            const path = AStar.findPath({r: army.r, c: army.c}, {r: targetR, c: targetC}, FIELD_MAP_DATA, this.occupiedTiles);
            const dist = path ? path.length - 1 : 999;
            const reachable = path && dist <= stats.range;
            
            let statusHtml = "";
            if (!isIdle) statusHtml = `<div class="squad-status">Ïù¥ÎèôÏ§ë...</div>`;
            else if (stats.power < 10) statusHtml = `<div class="squad-status text-red-400">Î≥ëÎ†• Î∂ÄÏ°±</div>`;
            else if (!path) statusHtml = `<div class="squad-status text-red-400">Í∞à Ïàò ÏóÜÏùå</div>`;
            else if (!reachable) statusHtml = `<div class="squad-status text-orange-400">Í±∞Î¶¨ Ï¥àÍ≥º (${dist}/${stats.range})</div>`;
            else statusHtml = `<div class="squad-status text-green-400">Í±∞Î¶¨: ${dist} / ‚è≥ ${((dist*stats.speed)/1000).toFixed(1)}s</div>`;

            if (!isIdle || stats.power < 10 || !reachable || !path) card.classList.add('disabled');
            
            card.innerHTML = `<div class="font-bold text-white">${army.name}</div>${statusHtml}`;
            if(!card.classList.contains('disabled')) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    let energyCost = 1; let goldCost = 0;
                    if (tileType === 2) { energyCost = 5; goldCost = 100; }
                    
                    this.selectedArmyId = army.id;
                    this.startMarch(army.id, targetR, targetC, tileType, energyCost, goldCost, path, stats.speed);
                    selector.remove();
                    this.renderFieldMap();
                };
            }
            selector.appendChild(card);
        });

        const closeBtn = document.createElement('div'); closeBtn.className = 'squad-card bg-red-900 border-red-700'; closeBtn.innerHTML = '<div class="font-bold text-red-200">Ï∑®ÏÜå</div>';
        closeBtn.onclick = (e) => { e.stopPropagation(); selector.remove(); }; selector.appendChild(closeBtn);
        viewport.appendChild(selector);
        
        const TILE_SIZE = 13; const tx = 50 + (targetC * TILE_SIZE) + 6.5; const ty = 50 + (targetR * TILE_SIZE) + 6.5;
        this.moveCameraTo(tx, ty, viewport, document.getElementById('map-layer'));
    }

    startMarch(armyId, r, c, type, energyCost, goldCost, path, moveSpeed) {
        if(this.energy < energyCost) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${energyCost})`); return; }
        if(this.gold < goldCost) { this.showToast(`Í≥®Îìú Î∂ÄÏ°± (${goldCost})`); return; }

        this.energy -= energyCost; this.gold -= goldCost; this.updateUI();

        const army = this.armies[armyId];
        army.state = 'MOVING_TO';
        army.path = path;
        army.nextStepIndex = 1; // Start from 1 (0 is current pos)
        army.moveInterval = moveSpeed;
        army.lastMoveTime = Date.now();
        army.target = { r, c, type };
        
        this.showToast(`${army.name} ÌñâÍµ∞ ÏãúÏûë!`);
        this.sound.playSpawn(); 
    }

    updateArmies() {
        const now = Date.now();
        const TILE_SIZE = 13;
        
        this.armies.forEach(army => {
            const el = document.getElementById(`army-marker-${army.id}`);
            if (el) {
                 const x = 50 + (army.c * TILE_SIZE);
                 const y = 50 + (army.r * TILE_SIZE);
                 el.style.transform = `translate(${x}px, ${y}px)`;
            }

            if (army.state === 'IDLE') return;

            if (army.state === 'MOVING_TO') {
                if (now - army.lastMoveTime >= army.moveInterval) {
                    army.lastMoveTime = now;
                    if (army.nextStepIndex < army.path.length) {
                        const nextPos = army.path[army.nextStepIndex];
                        army.r = nextPos.r;
                        army.c = nextPos.c;
                        army.nextStepIndex++;
                        this.revealFog(army.r, army.c, 3);
                    } else {
                        this.handleArrival(army);
                    }
                }
            }
        });
    }

    handleArrival(army) {
        const { r, c, type } = army.target;
        if (!this.occupiedTiles.has(`${r},${c}`)) {
            this.occupiedTiles.add(`${r},${c}`);
            if (type === 2) { 
                this.showToast(`‚öîÔ∏è ${army.name} Í¥ÄÎ¨∏ ÎèåÌåå!`); 
                this.sound.playUnlock();
                this.spawnParticles(this.width/2, this.height/2, "#FF0000", 50, "confetti");
            } else { 
                this.showToast(`üö© ${army.name} Ï†êÎ†π ÏÑ±Í≥µ!`); 
                this.sound.playCollect(); 
            }
            if (document.getElementById('field-modal').classList.contains('open')) this.renderFieldMap(); 
        } else {
             this.showToast(`${army.name} ÎèÑÏ∞© ÏôÑÎ£å`);
        }
        army.state = 'IDLE';
        this.updateUI(); this.saveGame();
    }

    moveCameraTo(targetX, targetY, viewport, mapLayer) {
        const viewportWidth = viewport.clientWidth; const viewportHeight = viewport.clientHeight;
        const newX = (viewportWidth / 2) - (targetX * this.camera.scale); const newY = (viewportHeight / 2) - (targetY * this.camera.scale);
        mapLayer.style.transition = 'transform 0.3s ease-out';
        this.camera.x = newX; this.camera.y = newY;
        mapLayer.style.transform = `translate(${this.camera.x}px, ${this.camera.y}px) scale(${this.camera.scale})`;
        setTimeout(() => { mapLayer.style.transition = 'none'; }, 300);
    }

    initFieldCamera(viewport, mapLayer) {
        const TILE_SIZE = 13; const VIEW_TILES = 9;
        const vw = viewport.clientWidth || 300; const vh = viewport.clientHeight || 300;
        let scale; if (this.camera && this.camera.scale) scale = this.camera.scale; else scale = vw / (TILE_SIZE * VIEW_TILES);
        let targetR, targetC; let shouldRecenter = false;
        if (!this.camera) { targetR = PLAYER_START.r; targetC = PLAYER_START.c; shouldRecenter = true; }
        if (shouldRecenter) {
            const targetX = 50 + (targetC * TILE_SIZE) + (TILE_SIZE / 2); const targetY = 50 + (targetR * TILE_SIZE) + (TILE_SIZE / 2);
            const x = (vw / 2) - (targetX * scale); const y = (vh / 2) - (targetY * scale);
            this.camera = { x, y, scale };
        }
        const updateTransform = () => { mapLayer.style.transform = `translate(${this.camera.x}px, ${this.camera.y}px) scale(${this.camera.scale})`; };
        setTimeout(updateTransform, 0);

        let isDragging = false, lastX = 0, lastY = 0, initialPinchDist = 0, initialPinchScale = 1;

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault(); const zoomSpeed = 0.1; const newScale = this.camera.scale + (e.deltaY > 0 ? -zoomSpeed : zoomSpeed) * this.camera.scale;
            if (newScale > 0.2 && newScale < 5) { 
                const centerX = viewport.clientWidth / 2; const centerY = viewport.clientHeight / 2;
                const scaleRatio = newScale / this.camera.scale;
                this.camera.x = centerX - (centerX - this.camera.x) * scaleRatio; this.camera.y = centerY - (centerY - this.camera.y) * scaleRatio;
                this.camera.scale = newScale; updateTransform();
            }
        });
        viewport.addEventListener('mousedown', (e) => { isDragging = true; this.isDraggingMap = false; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            if (Math.abs(e.clientX - lastX) > 5 || Math.abs(e.clientY - lastY) > 5) this.isDraggingMap = true;
            this.camera.x += e.clientX - lastX; this.camera.y += e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; updateTransform();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { isDragging = true; this.isDraggingMap = false; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }
            else if (e.touches.length === 2) { isDragging = false; initialPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); initialPinchScale = this.camera.scale; }
        }, { passive: false });
        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                if (Math.abs(e.touches[0].clientX - lastX) > 5 || Math.abs(e.touches[0].clientY - lastY) > 5) this.isDraggingMap = true;
                this.camera.x += e.touches[0].clientX - lastX; this.camera.y += e.touches[0].clientY - lastY; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; updateTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const newScale = initialPinchScale * (dist / initialPinchDist);
                if (newScale > 0.2 && newScale < 5) {
                    const centerX = viewport.clientWidth / 2; const centerY = viewport.clientHeight / 2;
                    const scaleRatio = newScale / this.camera.scale;
                    this.camera.x = centerX - (centerX - this.camera.x) * scaleRatio; this.camera.y = centerY - (centerY - this.camera.y) * scaleRatio;
                    this.camera.scale = newScale; updateTransform();
                }
            }
        }, { passive: false });
        viewport.addEventListener('touchend', () => { isDragging = false; });
    }

    closeModal() { document.getElementById('field-modal').classList.remove('open'); document.getElementById('modal-refill').classList.remove('open'); document.getElementById('modal-settings').classList.remove('open'); }
    buyBuilding(type, price) {
        if (this.gold < price) { this.showToast("Í≥®Îìú Î∂ÄÏ°±!"); return; }
        const limit = BUILDING_LIMITS[type] || 999; const current = this.getBuildingCount(type);
        if (current >= limit) { this.showToast(`ÏµúÎåÄ Í∞úÏàò ÎèÑÎã¨! (${limit})`); return; }
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.gold -= price; const newItem = { type: type, level: 1, scale: 0 };
                if (type === ITEM_TYPE.BUILDING_CHEST) newItem.usage = 5; if (type === ITEM_TYPE.BUILDING_CAMP) newItem.storedUnits = []; 
                this.grid[r][c] = newItem; this.updateUI(); this.requestRender(); this.showToast("Í±¥ÏÑ§ ÏôÑÎ£å!"); this.closeModal();
                const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;
                this.spawnParticles(cx, cy, "#FFD700", 20, "confetti"); this.sound.playSpawn(); return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }
    getBuildingCount(type) { let count = 0; for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) { if (this.grid[r][c] && this.grid[r][c].type === type) count++; } return count; }
    getHighestBuildingLevel(unitType) {
        let bType = -1; if (unitType === ITEM_TYPE.UNIT_INFANTRY) bType = ITEM_TYPE.BUILDING_BARRACKS; else if (unitType === ITEM_TYPE.UNIT_ARCHER) bType = ITEM_TYPE.BUILDING_RANGE; else if (unitType === ITEM_TYPE.UNIT_CAVALRY) bType = ITEM_TYPE.BUILDING_STABLE;
        if (bType === -1) return 10; let maxLvl = 0; for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) if (this.grid[r][c] && this.grid[r][c].type === bType) maxLvl = Math.max(maxLvl, this.grid[r][c].level); return maxLvl;
    }
    resize() {
        const wrap = document.getElementById('canvas-wrapper'); this.canvas.width = Math.floor(wrap.clientWidth * this.dpr); this.canvas.height = Math.floor(wrap.clientHeight * this.dpr);
        this.canvas.style.width = `${wrap.clientWidth}px`; this.canvas.style.height = `${wrap.clientHeight}px`; this.ctx.resetTransform(); this.ctx.scale(this.canvas.width / this.width, this.canvas.width / this.width); this.ctx.imageSmoothingEnabled = false; this.requestRender();
    }
    addXp(amount) { this.currentXp += amount; if (this.currentXp >= this.requiredXp) this.levelUp(); this.updateUI(); }
    levelUp() {
        if (this.lordLevel >= 15) return; 
        const nextReq = this.requiredXp;
        if(this.currentXp >= nextReq) {
            const prevLv = this.lordLevel;
            const prevEn = this.maxEnergy;
            this.currentXp -= nextReq; this.lordLevel++; this.updateLevelStats(); this.energy = this.maxEnergy; this.refreshLockState();
            this.showLevelUpModal(prevLv, prevEn);
            this.sound.playLevelUp();
            if (this.currentXp >= this.requiredXp) this.levelUp();
        }
    }
    updateLevelStats() {
        const d = LEVEL_DATA.find(d => d.level === this.lordLevel);
        const nextD = LEVEL_DATA.find(d => d.level === this.lordLevel + 1);
        this.maxEnergy = d ? d.maxEnergy : 50;
        this.requiredXp = nextD ? (nextD.xp - d.xp) : 999999;
    }
    selectItem(item, location) { if (this.selectedItem?.item !== item) this.sound.playClick(); this.selectedItem = item ? { item, location } : null; this.updateInfoPanel(); this.requestRender(); }
    updateInfoPanel() {
        const els = { name: document.getElementById('info-name'), desc: document.getElementById('info-desc'), cls: document.getElementById('info-class'), stats: document.getElementById('unit-stats-grid'), btn: document.getElementById('btn-action'), lbl: document.getElementById('action-label'), icon: document.getElementById('action-icon') };
        els.stats.classList.add('hidden'); els.cls.innerText = ""; els.btn.style.opacity = 0.5; els.lbl.innerText = "-";
        if (!this.selectedItem) { els.name.innerText = "ÏÑ†ÌÉùÎêú ÏóÜÏùå"; els.desc.innerText = "Ïú†ÎãõÏù¥ÎÇò Í±¥Î¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî."; return; }
        const item = this.selectedItem.item; const data = getData(item.type, item.level); els.name.innerText = `${data.name} LV.${item.level}`;
        if (item.type < 10) { 
            if (item.type === ITEM_TYPE.BUILDING_CHEST) els.desc.innerText = `ÎÇ®ÏùÄ ÌöüÏàò: ${item.usage}Ìöå`;
            else if (item.type === ITEM_TYPE.BUILDING_CAMP) els.desc.innerText = `Î≥¥Í¥Ä: ${item.storedUnits ? item.storedUnits.length : 0} / ${CAMP_CAPACITY[item.level]}`; // Modified here
            else { els.desc.innerText = "Ïú†Îãõ ÏÉùÏÇ∞"; const cost = data.energy || 1; els.lbl.innerText = `-${cost}‚ö°`; els.btn.style.opacity = 1; els.icon.innerText = ""; }
        } else if (item.type >= 20) { els.desc.innerText = "ÌÅ¥Î¶≠ÌïòÏó¨ ÌöçÎìù"; els.lbl.innerText = "ÌöçÎìù"; els.btn.style.opacity = 1; }
        else { 
            els.cls.innerText = data.class; els.desc.innerText = ""; els.stats.classList.remove('hidden');
            document.getElementById('st-hp').innerText = data.hp; document.getElementById('st-atk').innerText = data.atk; document.getElementById('st-def').innerText = data.def; 
            document.getElementById('st-spd').innerText = data.spd; document.getElementById('st-rng').innerText = data.rng; document.getElementById('st-mov').innerText = data.mov;
            els.lbl.innerText = `+${data.sell}`; els.icon.innerText = "üí∞"; els.btn.style.opacity = 1;
        }
    }
    handleAction() {
        if (!this.selectedItem) return; const { item, location } = this.selectedItem;
        if (item.type >= 10 && item.type < 20) { 
            if(location.zone===ZONES.GRID) this.grid[location.r][location.c]=null; else if(location.zone===ZONES.SQUAD1) this.squad1[location.idx]=null; else this.squad2[location.idx]=null;
            const val = getData(item.type, item.level).sell; this.gold += val; this.showToast(`+${val} G`); this.sound.playCollect(); this.selectItem(null); this.updateUI(); this.requestRender();
        } else if (item.type < 10 && item.type !== ITEM_TYPE.BUILDING_CHEST && item.type !== ITEM_TYPE.BUILDING_CAMP) this.produce(item);
    }
    setupInput() {
        const getPos = e => { const r = this.canvas.getBoundingClientRect(); return { x: ((e.touches?e.touches[0].clientX:e.clientX)-r.left)*(this.width/r.width), y: ((e.touches?e.touches[0].clientY:e.clientY)-r.top)*(this.width/r.width) }; };
        const start = e => {
            this.sound.resume(); const p = getPos(e); const hit = this.getZoneAt(p.x, p.y);
            if (hit) {
                if (hit.zone === ZONES.GRID && this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { this.tryUnlock(hit.r, hit.c); return; }
                let item = hit.zone===ZONES.GRID ? this.grid[hit.r][hit.c] : (hit.zone===ZONES.SQUAD1 ? this.squad1[hit.idx] : this.squad2[hit.idx]);
                this.potentialDrag = { startPos: p, item, hit };
            } else this.selectItem(null);
        };
        const move = e => {
            if (this.potentialDrag && !this.drag) { const p = getPos(e); if (Math.hypot(p.x-this.potentialDrag.startPos.x, p.y-this.potentialDrag.startPos.y) > 10 && this.potentialDrag.item) this.startDrag(this.potentialDrag.item, this.potentialDrag.hit, p); }
            if (this.drag) { this.drag.x = getPos(e).x; this.drag.y = getPos(e).y; this.hover = this.getZoneAt(this.drag.x, this.drag.y); this.requestRender(); }
        };
        const end = e => { if (this.drag) this.endDrag(); else if (this.potentialDrag) this.handleClick(this.potentialDrag.item, this.potentialDrag.hit); this.potentialDrag = null; this.drag = null; };
        this.canvas.onmousedown = start; window.onmousemove = move; window.onmouseup = end;
        this.canvas.ontouchstart = e => { start(e); e.preventDefault(); }; window.ontouchmove = e => { move(e); e.preventDefault(); }; window.ontouchend = end;
    }
    startDrag(item, hit, pos) {
        let cx, cy; if(hit.zone===ZONES.GRID) { cx = this.gridStartX+hit.c*this.gridTileSize; cy = this.gridStartY+hit.r*this.gridTileSize; } else if(hit.zone===ZONES.SQUAD1) { cx = this.squad1Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad1Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; } else { cx = this.squad2Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad2Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; }
        this.drag = { item, startZone: hit, x: pos.x, y: pos.y, offsetX: pos.x-cx, offsetY: pos.y-cy, size: hit.zone===ZONES.GRID?this.gridTileSize:this.squadCellSize };
        if(hit.zone===ZONES.GRID) this.grid[hit.r][hit.c]=null; else if(hit.zone===ZONES.SQUAD1) this.squad1[hit.idx]=null; else this.squad2[hit.idx]=null;
        this.selectItem(item, hit); this.requestRender();
    }
    endDrag() {
        const hit = this.getZoneAt(this.drag.x, this.drag.y); let returned = false;
        if (hit) {
            let target = null; if(hit.zone===ZONES.GRID) { if(this.gridState[hit.r][hit.c].type!==LOCK_TYPE.OPEN) returned=true; else target=this.grid[hit.r][hit.c]; } else if(hit.zone===ZONES.SQUAD1) target=this.squad1[hit.idx]; else target=this.squad2[hit.idx];
            if (!returned) {
                if (!target) { if(hit.zone===ZONES.GRID) this.grid[hit.r][hit.c]=this.drag.item; else if(hit.zone===ZONES.SQUAD1) this.squad1[hit.idx]=this.drag.item; else this.squad2[hit.idx]=this.drag.item; this.selectItem(this.drag.item, hit); }
                else if (target.type===ITEM_TYPE.BUILDING_CAMP && this.drag.item.type>=10 && this.drag.item.type<20 && hit.zone===ZONES.GRID) { 
                    if (!target.storedUnits) target.storedUnits = []; 
                    const cap = CAMP_CAPACITY[target.level] || 4;
                    if (target.storedUnits.length < cap) {
                        target.storedUnits.push(this.drag.item);
                        this.showToast(`Î≥¥Í¥ÄÎê® (${target.storedUnits.length}/${cap})`);
                        this.sound.playClick();
                    } else {
                        this.showToast("Î≥¥Í¥ÄÌï®Ïù¥ Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§.");
                        returned = true;
                    }
                }
                else if (target.type===this.drag.item.type && target.level===this.drag.item.level) {
                    const isUnit = target.type>=10 && target.type<20; const maxLvl = isUnit ? 10 : 5; let canMerge = true;
                    
                    if(isUnit) { 
                        const bLvl = this.getHighestBuildingLevel(target.type); 
                        if(target.level >= bLvl+5) { 
                            this.showToast(`Ìï©ÏÑ± Î∂àÍ∞Ä (Í±¥Î¨º Lv.${target.level-4} ÌïÑÏöî)`); 
                            canMerge=false; returned=true; 
                        } 
                    }

                    if(canMerge && target.level < maxLvl) {
                        target.level++; target.scale=1.3;
                        if(target.type===ITEM_TYPE.BUILDING_CHEST) { 
                            target.usage = Math.floor((target.usage + this.drag.item.usage) * 0.5); 
                        }
                        const xp = MERGE_XP_DATA[target.level-1] || 1;
                        this.addXp(xp); this.showFloatingImage('xp', hit.zone===ZONES.GRID ? this.gridStartX+hit.c*this.gridTileSize : this.drag.x, this.drag.y);
                        this.spawnParticles(this.drag.x, this.drag.y, "#FFD700", 30, "spark"); this.sound.playMerge();
                    } else if(canMerge) { this.showToast("ÏµúÎåÄ Î†àÎ≤®"); returned=true; }
                } else returned=true;
            }
        } else returned=true;
        if (returned) { const s=this.drag.startZone; if(s.zone===ZONES.GRID) this.grid[s.r][s.c]=this.drag.item; else if(s.zone===ZONES.SQUAD1) this.squad1[s.idx]=this.drag.item; else this.squad2[s.idx]=this.drag.item; }
        this.hover=null; this.updateUI(); this.requestRender(); this.drag=null;
    }
    handleClick(item, hit) {
        if(!item) { this.selectItem(null); return; }
        this.selectItem(item, hit);
        if(item.type>=20) this.collectResource(item, hit.r, hit.c);
        else if(item.type===ITEM_TYPE.BUILDING_CAMP) this.ejectCamp(item, hit.r, hit.c);
        else if(item.type<10 && item.type!==ITEM_TYPE.BUILDING_CAMP) {
            if(item.type===ITEM_TYPE.BUILDING_CHEST) this.produceFromChest(item, hit.r, hit.c);
            else this.produce(item);
        }
    }
    getZoneAt(x, y) {
        const check = (rect, rows, cols, size) => { if(x>=rect.x && x<rect.x+rect.w && y>=rect.y && y<rect.y+rect.h) { const c=Math.floor((x-rect.x)/size), r=Math.floor((y-rect.y)/size); if(c>=0 && c<cols && r>=0 && r<rows) return {c,r,idx:r*3+c}; } return null; };
        let res = check(this.squad1Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if(res) return {zone:ZONES.SQUAD1, ...res};
        res = check(this.squad2Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if(res) return {zone:ZONES.SQUAD2, ...res};
        if(x>=this.gridStartX && x<this.gridStartX+this.gridTileSize*CONFIG.gridCols && y>=this.gridStartY && y<this.gridStartY+this.gridTileSize*CONFIG.gridRows) { const c=Math.floor((x-this.gridStartX)/this.gridTileSize), r=Math.floor((y-this.gridStartY)/this.gridTileSize); if(c>=0 && c<CONFIG.gridCols && r>=0 && r<CONFIG.gridRows) return {zone:ZONES.GRID, r, c, idx:r*8+c}; }
        return null;
    }
    produce(building) {
        const buildingData = BUILDING_DATA[building.type];
        const stats = buildingData ? buildingData[building.level] : BUILDING_DATA[ITEM_TYPE.BUILDING_BARRACKS][1]; // Default fallback

        if(this.energy < stats.energy) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${stats.energy})`); return; }
        
        let unitType = ITEM_TYPE.UNIT_INFANTRY; 
        if(building.type === ITEM_TYPE.BUILDING_RANGE) unitType = ITEM_TYPE.UNIT_ARCHER; 
        else if(building.type === ITEM_TYPE.BUILDING_STABLE) unitType = ITEM_TYPE.UNIT_CAVALRY;

        let lvl = 1;
        const r = Math.random() * 100;
        let sum = 0;
        for(let i=0; i<stats.probs.length; i++) { 
            sum += stats.probs[i]; 
            if(r <= sum) { lvl = i+1; break; } 
        }

        if(this.spawnItem({type: unitType, level: lvl, scale: 0})) { 
            this.energy -= stats.energy; 
            this.updateUI(); 
            this.requestRender(); 
            this.sound.playSpawn(); 
        } else { 
            this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±"); 
        }
    }
    produceFromChest(chest, r, c) {
        if(this.energy<1) { this.showToast("ÏóêÎÑàÏßÄ Î∂ÄÏ°±"); return; }
        
        // Drop logic
        const table = CHEST_DROP_TABLE[chest.level] || CHEST_DROP_TABLE[1]; 
        let total=0; 
        table.forEach(e=>total+=e.prob); 
        let rnd=Math.random()*total, code=table[0].code; 
        for(let e of table) { if(rnd<e.prob){code=e.code;break;} rnd-=e.prob; }
        const info = getInfoFromCode(code);

        if(this.spawnItem({type:info.type, level:info.level, scale:0})) { 
            this.energy--; 
            chest.usage--; 
            chest.scale=1.2; 
            
            // Check usage
            if (chest.usage <= 0) {
                this.grid[r][c] = null; // Remove from grid
                if (this.selectedItem && this.selectedItem.item === chest) {
                    this.selectItem(null); // Deselect
                }
                this.showToast("ÏÉÅÏûêÍ∞Ä ÏÇ¨ÎùºÏ°åÏäµÎãàÎã§.");
            }
            
            this.updateUI(); 
            this.requestRender(); 
            this.sound.playSpawn(); 
        } else {
            this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±");
        }
    }
    spawnItem(item) {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) { this.grid[r][c]=item; const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2; this.spawnParticles(cx, cy, "#EEE", 10, "smoke"); return true; }
        return false;
    }
    ejectCamp(camp, r, c) {
        if(!camp.storedUnits || camp.storedUnits.length === 0) { this.showToast("ÎπÑÏñ¥ÏûàÏùå"); return; }
        const moves = [[0,1],[0,-1],[1,0],[-1,0]]; 
        for(let m of moves) { 
            const nr=r+m[0], nc=c+m[1]; 
            if(nr>=0 && nr<8 && nc>=0 && nc<8 && this.gridState[nr][nc].type===LOCK_TYPE.OPEN && !this.grid[nr][nc]) { 
                const unit = camp.storedUnits.pop(); // Take last added unit (LIFO)
                this.grid[nr][nc] = unit; 
                this.requestRender(); 
                this.sound.playClick(); 
                this.showToast(`Í∫ºÎÉÑ (${camp.storedUnits.length} ÎÇ®Ïùå)`);
                return; 
            } 
        }
        this.showToast("Ï£ºÎ≥Ä Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }
    collectResource(item, r, c) {
        const val = ITEM_VALUES[item.level] || 1; let pColor = "#fff";
        if(item.type===ITEM_TYPE.ITEM_GOLD) { this.gold+=val; this.showToast(`+${val}G`); pColor="#FFD700"; } else if(item.type===ITEM_TYPE.ITEM_ENERGY) { this.energy=Math.min(this.energy+val, this.maxEnergy); this.showToast(`+${val}‚ö°`); pColor="#00FFFF"; } else { this.gem+=val; this.showToast(`+${val}üíé`); pColor="#FF00FF"; }
        const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2; this.spawnParticles(cx, cy, pColor, 15, "spark"); this.sound.playCollect(); this.grid[r][c]=null; this.updateUI(); this.requestRender();
    }
    tryUnlock(r, c) {
        const l = this.gridState[r][c];
        if(l.type===LOCK_TYPE.GOLD) { if(this.gold>=l.value) { this.gold-=l.value; this.gridState[r][c]={type:LOCK_TYPE.OPEN}; this.showToast("Ìï¥Í∏à!"); this.spawnParticles(this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, this.gridStartY + r * this.gridTileSize + this.gridTileSize/2, "#FFF", 20, "confetti"); this.sound.playUnlock(); } else { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); this.sound.playError(); } }
        else if(l.type===LOCK_TYPE.LEVEL) { if(this.lordLevel>=l.value) { this.gridState[r][c]={type:LOCK_TYPE.OPEN}; this.showToast("Ìï¥Í∏à!"); this.spawnParticles(this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, this.gridStartY + r * this.gridTileSize + this.gridTileSize/2, "#FFF", 20, "confetti"); this.sound.playUnlock(); } else { this.showToast(`LV.${l.value} ÌïÑÏöî`); this.sound.playError(); } }
        this.updateUI(); this.requestRender();
    }
    loop() {
        // Ïä§ÏøºÎìú Ïù¥Îèô ÏóÖÎç∞Ïù¥Ìä∏ (Îß§ ÌîÑÎ†àÏûÑ)
        this.updateArmies();

        if(this.isDirty || this.drag) {
            this.ctx.clearRect(0,0,this.width,this.height);
            this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50", ZONES.SQUAD1); this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3", ZONES.SQUAD2);
            for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
                const x = this.gridStartX+c*this.gridTileSize, y = this.gridStartY+r*this.gridTileSize;
                const isHover = this.hover && this.hover.zone===ZONES.GRID && this.hover.r===r && this.hover.c===c, isSel = this.selectedItem && this.selectedItem.location.zone===ZONES.GRID && this.selectedItem.location.r===r && this.selectedItem.location.c===c;
                this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c], isHover, isSel);
            }
            if(this.drag) this.drawItem(this.drag.x-this.drag.size/2, this.drag.y-this.drag.size/2, this.drag.size, this.drag.item, true);
            for(let i=this.particles.length-1; i>=0; i--) { this.particles[i].update(); this.particles[i].draw(this.ctx); if(this.particles[i].life <= 0) this.particles.splice(i, 1); }
            let anim = false; this.grid.flat().concat(this.squad1).concat(this.squad2).forEach(i=>{ if(i&&i.scale!==1){ i.scale+=(i.scale<1?0.1:-0.05); if(Math.abs(i.scale-1)<0.05)i.scale=1; anim=true; } });
            this.isDirty = anim || !!this.drag || this.particles.length > 0;
        }
        requestAnimationFrame(()=>this.loop());
    }
    getSquadPower(s) { let p=0; for(let u of s) if(u&&u.type>=10&&u.type<20) { const d=getData(u.type,u.level); if(d.hp) p+=(d.hp+d.atk+d.def); } return p; }
    drawSquad(data, rect, label, color, zone) {
        const cp = this.getSquadPower(data);
        this.ctx.fillStyle = color; this.ctx.font="bold 40px sans-serif"; this.ctx.textAlign="center"; this.ctx.fillText(`${label}`, rect.x+rect.w/2, rect.y-22);
        this.ctx.fillStyle = color+"11"; this.ctx.fillRect(rect.x-5, rect.y-5, rect.w+10, rect.h+10);
        this.ctx.font="bold 40px sans-serif"; this.ctx.fillStyle = "#fff"; this.ctx.fillText(`‚öîÔ∏è ${cp}`, rect.x+rect.w/2, rect.y + rect.h + 39); 
        for(let i=0; i<9; i++) {
            const x = rect.x+(i%3)*this.squadCellSize, y = rect.y+Math.floor(i/3)*this.squadCellSize;
            const isHover = this.hover && this.hover.zone===zone && this.hover.idx===i, isSel = this.selectedItem && this.selectedItem.location.zone===zone && this.selectedItem.location.idx===i;
            this.drawCell(x, y, this.squadCellSize, data[i], {type:LOCK_TYPE.OPEN}, isHover, isSel);
        }
    }
    drawCell(x, y, s, item, lock, isHover, isSel) {
        const p=2, size=s-p*2;
        this.ctx.fillStyle = lock.type===LOCK_TYPE.OPEN ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.5)"; this.ctx.fillRect(x+p, y+p, size, size);
        if(isSel) { this.ctx.lineWidth=6; this.ctx.strokeStyle="#0f0"; this.ctx.strokeRect(x+p, y+p, size, size); }
        else if(isHover) { this.ctx.lineWidth=4; this.ctx.strokeStyle="#ff0"; this.ctx.strokeRect(x+p, y+p, size, size); }
        else { this.ctx.lineWidth=2; this.ctx.strokeStyle="rgba(0,0,0,0.3)"; this.ctx.strokeRect(x+p, y+p, size, size); }
        if(lock.type!==LOCK_TYPE.OPEN) {
            const img = this.assets.getImage(lock.type===LOCK_TYPE.GOLD?'1804':'lock');
            if(img && img.complete && img.naturalWidth>0) { const isz=size*0.6; this.ctx.drawImage(img, x+(s-isz)/2, y+(s-isz)/2, isz, isz); this.ctx.fillStyle=lock.type===LOCK_TYPE.GOLD?"#ffd700":"#fff"; this.ctx.font="bold 20px sans-serif"; this.ctx.textAlign="center"; this.ctx.strokeStyle="black"; this.ctx.lineWidth=4; const txt = lock.type===LOCK_TYPE.GOLD ? `üí∞${lock.value}` : `LV.${lock.value}`; this.ctx.strokeText(txt, x+s/2, y+s/2); this.ctx.fillText(txt, x+s/2, y+s/2); }
        } else if(item && item !== this.drag?.item) this.drawItem(x, y, s, item);
    }
    drawItem(x, y, s, item, isDrag=false) {
        const sc=isDrag?1.1:item.scale, p=4, ds=(s-p*2)*sc, offset=(s-ds)/2; const img = this.assets.getImage(item.type, item.level);
        
        // --- ADDED: LEVEL COLOR BORDER ---
        const lvColor = LEVEL_COLORS[item.level] || "#fff";
        
        if(img && img.complete && img.naturalWidth>0) {
            if(isDrag) { this.ctx.shadowColor="black"; this.ctx.shadowBlur=15; }
            const drawSize = ds * 1.2; const drawOffset = (s - drawSize) / 2;
            this.ctx.drawImage(img, x + drawOffset, y + drawOffset, drawSize, drawSize); this.ctx.shadowBlur=0;
        } else {
            let c = "#cfd8dc"; let sym = "‚ùì";
            if(item.type===ITEM_TYPE.BUILDING_BARRACKS) { c="#795548"; sym="üè†"; } else if(item.type===ITEM_TYPE.BUILDING_RANGE) { c="#388e3c"; sym="üéØ"; } else if(item.type===ITEM_TYPE.BUILDING_STABLE) { c="#1976d2"; sym="üê¥"; } else if(item.type===ITEM_TYPE.BUILDING_CHEST) { c="#ffa000"; sym="üéÅ"; } else if(item.type===ITEM_TYPE.BUILDING_CAMP) { c="#5d4037"; sym="‚õ∫"; } else if(item.type===ITEM_TYPE.UNIT_INFANTRY) { c="#eeeeee"; sym="üõ°Ô∏è"; } else if(item.type===ITEM_TYPE.UNIT_ARCHER) { c="#c8e6c9"; sym="üèπ"; } else if(item.type===ITEM_TYPE.UNIT_CAVALRY) { c="#bbdefb"; sym="üêé"; } else if(item.type===ITEM_TYPE.ITEM_GOLD) { c="#fff176"; sym="üí∞"; } else if(item.type===ITEM_TYPE.ITEM_ENERGY) { c="#80deea"; sym="‚ö°"; } else if(item.type===ITEM_TYPE.ITEM_CRYSTAL) { c="#e1bee7"; sym="üíé"; }
            const drawSize = ds * 1.2; const drawOffset = (s - drawSize) / 2;
            this.ctx.fillStyle = c; this.roundRect(x + drawOffset, y + drawOffset, drawSize, drawSize, 12); this.ctx.fill(); this.ctx.strokeStyle = "rgba(0,0,0,0.4)"; this.ctx.lineWidth = 2; this.ctx.stroke(); this.ctx.fillStyle = "rgba(0,0,0,0.6)"; this.ctx.font = `${Math.floor(drawSize*0.5)}px sans-serif`; this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle"; this.ctx.fillText(sym, x+s/2, y+s/2);
        }
        
        this.ctx.lineWidth = 3;
        this.ctx.strokeStyle = lvColor;
        this.ctx.strokeRect(x+p, y+p, ds, ds);

        const bx=x+s/2, by=y+ds; 
        if(item.type>=10 || item.type<10) { 
            this.ctx.fillStyle="rgba(0,0,0,0.8)"; this.ctx.beginPath(); this.ctx.arc(bx, by-10, 10, 0, Math.PI*2); this.ctx.fill(); this.ctx.strokeStyle="#fff"; this.ctx.lineWidth=1; this.ctx.stroke(); this.ctx.fillStyle="#fff"; this.ctx.font="bold 12px sans-serif"; this.ctx.textAlign="center"; this.ctx.fillText(item.level, bx, by-6);
        }
        
        // --- MODIFIED: Camp Storage Display ---
        if(item.type===ITEM_TYPE.BUILDING_CAMP) { 
            const count = item.storedUnits ? item.storedUnits.length : 0;
            const cap = CAMP_CAPACITY[item.level] || 4;
            
            // Styled Text Box
            const text = `${count}/${cap}`;
            this.ctx.font = "bold 16px sans-serif";
            const textW = this.ctx.measureText(text).width + 8;
            
            this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; // Semi-transparent black bg
            this.ctx.beginPath();
            this.ctx.roundRect(bx - textW/2, y + s/2 - 10, textW, 20, 4);
            this.ctx.fill();
            
            this.ctx.fillStyle = "#fff"; // White text
            this.ctx.shadowColor = "black";
            this.ctx.shadowBlur = 2;
            this.ctx.fillText(text, bx, y + s/2 + 6);
            this.ctx.shadowBlur = 0; // Reset shadow
        }
    }
    roundRect(x,y,w,h,r){this.ctx.beginPath();this.ctx.moveTo(x+r,y);this.ctx.arcTo(x+w,y,x+w,y+h,r);this.ctx.arcTo(x+w,y+h,x,y+h,r);this.ctx.arcTo(x,y+h,x,y,r);this.ctx.arcTo(x,y,x+w,y,r);this.ctx.closePath();}
    showToast(msg) { if (msg.includes("Î∂ÄÏ°±") || msg.includes("Î∂àÍ∞Ä")) this.sound.playError(); const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1000); }
    showFloatingImage(key, x, y) {
        const img = this.assets.getImage(key); if(!img) return; const el = document.createElement('img'); el.src = img.src; el.className='float-img';
        const r = this.canvas.getBoundingClientRect(); el.style.left = ((x/this.width)*r.width)+"px"; el.style.top = ((y/this.height)*r.height)+"px"; document.getElementById('canvas-wrapper').appendChild(el); setTimeout(()=>el.remove(), 1000);
    }
    showFloatingText(text, x, y, color) {
        const el = document.createElement('div');
        el.innerText = text; el.id = 'income-float'; el.style.color = color;
        // Simple positioning relative to container
        el.style.left = '50%'; el.style.top = '20%'; el.style.transform = 'translate(-50%, 0)';
        document.getElementById('canvas-wrapper').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }
    updateUI() {
        document.getElementById('energy-display').innerText=`${this.energy}/${this.maxEnergy}`; document.getElementById('gold-display').innerText=this.gold; document.getElementById('gem-display').innerText=this.gem; document.getElementById('level-display').innerText=`LORD LV.${this.lordLevel}`; document.getElementById('xp-text').innerText=`${this.currentXp} / ${this.requiredXp}`; document.getElementById('xp-bar').style.width=`${(this.currentXp/this.requiredXp)*100}%`;
        this.saveGame();
    }
}
const game = new Game();
</script>
</body>
</html>