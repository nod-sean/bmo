<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KOV Prototype v60 - Money Bag for Gold Locks</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            background-color: #000;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            margin: 0; padding: 0;
            display: flex; justify-content: center; align-items: center;
            width: 100vw; height: 100dvh;
        }

        #game-container {
            position: relative;
            background-color: #4e342e;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            width: 100%; height: 100%;
            max-width: 56.25vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        .header-panel {
            flex: 0 0 auto;
            background: linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.0));
            color: white;
            padding: 8px 12px;
            padding-top: max(8px, env(safe-area-inset-top));
            z-index: 20;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #3e2723;
            width: 100%;
        }
        
        canvas {
            display: block;
            width: 100%; height: 100%;
            image-rendering: pixelated;
        }

        .footer-panel {
            flex: 0 0 auto;
            background: #d7ccc8; 
            border-top: 4px solid #8d6e63;
            padding: 8px 12px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            display: flex; align-items: center; justify-content: space-between;
            min-height: 90px;
            z-index: 20;
        }

        .res-pill {
            background: rgba(0,0,0,0.6); border: 1px solid #555;
            border-radius: 99px; padding: 2px 8px 2px 4px;
            display: flex; align-items: center; gap: 4px;
            font-weight: bold; font-size: 12px; color: #fff;
        }
        .res-icon { width: 20px; height: 20px; object-fit: contain; }

        .info-box {
            flex: 1;
            background: #f5f5f5;
            border: 1px solid #8d6e63;
            border-radius: 6px;
            padding: 4px 8px;
            height: 64px;
            display: flex; flex-direction: column; justify-content: center;
            color: #3e2723; margin: 0 6px; overflow: hidden;
        }

        .stat-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;
            font-size: 10px; font-weight: bold; color: #444; margin-top: 2px;
        }
        .stat-item { display: flex; align-items: center; gap: 2px; }
        .stat-icon { font-size: 10px; }

        .action-btn {
            width: 50px; height: 50px;
            background: linear-gradient(to bottom, #ffca28, #ff6f00);
            border: 1px solid #e65100;
            border-radius: 8px;
            color: white; font-weight: bold;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 10px; box-shadow: 0 2px 0 #bf360c;
        }
        .action-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #bf360c; }
        
        .btn-open { background: linear-gradient(to bottom, #26a69a, #00695c); border-color: #004d40; box-shadow: 0 2px 0 #004d40; }
        .world-btn { background: linear-gradient(to bottom, #42a5f5, #1565c0); border-color: #0d47a1; box-shadow: 0 2px 0 #0d47a1; }
        .chat-btn { background: linear-gradient(to bottom, #78909c, #455a64); border-color:#37474f; box-shadow: 0 2px 0 #263238; }
        .build-btn { background: linear-gradient(to bottom, #8d6e63, #5d4037); border-color: #3e2723; box-shadow: 0 2px 0 #3e2723; }

        #shop-modal {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 50%;
            background: rgba(30, 20, 15, 0.98);
            border-top: 4px solid #8d6e63;
            border-radius: 20px 20px 0 0;
            z-index: 50;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            display: flex; flex-direction: column;
            padding: 20px;
            color: white;
        }
        #shop-modal.open { transform: translateY(0); }
        
        .shop-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;
            overflow-y: auto;
        }
        .shop-item {
            background: #4e342e; border: 2px solid #8d6e63; border-radius: 10px;
            padding: 10px; display: flex; flex-direction: column; align-items: center;
        }
        .shop-btn {
            background: #ffb300; color: black; font-weight: bold; padding: 5px 15px;
            border-radius: 5px; margin-top: 5px; font-size: 12px;
        }

        #field-modal {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 60%;
            background: rgba(30, 20, 15, 0.98);
            border-top: 4px solid #8d6e63;
            border-radius: 20px 20px 0 0;
            z-index: 50;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            display: flex; flex-direction: column;
            padding: 20px;
            color: white;
        }
        #field-modal.open { transform: translateY(0); }

        #toast {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px;
            border-radius: 20px; font-size: 14px; font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; border: 2px solid #ffd700;
            white-space: nowrap; z-index: 100;
        }

        /* Level Up Banner Animation */
        #levelup-banner {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) scale(0);
            z-index: 150; pointer-events: none;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #levelup-banner.show { transform: translate(-50%, -50%) scale(1); }
        #levelup-banner img { width: 300px; max-width: 80vw; filter: drop-shadow(0 0 10px gold); }

        /* DEBUG OVERLAY */
        #debug-overlay {
            position: absolute; top: 60px; left: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.7); color: white;
            padding: 10px; border-radius: 8px; font-size: 11px;
            pointer-events: none; z-index: 999;
            display: none;
            text-align: left;
        }
        
        .float-text {
            position: absolute; color: #ffd700; font-weight: bold; font-size: 16px;
            text-shadow: 1px 1px 0 #000; pointer-events: none;
            animation: floatUp 1s ease-out forwards; z-index: 50;
            display: flex; align-items: center; gap: 4px;
        }
        .float-img {
            position: absolute; pointer-events: none; z-index: 60;
            animation: floatUpImg 1.2s ease-out forwards;
            width: 60px; height: auto;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
        @keyframes floatUpImg {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-10px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Level Up Banner -->
    <div id="levelup-banner">
        <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/levelup.png" onerror="this.style.display='none'">
    </div>

    <!-- Header -->
    <div class="header-panel">
        <div class="flex justify-between mb-1">
            <div class="res-pill">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/energy.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='‚ö°'+this.nextElementSibling.innerText">
                <span id="energy-display">50/50</span>
            </div>
            <div class="res-pill">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/gold.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üí∞'+this.nextElementSibling.innerText">
                <span id="gold-display">3000</span>
            </div>
            <div class="res-pill">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/crystal.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üíé'+this.nextElementSibling.innerText">
                <span id="gem-display">50</span>
            </div>
        </div>
        <div class="flex flex-col w-full">
            <div class="flex justify-between items-end px-1">
                <span class="font-bold text-yellow-400 text-xs" id="level-display">LORD LV.1</span>
                <span class="font-bold text-gray-300 text-xs flex items-center gap-1">
                    <span id="xp-text">0 / 10</span>
                    <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/xp.png" class="h-3 object-contain" onerror="this.style.display='none';this.previousElementSibling.innerText+=' XP'">
                </span>
            </div>
            <div class="w-full bg-gray-800 h-2 mt-1 rounded-full overflow-hidden border border-gray-600 relative">
                <div id="xp-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
            </div>
        </div>
        <div class="flex gap-2 mt-1 opacity-30 hover:opacity-100 transition-opacity justify-end">
            <button onclick="game.cheatEnergy()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚ö°+30</button>
            <button onclick="game.spawnChest()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">üéÅÏÉÅÏûê</button>
            <button onclick="game.cheatLevelUp()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚¨ÜÔ∏èLvUP</button>
        </div>
    </div>

    <!-- Canvas -->
    <div id="canvas-wrapper">
        <div id="debug-overlay"></div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Footer -->
    <div class="footer-panel">
        <button class="action-btn chat-btn" onclick="game.showToast('Ï±ÑÌåÖ Í∏∞Îä• Ï§ÄÎπÑ Ï§ë')">
            <span class="sell-icon">üí¨</span>
        </button>
        
        <div class="info-box" id="info-panel">
            <div class="flex justify-between items-center mb-0">
                <span class="font-bold text-sm truncate" id="info-name">ÏÑ†ÌÉùÎêú ÏóÜÏùå</span>
                <span class="text-[10px] text-gray-500 font-bold" id="info-class"></span>
            </div>
            <!-- ÏÉÅÏÑ∏ Ïä§ÌÉØ Í∑∏Î¶¨Îìú -->
            <div class="stat-grid hidden" id="unit-stats-grid">
                <div class="stat-item"><span class="stat-icon">‚ù§</span><span id="st-hp">0</span></div>
                <div class="stat-item"><span class="stat-icon">‚öî</span><span id="st-atk">0</span></div>
                <div class="stat-item"><span class="stat-icon">üõ°Ô∏è</span><span id="st-def">0</span></div>
                <div class="stat-item"><span class="stat-icon">ü¶∂</span><span id="st-spd">0</span></div>
                <div class="stat-item"><span class="stat-icon">üéØ</span><span id="st-rng">0</span></div>
                <div class="stat-item"><span class="stat-icon">üèÉ</span><span id="st-mov">0</span></div>
            </div>
            <div class="text-[10px] text-gray-600 leading-tight truncate mt-1" id="info-desc">Ïú†ÎãõÏù¥ÎÇò Í±¥Î¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>
        </div>

        <button class="action-btn" id="btn-action" onclick="game.handleAction()">
            <span class="sell-icon" id="action-icon">üí∞</span>
            <span id="action-label" style="font-size: 9px;">Sell</span>
        </button>
        
        <button class="action-btn world-btn" onclick="game.toggleFieldModal()" style="margin-left:5px;">
            <span class="sell-icon">üåç</span><span style="font-size: 9px;">ÌïÑÎìú</span>
        </button>
    </div>

    <!-- Field/Construction Modal -->
    <div id="field-modal">
        <div class="flex justify-between items-center mb-2 border-b border-gray-600 pb-2">
            <div>
                <h2 class="text-xl font-bold text-yellow-400">ÌïÑÎìú ÏàòÏßë(ÎØ∏Íµ¨ÌòÑ)</h2>
                <p class="text-xs text-gray-400">Í±¥Î¨ºÏùÑ Í±¥ÏÑ§ÌïòÏó¨ ÏòÅÏßÄÎ•º ÌôïÏû•ÌïòÏÑ∏Ïöî.</p>
            </div>
            <button onclick="game.toggleFieldModal()" class="w-8 h-8">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/x.png" class="w-full h-full object-contain" onerror="this.style.display='none';this.parentNode.innerText='‚úñ'">
            </button>
        </div>
        <div class="shop-grid" id="shop-list"></div>
    </div>
    
    <div id="toast">Î©îÏãúÏßÄ</div>
</div>

<script>
/**
 * KOV Prototype v60 - Money Bag for Gold Locks
 * FEATURE: Replaced lock icon with money bag (1804.png) for gold-unlockable slots.
 */

// --- CONFIGURATION ---
const GITHUB_REPO = "nod-sean/bmo";
const GITHUB_BRANCH = "main";
const LOCAL_BASE_PATH = "./"; 
const SEARCH_PATHS = ["", "img/", "assets/", "images/"];
const EXTENSIONS = [".png", ".PNG", ".jpg", ".jpeg"];

// --- ASSET KEYS ---
const ASSET_KEYS = [
    // Units: Infantry
    '1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110',
    // Units: Archer
    '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210',
    // Buildings: Barracks
    '2101', '2102', '2103', '2104', '2105',
    // Buildings: Range
    '2201', '2204', '2205',
    // Buildings: Stable
    '2301', '2302', '2303', '2304',
    // Buildings: Chest
    '2801', '2802', '2803', '2804', '2805',
    // Resources: Gold
    '1801', '1802', '1803', '1804', '1805', 
    // Resources: Energy
    '1811', '1812', '1813', '1814', '1815',
    // Resources: Crystal
    '1821', '1822', '1823', '1824', '1825',
    // UI Elements
    'lock', 'gold', 'energy', 'crystal', 'xp', 'levelup', '5xp', '10xp', 'x', 'LV'
];

// --- DATA ---
const LEVEL_DATA = [ { level: 1, xp: 10, maxEnergy: 50 }, { level: 2, xp: 22, maxEnergy: 52 }, { level: 3, xp: 37, maxEnergy: 54 }, { level: 4, xp: 55, maxEnergy: 56 }, { level: 5, xp: 77, maxEnergy: 58 }, { level: 6, xp: 103, maxEnergy: 60 }, { level: 7, xp: 134, maxEnergy: 62 }, { level: 8, xp: 169, maxEnergy: 64 }, { level: 9, xp: 209, maxEnergy: 66 }, { level: 10, xp: 254, maxEnergy: 68 }, { level: 11, xp: 304, maxEnergy: 70 }, { level: 12, xp: 359, maxEnergy: 72 }, { level: 13, xp: 420, maxEnergy: 74 }, { level: 14, xp: 486, maxEnergy: 76 }, { level: 15, xp: 558, maxEnergy: 78 }];
const MERGE_XP_DATA = { 1:1, 2:2, 3:4, 4:5, 5:6, 6:8, 7:10, 8:15, 9:20, 10:0 };
const BUILDING_STATS = { 1: { energy: 1, probs: [90, 10, 0, 0, 0] }, 2: { energy: 2, probs: [0, 90, 10, 0, 0] }, 3: { energy: 3, probs: [0, 45, 55, 0, 0] }, 4: { energy: 4, probs: [0, 0, 90, 10, 0] }, 5: { energy: 5, probs: [0, 0, 80, 10, 10] } };
const ITEM_VALUES = { 1: 1, 2: 2, 3: 6, 4: 14, 5: 32 };
const UNLOCK_GOLD_MAP = [[100, 50, 30, 20, 20, 30, 50, 100], [50, 40, 10, 5,  5,  10, 40, 50], [30, 10, 0,  0,  0,  0,  10, 30], [20, 5,  0,  0,  0,  0,  5,  20], [20, 5,  0,  0,  0,  0,  5,  20], [30, 10, 0,  0,  0,  0,  10, 30], [50, 40, 10, 5,  5,  10, 40, 50], [100, 50, 30, 20, 20, 30, 50, 100]];
const UNLOCK_LEVEL_MAP = [[24, 20, 14, 10, 10, 14, 20, 24], [23, 18, 6,  2,  2,  6,  18, 21], [17, 8,  0,  0,  0,  0,  9,  15], [13, 5,  0,  0,  0,  0,  3,  11], [13, 5,  0,  0,  0,  0,  3,  11], [17, 8,  0,  0,  0,  0,  9,  15], [23, 19, 7,  4,  4,  7,  19, 21], [25, 22, 16, 12, 12, 16, 22, 25]];

const CHEST_DROP_TABLE = {
    1: [ {code: 1801, prob: 50}, {code: 1811, prob: 50} ],
    2: [ {code: 1801, prob: 25}, {code: 1802, prob: 25}, {code: 1811, prob: 25}, {code: 1812, prob: 25} ],
    3: [ {code: 1801, prob: 20}, {code: 1802, prob: 20}, {code: 1803, prob: 10}, {code: 1811, prob: 20}, {code: 1812, prob: 20}, {code: 1813, prob: 10} ],
    4: [ {code: 1802, prob: 20}, {code: 1803, prob: 20}, {code: 1804, prob: 5}, {code: 1812, prob: 20}, {code: 1813, prob: 20}, {code: 1814, prob: 5}, {code: 1821, prob: 10} ],
    5: [ {code: 1802, prob: 15}, {code: 1803, prob: 20}, {code: 1804, prob: 10}, {code: 1812, prob: 15}, {code: 1813, prob: 20}, {code: 1814, prob: 10}, {code: 1821, prob: 5}, {code: 1825, prob: 5} ] 
};

const CONFIG = { gridCols: 8, gridRows: 8, gridTopY: 520, gridPadding: 20, squadCols: 3, squadRows: 3, squadTopY: 50, squadGap: 20, squadCellSize: 130 };
const ITEM_TYPE = { EMPTY: 0, BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3, BUILDING_CHEST: 4, BUILDING_CAMP: 5, UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12, ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22 };
const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2' };
const BUILDING_LIMITS = { [ITEM_TYPE.BUILDING_BARRACKS]: 3, [ITEM_TYPE.BUILDING_RANGE]: 2, [ITEM_TYPE.BUILDING_STABLE]: 2, [ITEM_TYPE.BUILDING_CAMP]: 2, [ITEM_TYPE.BUILDING_CHEST]: 99 };
const SHOP_DATA = [ { type: ITEM_TYPE.BUILDING_BARRACKS, name: "Î≥ëÏòÅ", price: 100, icon: "üè†" }, { type: ITEM_TYPE.BUILDING_RANGE, name: "ÏÇ¨Í≤©Ïû•", price: 200, icon: "üéØ" }, { type: ITEM_TYPE.BUILDING_STABLE, name: "ÎßàÍµ¨Í∞Ñ", price: 500, icon: "üê¥" }, { type: ITEM_TYPE.BUILDING_CAMP, name: "Ï∫†ÌîÑ", price: 300, icon: "‚õ∫" }, { type: ITEM_TYPE.BUILDING_CHEST, name: "Î≥¥Î¨ºÏÉÅÏûê", price: 500, icon: "üéÅ" } ];

function getInfoFromCode(code) {
    if (code >= 1100 && code < 1200) return { type: ITEM_TYPE.UNIT_INFANTRY, level: code % 100 };
    if (code >= 1200 && code < 1300) return { type: ITEM_TYPE.UNIT_ARCHER, level: code % 100 };
    if (code >= 1300 && code < 1400) return { type: ITEM_TYPE.UNIT_CAVALRY, level: code % 100 };
    if (code >= 1800 && code < 1810) return { type: ITEM_TYPE.ITEM_GOLD, level: code - 1800 };
    if (code >= 1810 && code < 1820) return { type: ITEM_TYPE.ITEM_ENERGY, level: code - 1810 };
    if (code >= 1820 && code < 1830) return { type: ITEM_TYPE.ITEM_CRYSTAL, level: code - 1820 };
    return { type: ITEM_TYPE.ITEM_GOLD, level: 1 };
}

function getData(type, level) {
    const code = getCode(type, level);
    if (DB.units[code]) return DB.units[code];
    if (DB.buildings[code]) return DB.buildings[code];
    if (DB.items[code]) return DB.items[code];
    if (type >= 10 && type < 20) {
        const base = DB.units[getCode(type, 1)];
        if(base) return { name: base.name, class: base.class, hp: base.hp * level, atk: base.atk * level, def: base.def * level, spd: base.spd, rng: base.rng, mov: base.mov, sell: base.sell * level };
    }
    return { name: "Ïïå Ïàò ÏóÜÏùå", energy: 1, probs: [100], earn: 1, sell: 0 };
}
function getCode(type, level) {
    if (type === ITEM_TYPE.UNIT_INFANTRY) return 1100 + level;
    if (type === ITEM_TYPE.UNIT_ARCHER) return 1200 + level;
    if (type === ITEM_TYPE.UNIT_CAVALRY) return 1300 + level;
    if (type === ITEM_TYPE.BUILDING_BARRACKS) return 2100 + level;
    if (type === ITEM_TYPE.BUILDING_RANGE) return 2200 + level;
    if (type === ITEM_TYPE.BUILDING_STABLE) return 2300 + level;
    if (type === ITEM_TYPE.BUILDING_CHEST) return 2800 + level;
    if (type === ITEM_TYPE.BUILDING_CAMP) return 2810 + level;
    if (type === ITEM_TYPE.ITEM_GOLD) return 1800 + level;
    if (type === ITEM_TYPE.ITEM_ENERGY) return 1810 + level;
    if (type === ITEM_TYPE.ITEM_CRYSTAL) return 1820 + level;
    return 0;
}
const DB = {
    units: { 
        1101: { name:"ÎØºÎ≥ë", class:"Î≥¥Î≥ë", hp:10, atk:5, def:10, spd:5, rng:1, mov:1, sell:0 },
        1201: { name:"Í∂ÅÎ≥ë", class:"Í∂ÅÎ≥ë", hp:8, atk:8, def:5, spd:7, rng:3, mov:1, sell:0 },
        1301: { name:"Í∏∞Î≥ë", class:"Í∏∞Î≥ë", hp:15, atk:4, def:8, spd:9, rng:1, mov:1, sell:0 }
    },
    buildings: { 
        2101: { name: "Î≥ëÏòÅ" }, 
        2201: { name: "ÏÇ¨Í≤©Ïû•" },
        2301: { name: "ÎßàÍµ¨Í∞Ñ" },
        2801: { name: "Îèô ÏÉÅÏûê" }, 2802: { name: "ÏùÄ ÏÉÅÏûê" }, 2803: { name: "Í∏à ÏÉÅÏûê" }, 2804: { name: "Î∞±Í∏à ÏÉÅÏûê" }, 2805: { name: "Îã§Ïù¥ÏïÑ ÏÉÅÏûê" },
        2811: { name: "Ï∫†ÌîÑ" } 
    },
    items: { 
        1801: { name: "Í≥®Îìú", earn: 1 }, 1802: { name: "Í≥®Îìú", earn: 2 }, 1803: { name: "Í≥®Îìú", earn: 6 }, 1804: { name: "Í≥®Îìú", earn: 14 }, 1805: { name: "Í≥®Îìú", earn: 32 },
        1811: { name: "ÏóêÎÑàÏßÄ", earn: 1 }, 1812: { name: "ÏóêÎÑàÏßÄ", earn: 2 }, 1813: { name: "ÏóêÎÑàÏßÄ", earn: 6 }, 1814: { name: "ÏóêÎÑàÏßÄ", earn: 14 }, 1815: { name: "ÏóêÎÑàÏßÄ", earn: 32 },
        1821: { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 1 }, 1822: { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 2 }, 1823: { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 6 }, 1824: { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 14 }, 1825: { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 32 }
    }
};

// --- SMART ASSET LOADER ---
class AssetLoader {
    constructor() { 
        this.images = {}; 
        this.failedKeys = new Set();
        this.successUrls = {}; 
    }
    
    tryLoadImage(key, pathIndex, extIndex, useLocal) {
        return new Promise((resolve, reject) => {
            if (!useLocal && pathIndex >= SEARCH_PATHS.length) {
                this.failedKeys.add(key);
                resolve(null); 
                return;
            }

            const img = new Image();
            if (!useLocal) img.crossOrigin = "Anonymous"; 

            let url = "";
            if (useLocal) {
                if (extIndex >= EXTENSIONS.length) { resolve(null); return; }
                url = `${LOCAL_BASE_PATH}${key}${EXTENSIONS[extIndex]}`;
            } else {
                if (extIndex >= EXTENSIONS.length) {
                    this.tryLoadImage(key, pathIndex + 1, 0, false).then(resolve);
                    return;
                }
                const folder = SEARCH_PATHS[pathIndex];
                const ext = EXTENSIONS[extIndex];
                url = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/${folder}${key}${ext}`;
            }

            img.onload = () => {
                this.images[key] = img;
                this.successUrls[key] = url;
                resolve(img);
            };

            img.onerror = () => {
                this.tryLoadImage(key, pathIndex, extIndex + 1, useLocal).then(resolve);
            };

            img.src = url;
        });
    }

    async loadAll(callback) {
        this.failedKeys.clear();
        const promises = ASSET_KEYS.map(async (key) => {
            let result = await this.tryLoadImage(key, 0, 0, true);
            if (result) return;
            await this.tryLoadImage(key, 0, 0, false);
        });
        await Promise.all(promises);
        this.reportStatus();
        if (callback) callback();
    }

    reportStatus() {
        const overlay = document.getElementById('debug-overlay');
        const failCount = this.failedKeys.size;
        if (failCount > 0) {
            overlay.style.display = 'block';
            const missing = Array.from(this.failedKeys).join(', ');
            overlay.innerHTML = `<strong style="color:#ff5252">‚ö†Ô∏è Ïù¥ÎØ∏ÏßÄ Î°úÎî© Ïã§Ìå® (${failCount}Í∞ú)</strong><br><div style="margin-top:5px; color:#ddd; font-size:10px;">${missing}</div>`;
        } else { overlay.style.display = 'none'; }
    }

    getImage(type, level) {
        if(typeof type === 'string') return this.images[type]; 
        
        const code = getCode(type, level);
        if (this.images[code]) return this.images[code];
        
        if (level > 1) { 
            for(let l=level-1; l>=1; l--) {
                const lowerCode = getCode(type, l);
                if(this.images[lowerCode]) return this.images[lowerCode];
            }
        }
        for(let l=level+1; l<=10; l++) {
             const higherCode = getCode(type, l);
             if(this.images[higherCode]) return this.images[higherCode];
        }
        return null;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = 1080; this.height = 1920;
        this.assets = new AssetLoader();
        
        this.assets.loadAll(() => {
            this.requestRender();
        });

        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null);
        this.squad2 = Array(9).fill(null);
        
        this.lordLevel = 1; this.currentXp = 0; this.updateLevelStats();
        this.energy = this.maxEnergy; this.gold = 3000; this.gem = 50; 
        this.drag = null; this.hover = null; this.selectedItem = null;
        this.potentialDrag = null;

        this.calcLayout();
        this.initGame();
        
        this.dpr = window.devicePixelRatio || 1;
        window.addEventListener('resize', () => { this.resize(); this.requestRender(); });
        this.resize();

        const start = e => this.handleInput(e, 'start');
        const move = e => this.handleInput(e, 'move');
        const end = e => this.handleInput(e, 'end');
        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        this.canvas.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end);

        this.initShopUI();
        this.loop();
        this.updateUI();
    }

    requestRender() { this.isDirty = true; }

    calcLayout() {
        const gridAvailW = this.width - (CONFIG.gridPadding * 2);
        this.gridTileSize = Math.floor(gridAvailW / CONFIG.gridCols);
        this.gridStartX = CONFIG.gridPadding;
        this.gridStartY = CONFIG.gridTopY;
        this.squadCellSize = CONFIG.squadCellSize; 
        const squadW = this.squadCellSize * 3;
        const totalSquadW = (squadW * 2) + CONFIG.squadGap;
        const squadStartX = Math.floor((this.width - totalSquadW) / 2);
        this.squad1Rect = { x: squadStartX, y: CONFIG.squadTopY, w: squadW, h: squadW };
        this.squad2Rect = { x: squadStartX + squadW + CONFIG.squadGap, y: CONFIG.squadTopY, w: squadW, h: squadW };
    }

    initGame() {
        this.refreshLockState(); 
        this.grid[3][3] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1 };
    }

    refreshLockState() {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if (this.gridState[r][c] && this.gridState[r][c].type === LOCK_TYPE.OPEN) continue;
            const lvlReq = UNLOCK_LEVEL_MAP[r][c];
            const goldReq = UNLOCK_GOLD_MAP[r][c];
            if (this.lordLevel < lvlReq) this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: lvlReq };
            else if (goldReq > 0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: goldReq };
            else this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
        }
        this.requestRender();
    }

    initShopUI() {
        const list = document.getElementById('shop-list');
        list.innerHTML = "";
        SHOP_DATA.forEach(item => {
            const div = document.createElement('div');
            div.className = 'shop-item';
            div.innerHTML = `<div class="text-2xl">${item.icon}</div><div class="font-bold text-sm text-white">${item.name}</div><button class="shop-btn" onclick="game.buyBuilding(${item.type}, ${item.price})">üí∞ ${item.price}</button>`;
            list.appendChild(div);
        });
    }

    toggleFieldModal() { const modal = document.getElementById('field-modal'); modal.classList.toggle('open'); }
    toggleShop() { this.toggleFieldModal(); }

    buyBuilding(type, price) {
        if (this.gold < price) { this.showToast("Í≥®Îìú Î∂ÄÏ°±!"); return; }
        const limit = BUILDING_LIMITS[type] || 999;
        const current = this.getBuildingCount(type);
        if (current >= limit) { this.showToast(`ÏµúÎåÄ Í∞úÏàò ÎèÑÎã¨! (${limit})`); return; }

        for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.gold -= price;
                this.grid[r][c] = { type: type, level: 1, scale: 0 };
                this.updateUI(); this.requestRender();
                this.showToast("Í±¥ÏÑ§ ÏôÑÎ£å!");
                this.toggleFieldModal();
                return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }

    getBuildingCount(type) {
        let count = 0;
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) { if (this.grid[r][c] && this.grid[r][c].type === type) count++; }
        return count;
    }

    getHighestBuildingLevel(unitType) {
        let bType = -1;
        if (unitType === ITEM_TYPE.UNIT_INFANTRY) bType = ITEM_TYPE.BUILDING_BARRACKS;
        if (unitType === ITEM_TYPE.UNIT_ARCHER) bType = ITEM_TYPE.BUILDING_RANGE;
        if (unitType === ITEM_TYPE.UNIT_CAVALRY) bType = ITEM_TYPE.BUILDING_STABLE;
        if (bType === -1) return 10; 
        let maxLvl = 0;
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if (this.grid[r][c] && this.grid[r][c].type === bType) {
                if (this.grid[r][c].level > maxLvl) maxLvl = this.grid[r][c].level;
            }
        }
        return maxLvl;
    }

    resize() {
        const wrapper = document.getElementById('game-container');
        const canvasWrap = document.getElementById('canvas-wrapper');
        const width = canvasWrap.clientWidth;
        const height = canvasWrap.clientHeight;
        this.canvas.width = Math.floor(width * this.dpr);
        this.canvas.height = Math.floor(height * this.dpr);
        this.canvas.style.width = `${width}px`;
        this.canvas.style.height = `${height}px`;
        this.ctx.resetTransform();
        const scale = (width * this.dpr) / this.width;
        this.ctx.scale(scale, scale);
        this.ctx.imageSmoothingEnabled = false;
        this.requestRender();
    }

    addXp(amount) {
        this.currentXp += amount;
        if (this.currentXp >= this.requiredXp) this.levelUp();
        this.updateUI();
    }
    levelUp() {
        if (this.lordLevel >= 15) return; 
        this.currentXp -= this.requiredXp;
        this.lordLevel++;
        this.updateLevelStats();
        this.energy = this.maxEnergy; 
        this.refreshLockState();
        
        // Show Level Up Banner
        const banner = document.getElementById('levelup-banner');
        banner.classList.add('show');
        setTimeout(() => banner.classList.remove('show'), 2000);
        
        if (this.currentXp >= this.requiredXp) this.levelUp();
    }
    cheatLevelUp() { this.addXp(this.requiredXp - this.currentXp); }
    updateLevelStats() {
        const levelData = LEVEL_DATA.find(d => d.level === this.lordLevel) || LEVEL_DATA[LEVEL_DATA.length - 1];
        this.maxEnergy = levelData.maxEnergy;
        this.requiredXp = levelData.xp;
    }

    selectItem(item, location) {
        this.selectedItem = item ? { item, location } : null;
        this.updateInfoPanel();
        this.requestRender();
    }

    updateInfoPanel() {
        const nameEl = document.getElementById('info-name');
        const descEl = document.getElementById('info-desc');
        const classEl = document.getElementById('info-class');
        const statsGrid = document.getElementById('unit-stats-grid');
        const actionBtn = document.getElementById('btn-action');
        const actionLabel = document.getElementById('action-label');
        const actionIcon = document.getElementById('action-icon');

        statsGrid.classList.add('hidden');
        classEl.innerText = "";
        actionBtn.className = 'action-btn'; 
        
        if (!this.selectedItem || !this.selectedItem.item) {
            nameEl.innerText = "ÏÑ†ÌÉùÎêú ÏóÜÏùå";
            descEl.innerText = "Ïú†ÎãõÏù¥ÎÇò Í±¥Î¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.";
            actionLabel.innerText = "-";
            actionBtn.style.opacity = 0.5;
            return;
        }

        const item = this.selectedItem.item;
        const data = getData(item.type, item.level); // Use DB
        let desc = ""; let price = 0; let actionType = "sell"; 

        if (item.type < 10) { 
            if(item.type === ITEM_TYPE.BUILDING_CHEST) { 
                desc = "ÏïÑÏù¥ÌÖú ÏÉùÏÇ∞"; 
                actionType = "none";
            } else if (item.type === ITEM_TYPE.BUILDING_CAMP) {
                desc = "Ïú†Îãõ Î≥¥Í¥Ä";
            } else {
                desc = "Ïú†Îãõ ÏÉùÏÇ∞";
            }
            if(item.type !== ITEM_TYPE.BUILDING_CHEST) {
                 const energyCost = data.energy || 1;
                 desc += ` (ÏÜåÎ™® ‚ö°${energyCost})`;
            }
            if (item.type === ITEM_TYPE.BUILDING_CAMP) desc += ` (Î≥¥Í¥Ä:${item.storedUnit ? 'O' : 'X'})`;
            
        } else if (item.type >= 20) {
            const val = data.earn || 1;
            desc = `ÌÅ¥Î¶≠ÌïòÏó¨ +${val} ÌöçÎìù`;
        } else {
            // Unit Stats
            classEl.innerText = data.class;
            desc = `${data.name} Î∂ÄÎåÄ`;
            price = data.sell;
            
            statsGrid.classList.remove('hidden');
            document.getElementById('st-hp').innerText = data.hp;
            document.getElementById('st-atk').innerText = data.atk;
            document.getElementById('st-def').innerText = data.def;
            document.getElementById('st-spd').innerText = data.spd;
            document.getElementById('st-rng').innerText = data.rng;
            document.getElementById('st-mov').innerText = data.mov;
        }

        nameEl.innerText = data.name + (item.type < 20 ? ` LV.${item.level}` : ` LV.${item.level}`); 
        if(!statsGrid.classList.contains('hidden')) desc = ""; 
        descEl.innerText = desc;
        
        if (actionType === "open") {
            // Deprecated flow, now chests behave like buildings
            actionLabel.innerText = "-"; actionBtn.style.opacity = 0.5;
        } else if (price > 0) { 
            actionLabel.innerText = `+${price}`; actionIcon.innerText = "üí∞"; actionBtn.style.opacity = 1; 
        } else { 
            actionLabel.innerText = "-"; actionIcon.innerText = "üí∞"; actionBtn.style.opacity = 0.5; 
        }
    }

    handleAction() {
        if (!this.selectedItem || !this.selectedItem.item) return;
        const { item } = this.selectedItem;
        if (item.type === ITEM_TYPE.BUILDING_CHEST) return;
        this.sellSelectedItem();
    }

    sellSelectedItem() {
        if (!this.selectedItem || !this.selectedItem.item) return;
        const { item, location } = this.selectedItem;
        const data = getData(item.type, item.level);
        let price = data.sell || 0;

        if (price > 0) {
            if (location.zone === ZONES.GRID) this.grid[location.r][location.c] = null;
            else if (location.zone === ZONES.SQUAD1) this.squad1[location.idx] = null;
            else if (location.zone === ZONES.SQUAD2) this.squad2[location.idx] = null;
            this.gold += price; this.showToast(`${price} Í≥®Îìú ÌöçÎìù!`);
            this.selectedItem = null; this.updateInfoPanel(); this.updateUI(); this.requestRender();
        } else { this.showToast("ÌåêÎß§ Î∂àÍ∞Ä"); }
    }

    goToWorld() { this.toggleFieldModal(); }

    getGamePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const scaleX = this.width / rect.width;
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleX };
    }

    getZoneAt(x, y) {
        if (x >= this.squad1Rect.x && x < this.squad1Rect.x + this.squad1Rect.w && y >= this.squad1Rect.y && y < this.squad1Rect.y + this.squad1Rect.h) {
            const c = Math.floor((x - this.squad1Rect.x) / this.squadCellSize);
            const r = Math.floor((y - this.squad1Rect.y) / this.squadCellSize);
            // BUG FIX: Boundary Check
            if (c >= 0 && c < CONFIG.squadCols && r >= 0 && r < CONFIG.squadRows)
                return { zone: ZONES.SQUAD1, idx: r * 3 + c, r, c };
        }
        if (x >= this.squad2Rect.x && x < this.squad2Rect.x + this.squad2Rect.w && y >= this.squad2Rect.y && y < this.squad2Rect.y + this.squad2Rect.h) {
            const c = Math.floor((x - this.squad2Rect.x) / this.squadCellSize);
            const r = Math.floor((y - this.squad2Rect.y) / this.squadCellSize);
             if(c >= 0 && c < CONFIG.squadCols && r >= 0 && r < CONFIG.squadRows)
                return { zone: ZONES.SQUAD2, idx: r * 3 + c, r, c };
        }
        if (x >= this.gridStartX && x < this.gridStartX + this.gridTileSize * CONFIG.gridCols && y >= this.gridStartY && y < this.gridStartY + this.gridTileSize * CONFIG.gridRows) {
            const c = Math.floor((x - this.gridStartX) / this.gridTileSize);
            const r = Math.floor((y - this.gridStartY) / this.gridTileSize);
            if (c >= 0 && c < CONFIG.gridCols && r >= 0 && r < CONFIG.gridRows) {
                return { zone: ZONES.GRID, r, c, idx: r*8+c };
            }
        }
        return null;
    }

    handleInput(e, state) {
        if(state === 'start') e.preventDefault();
        let pos = (state !== 'end') ? this.getGamePos(e) : { x: this.drag?.x||0, y: this.drag?.y||0 };

        if (state === 'start') {
            const hit = this.getZoneAt(pos.x, pos.y);
            
            if (hit) {
                if (hit.zone === ZONES.GRID) {
                    if (this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { 
                        this.tryUnlock(hit.r, hit.c); return; 
                    }
                }
                
                let item = null;
                if(hit.zone === ZONES.GRID) item = this.grid[hit.r][hit.c];
                else if(hit.zone === ZONES.SQUAD1) item = this.squad1[hit.idx];
                else if(hit.zone === ZONES.SQUAD2) item = this.squad2[hit.idx];

                this.potentialDrag = { startPos: pos, item: item, hit: hit };
            } else {
                this.selectItem(null); 
            }
        }
        else if (state === 'move') {
            if (this.potentialDrag && !this.drag) {
                const dist = Math.hypot(pos.x - this.potentialDrag.startPos.x, pos.y - this.potentialDrag.startPos.y);
                if (dist > 10 && this.potentialDrag.item) {
                    this.startDrag(this.potentialDrag.item, this.potentialDrag.hit, pos);
                }
            }
            if (this.drag) {
                this.drag.x = pos.x; this.drag.y = pos.y; this.hover = this.getZoneAt(pos.x, pos.y); 
                this.requestRender();
            }
        }
        else if (state === 'end') {
            if (this.drag) {
                this.endDrag();
            } else if (this.potentialDrag) {
                // Click (Mouse Up without Drag)
                this.handleClick(this.potentialDrag.item, this.potentialDrag.hit);
            }
            this.potentialDrag = null;
            this.drag = null;
        }
    }

    startDrag(item, hit, pos) {
        let cellX, cellY, cellSize;
        if (hit.zone === ZONES.GRID) {
            cellX = this.gridStartX + hit.c * this.gridTileSize; cellY = this.gridStartY + hit.r * this.gridTileSize; cellSize = this.gridTileSize;
        } else if (hit.zone === ZONES.SQUAD1) {
            const c = hit.idx % 3, r = Math.floor(hit.idx / 3);
            cellX = this.squad1Rect.x + c * this.squadCellSize; cellY = this.squad1Rect.y + r * this.squadCellSize; cellSize = this.squadCellSize;
        } else {
            const c = hit.idx % 3, r = Math.floor(hit.idx / 3);
            cellX = this.squad2Rect.x + c * this.squadCellSize; cellY = this.squad2Rect.y + r * this.squadCellSize; cellSize = this.squadCellSize;
        }
        
        this.drag = { item: item, startZone: hit, x: pos.x, y: pos.y, offsetX: pos.x - cellX, offsetY: pos.y - cellY, size: cellSize };
        this.hover = hit;
        
        if(hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = null;
        else if(hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = null;
        else if(hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = null;
        
        this.selectItem(item, hit);
        this.requestRender();
    }

    endDrag() {
        const hit = this.getZoneAt(this.drag.x, this.drag.y);
        let returned = false;
        
        if (hit) {
            let target = null;
            let isLocked = false;
            if(hit.zone === ZONES.GRID) {
                if(this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) isLocked = true;
                else target = this.grid[hit.r][hit.c];
            }
            else if(hit.zone === ZONES.SQUAD1) target = this.squad1[hit.idx];
            else if(hit.zone === ZONES.SQUAD2) target = this.squad2[hit.idx];

            if (isLocked) returned = true;
            else if (!target) {
                // Move to empty
                if(hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = this.drag.item;
                else if(hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = this.drag.item;
                else if(hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = this.drag.item;
                this.selectItem(this.drag.item, hit);
            }
            else if (target) {
                // Camp Logic
                if (hit.zone === ZONES.GRID && target.type === ITEM_TYPE.BUILDING_CAMP && !target.storedUnit && this.drag.item.type >= 10 && this.drag.item.type < 20) {
                    target.storedUnit = this.drag.item; this.showToast("Î≥¥Í¥Ä ÏôÑÎ£å");
                    this.selectItem(target, hit);
                }
                // MERGE LOGIC (Buildings & Units & Chests)
                else if (target.type === this.drag.item.type && target.level === this.drag.item.level) {
                    const isUnit = (target.type >= 10 && target.type < 20);
                    const maxLvl = isUnit ? 10 : 5;

                    if (isUnit) {
                        const buildingLvl = this.getHighestBuildingLevel(target.type);
                        const unitCap = Math.min(10, buildingLvl + 5);
                        if (target.level >= unitCap) { this.showToast(`ÏÑ±Ïû• ÌïúÍ≥Ñ! (Í±¥Î¨º Lv.${unitCap-5} ÌïÑÏöî)`); returned = true; }
                    }

                    if (!returned && target.level < maxLvl) {
                        target.level++; target.scale = 1.3;
                        if (isUnit) {
                            const gain = MERGE_XP_DATA[target.level - 1] || 0;
                            if (gain > 0) { 
                                this.addXp(gain); 
                                // Show Image Toast for XP
                                if (gain === 5 || gain === 10) {
                                    this.showFloatingImage(`${gain}xp`, hit.x, hit.y);
                                } else {
                                    this.showToast(`XP +${gain}`, hit.x, hit.y); 
                                }
                            } else { 
                                this.showToast("Level Up!", hit.x, hit.y); 
                            }
                        } else { 
                            this.showToast(`Upgraded!`, hit.x, hit.y); 
                        }
                        this.selectItem(target, hit);
                    } else if (!returned) {
                        this.showToast("ÏµúÎåÄ Î†àÎ≤®ÏûÖÎãàÎã§", hit.x, hit.y);
                        returned = true;
                    }
                }
                else returned = true; 
            }
        } else returned = true; 

        if (returned) {
            const s = this.drag.startZone;
            if(s.zone === ZONES.GRID) this.grid[s.r][s.c] = this.drag.item;
            else if(s.zone === ZONES.SQUAD1) this.squad1[s.idx] = this.drag.item;
            else if(s.zone === ZONES.SQUAD2) this.squad2[s.idx] = this.drag.item;
            this.selectItem(this.drag.item, s);
        }
        this.hover = null; 
        this.updateUI(); 
        this.requestRender();
    }

    handleClick(item, hit) {
        if (!item) { this.selectItem(null); return; }
        this.selectItem(item, hit);
        
        if (item.type >= 20) { this.collectResource(item, hit.r, hit.c); return; }
        if (item.type === ITEM_TYPE.BUILDING_CAMP) { this.ejectCamp(item, hit.r, hit.c); return; }
        // Produce from Buildings AND Chests
        if (item.type < 10 && item.type !== ITEM_TYPE.BUILDING_CAMP) { 
            if (item.type === ITEM_TYPE.BUILDING_CHEST) this.produceFromChest(item, hit.r, hit.c);
            else this.produce(item); 
            return; 
        }
    }

    // --- Rendering ---
    loop() {
        if (!this.isDirty && !this.drag) {
            requestAnimationFrame(() => this.loop());
            return;
        }

        this.ctx.clearRect(0, 0, this.width, this.height);
        this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50", ZONES.SQUAD1);
        this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3", ZONES.SQUAD2);
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            const x = this.gridStartX + c * this.gridTileSize;
            const y = this.gridStartY + r * this.gridTileSize;
            const isHover = (this.hover && this.hover.zone === ZONES.GRID && this.hover.r === r && this.hover.c === c);
            const isSelected = (this.selectedItem && this.selectedItem.location && this.selectedItem.location.zone === ZONES.GRID && this.selectedItem.location.r === r && this.selectedItem.location.c === c);
            this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c], isHover, isSelected);
        }
        if(this.drag) {
            const dx = Math.floor(this.drag.x - this.drag.offsetX);
            const dy = Math.floor(this.drag.y - this.drag.offsetY);
            this.drawItem(dx, dy, this.drag.size, this.drag.item, true);
        }
        let animating = false;
        this.grid.flat().forEach(i => { if(i && i.scale!==1) { this.anim(i); animating=true; } });
        this.isDirty = animating || !!this.drag;
        requestAnimationFrame(() => this.loop());
    }
    anim(i) { 
        if (i.scale === 1) return;
        if (i.scale < 1) { i.scale += 0.1; if (i.scale >= 1) i.scale = 1; } 
        else if (i.scale > 1) { i.scale -= 0.05; if (i.scale <= 1) i.scale = 1; }
    }

    drawSquad(d, r, l, c, zoneName) {
        this.ctx.fillStyle = c; this.ctx.font = "bold 30px sans-serif"; this.ctx.textAlign="center"; 
        this.ctx.fillText(l, Math.floor(r.x + r.w/2), Math.floor(r.y - 15));
        this.ctx.fillStyle = c + "33"; this.ctx.fillRect(Math.floor(r.x-5), Math.floor(r.y-5), Math.floor(r.w+10), Math.floor(r.h+10));
        for(let i=0; i<9; i++) {
            const cx = r.x + (i%3)*this.squadCellSize; const cy = r.y + Math.floor(i/3)*this.squadCellSize;
            const isHover = (this.hover && this.hover.zone === zoneName && this.hover.idx === i);
            const isSelected = (this.selectedItem && this.selectedItem.location && this.selectedItem.location.zone === zoneName && this.selectedItem.location.idx === i);
            this.drawCell(cx, cy, this.squadCellSize, d[i], {type:LOCK_TYPE.OPEN}, isHover, isSelected);
        }
    }

    drawCell(x, y, s, i, l, isHover, isSelected) {
        const p = 2; const is = s - p*2;
        
        // Background
        this.ctx.fillStyle = (l.type !== LOCK_TYPE.OPEN) ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.1)";
        this.ctx.fillRect(Math.floor(x+p), Math.floor(y+p), Math.floor(is), Math.floor(is));
        
        // Border
        if (isSelected) { this.ctx.strokeStyle = "#00ff00"; this.ctx.lineWidth = 6; }
        else if (isHover) { this.ctx.strokeStyle = "#ffff00"; this.ctx.lineWidth = 4; }
        else { this.ctx.strokeStyle = "rgba(0,0,0,0.3)"; this.ctx.lineWidth = 2; }
        this.ctx.strokeRect(Math.floor(x+p), Math.floor(y+p), Math.floor(is), Math.floor(is));

        // Content
        if(l.type !== LOCK_TYPE.OPEN) {
            // Determine which icon to draw
            let iconKey = 'lock'; // Default to lock
            if (l.type === LOCK_TYPE.GOLD) {
                iconKey = '1804'; // Use Gold Bag for gold unlocks
            }

            const iconImg = this.assets.getImage(iconKey);
            const lvImg = this.assets.getImage('LV');
            
            if (iconImg && iconImg.complete) {
                const iconSize = is * 0.8; 
                this.ctx.drawImage(iconImg, x + (is-iconSize)/2, y + (is-iconSize)/2, iconSize, iconSize);
                
                // Text styling
                this.ctx.fillStyle = "#FFFFFF"; 
                this.ctx.font = "bold 22px sans-serif"; // Slightly larger font
                this.ctx.textAlign = "center"; 
                this.ctx.textBaseline = "middle";
                this.ctx.shadowColor = "black";
                this.ctx.shadowBlur = 4;
                this.ctx.lineWidth = 5; // Thicker stroke
                this.ctx.strokeStyle = "black"; 
                
                let text = `${l.value}`;
                
                if(l.type === LOCK_TYPE.GOLD) {
                    this.ctx.fillStyle = "#FFD700"; // Gold text color
                    text = `üí∞${l.value}`; 
                }

                // Adjust Y for text based on icon type
                // For lock, we want it in the screen area (center).
                // For money bag, we want it clearly visible over the bag.
                const textY = y + s/2;
                
                this.ctx.strokeText(text, x + s/2, textY);
                this.ctx.fillText(text, x + s/2, textY);
                
                this.ctx.shadowBlur = 0;
            } else {
                // Fallback if image not loaded
                this.ctx.fillStyle = "white"; this.ctx.font = "24px sans-serif"; this.ctx.textAlign = "center";
                const fallbackIcon = (l.type === LOCK_TYPE.GOLD) ? "üí∞" : "üîí";
                this.ctx.fillText(fallbackIcon, x+s/2, y+s/2 - 10);
                
                const text = (l.type === LOCK_TYPE.GOLD) ? `üí∞${l.value}` : `LV.${l.value}`;
                this.ctx.fillText(text, x+s/2, y+s/2 + 25);
            }
            
        } else if(i && i !== this.drag?.item) this.drawItem(x, y, s, i);
    }

    drawItem(x, y, size, item, isDrag=false) {
        x = Math.floor(x); y = Math.floor(y); size = Math.floor(size);
        const scale = isDrag ? 1.0 : item.scale;
        const pad = 4; const ds = Math.floor((size - pad * 2) * scale);
        const offset = Math.floor((size - ds) / 2);
        const dx = x + offset; const dy = y + offset;
        const cx = x + size/2; const cy = y + size/2;

        if(isDrag) { this.ctx.shadowColor = "black"; this.ctx.shadowBlur = 20; }

        const img = this.assets.getImage(item.type, item.level);
        if(img && img.complete && img.naturalWidth !== 0) {
            this.ctx.drawImage(img, dx, dy, ds, ds);
        } else {
            // Fallback render
            let c = "#cfd8dc"; let sym = "‚ùì";
            if(item.type===ITEM_TYPE.BUILDING_BARRACKS) { c="#795548"; sym="üè†"; }
            else if(item.type===ITEM_TYPE.BUILDING_RANGE) { c="#388e3c"; sym="üéØ"; }
            else if(item.type===ITEM_TYPE.BUILDING_STABLE) { c="#1976d2"; sym="üê¥"; }
            else if(item.type===ITEM_TYPE.BUILDING_CHEST) { c="#ffa000"; sym="üéÅ"; }
            else if(item.type===ITEM_TYPE.BUILDING_CAMP) { c="#5d4037"; sym="‚õ∫"; }
            else if(item.type===ITEM_TYPE.UNIT_INFANTRY) { c="#eeeeee"; sym="üõ°Ô∏è"; }
            else if(item.type===ITEM_TYPE.UNIT_ARCHER) { c="#c8e6c9"; sym="üèπ"; }
            else if(item.type===ITEM_TYPE.UNIT_CAVALRY) { c="#bbdefb"; sym="üêé"; }
            else if(item.type===ITEM_TYPE.ITEM_GOLD) { c="#fff176"; sym="üí∞"; }
            else if(item.type===ITEM_TYPE.ITEM_ENERGY) { c="#80deea"; sym="‚ö°"; }
            else if(item.type===ITEM_TYPE.ITEM_CRYSTAL) { c="#e1bee7"; sym="üíé"; }
            this.ctx.fillStyle = c; this.roundRect(dx, dy, ds, ds, 12); this.ctx.fill();
            this.ctx.strokeStyle = "rgba(0,0,0,0.4)"; this.ctx.lineWidth = 2; this.ctx.stroke();
            this.ctx.fillStyle = "rgba(0,0,0,0.6)"; this.ctx.font = `${Math.floor(ds*0.5)}px sans-serif`;
            this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle";
            this.ctx.fillText(sym, cx, cy);
        }
        this.drawLabel(item, cx, dy, ds);
        this.ctx.shadowBlur = 0;
    }

    drawLabel(item, cx, dy, ds) {
        let label = "";
        
        if ((item.type >= 10 && item.type < 20) || (item.type < 10 && item.type > 0)) { 
            // Level Badge Circle
            const badgeX = cx;
            const badgeY = dy + ds - 12; // Adjusted position (-10 -> -12)
            const badgeRadius = 11;

            this.ctx.fillStyle = "rgba(0,0,0,0.85)"; // Darker background
            this.ctx.beginPath(); 
            this.ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI*2); 
            this.ctx.fill();
            
            // Border for visibility
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 1;
            this.ctx.stroke();

            this.ctx.fillStyle = "white"; 
            this.ctx.font = "bold 14px sans-serif"; 
            this.ctx.textAlign = "center"; 
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(item.level, badgeX, badgeY + 1); // +1 Y Î≥¥Ï†ï
        }
        if (item.type === ITEM_TYPE.BUILDING_CAMP && item.storedUnit) {
            this.ctx.fillStyle = "#ff5252"; this.ctx.font="bold 20px sans-serif"; this.ctx.fillText("IN", cx, Math.floor(dy + ds/2));
        }
    }

    roundRect(x,y,w,h,r){this.ctx.beginPath();this.ctx.moveTo(x+r,y);this.ctx.arcTo(x+w,y,x+w,y+h,r);this.ctx.arcTo(x+w,y+h,x,y+h,r);this.ctx.arcTo(x,y+h,x,y,r);this.ctx.arcTo(x,y,x+w,y,r);this.ctx.closePath();}
    
    showToast(msg, x, y, color='#ffd700') { 
        if (x && y) {
            const rect = this.canvas.getBoundingClientRect();
            const scale = rect.width / this.width;
            const screenX = x * scale;
            const screenY = y * scale;
            const el = document.createElement('div');
            el.className = 'float-text';
            el.style.left = `${screenX}px`; el.style.top = `${screenY}px`;
            el.innerText = msg;
            el.style.color = color; // Apply dynamic color
            document.getElementById('canvas-wrapper').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        } else {
            const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1000); 
        }
    }

    showFloatingImage(key, x, y) {
        const imgObj = this.assets.getImage(key);
        if (!imgObj) return;

        const rect = this.canvas.getBoundingClientRect();
        const scale = rect.width / this.width;
        const screenX = x * scale;
        const screenY = y * scale;

        const el = document.createElement('img');
        el.className = 'float-img';
        el.src = imgObj.src;
        el.style.left = `${screenX - 30}px`; // Center align adjustment
        el.style.top = `${screenY}px`;
        document.getElementById('canvas-wrapper').appendChild(el);
        setTimeout(() => el.remove(), 1200);
    }

    updateUI(){ 
        document.getElementById('energy-display').innerText = `${this.energy}/${this.maxEnergy}`;
        document.getElementById('gold-display').innerText = this.gold;
        document.getElementById('gem-display').innerText = this.gem;
        document.getElementById('level-display').innerText = `LORD LV.${this.lordLevel}`;
        document.getElementById('xp-text').innerText = `${this.currentXp} / ${this.requiredXp}`;
        document.getElementById('xp-bar').style.width = `${Math.min(100, (this.currentXp/this.requiredXp)*100)}%`;
    }
    cheatEnergy(){ this.energy = Math.min(this.energy+30, this.maxEnergy); this.updateUI(); }
    spawnChest(){ for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(this.gridState[r][c].type===LOCK_TYPE.OPEN&&!this.grid[r][c]){ this.grid[r][c]={type:ITEM_TYPE.BUILDING_CHEST,level:1,scale:0}; this.requestRender(); return; } }
    
    produce(building) {
        const stats = BUILDING_STATS[building.level] || BUILDING_STATS[1];
        if(this.energy < stats.energy) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${stats.energy} ÌïÑÏöî)`); return; }
        let unitType = ITEM_TYPE.UNIT_INFANTRY;
        if(building.type === ITEM_TYPE.BUILDING_RANGE) unitType = ITEM_TYPE.UNIT_ARCHER;
        if(building.type === ITEM_TYPE.BUILDING_STABLE) unitType = ITEM_TYPE.UNIT_CAVALRY;
        let spawnLevel = 1;
        const rand = Math.random() * 100;
        let cum = 0;
        for(let i=0; i<stats.probs.length; i++) {
            cum += stats.probs[i];
            if(rand < cum) { spawnLevel = i + 1; break; }
        }
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if(this.gridState[r][c].type === LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.energy -= stats.energy;
                this.grid[r][c] = { type: unitType, level: spawnLevel, scale: 0 };
                this.updateUI(); this.requestRender(); return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }

    produceFromChest(chest, r, c) {
        const cost = 1; 
        if(this.energy < cost) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${cost} ÌïÑÏöî)`); return; }
        const table = CHEST_DROP_TABLE[chest.level] || CHEST_DROP_TABLE[1];
        let totalWeight = 0;
        table.forEach(entry => totalWeight += entry.prob);
        let rand = Math.random() * totalWeight;
        let selectedCode = table[0].code;
        for(let entry of table) {
            if(rand < entry.prob) { selectedCode = entry.code; break; }
            rand -= entry.prob;
        }
        const info = getInfoFromCode(selectedCode);
        for(let tr=0; tr<CONFIG.gridRows; tr++) for(let tc=0; tc<CONFIG.gridCols; tc++) {
            if(this.gridState[tr][tc].type === LOCK_TYPE.OPEN && !this.grid[tr][tc]) {
                this.energy -= cost;
                this.grid[tr][tc] = { type: info.type, level: info.level, scale: 0 };
                chest.scale = 1.3; 
                this.updateUI(); this.requestRender(); return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }

    collectResource(item, r, c) {
        const val = ITEM_VALUES[item.level] || 1;
        let msg = "";
        let color = "#fff"; // Default white
        const cellX = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2;
        const cellY = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;

        if(item.type === ITEM_TYPE.ITEM_GOLD) { 
            this.gold += val; msg = `+${val} Gold`; color = "#ffd700"; // Yellow
        }
        if(item.type === ITEM_TYPE.ITEM_ENERGY) { 
            this.energy = Math.min(this.energy + val, this.maxEnergy); msg = `+${val} Energy`; color = "#00bfff"; // Deep Sky Blue
        }
        if(item.type === ITEM_TYPE.ITEM_CRYSTAL) { 
            this.gem += val; msg = `+${val} Gem`; color = "#ff69b4"; // Hot Pink
        }
        
        this.showToast(msg, cellX, cellY, color);
        this.grid[r][c] = null; 
        this.updateUI(); this.requestRender();
    }
    
    ejectCamp(item, r, c) {
        if(!item.storedUnit) { this.showToast("ÎπÑÏñ¥ÏûàÏùå"); return; }
        const n = [[0,1],[0,-1],[1,0],[-1,0]];
        for(let o of n) {
            const nr=r+o[0], nc=c+o[1];
            if(nr>=0 && nr<8 && nc>=0 && nc<8 && !this.grid[nr][nc] && this.gridState[nr][nc].type===LOCK_TYPE.OPEN) {
                this.grid[nr][nc] = item.storedUnit; item.storedUnit = null; 
                this.requestRender(); return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }
    tryUnlock(r, c) {
        const lock = this.gridState[r][c];
        if(lock.type === LOCK_TYPE.GOLD) {
            if(this.gold >= lock.value) { this.gold -= lock.value; this.gridState[r][c] = { type: LOCK_TYPE.OPEN }; this.showToast("Ìï¥Í∏à ÏôÑÎ£å!"); }
            else this.showToast("Í≥®Îìú Î∂ÄÏ°±");
        } else if(lock.type === LOCK_TYPE.LEVEL) {
            if(this.lordLevel >= lock.value) { this.gridState[r][c] = { type: LOCK_TYPE.OPEN }; this.showToast("Ìï¥Í∏à ÏôÑÎ£å!"); }
            else this.showToast(`LV.${lock.value} ÌïÑÏöî`);
        }
        this.updateUI(); this.requestRender();
    }
}

const game = new Game();
</script>
</body>
</html>