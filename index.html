<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KOV - Field Objects Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ... (Í∏∞Ï°¥ Ïä§ÌÉÄÏùº Ïú†ÏßÄ) ... */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background-color: #000; touch-action: none; font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; width: 100vw; height: 100dvh; }
        #game-container { position: relative; background-color: #4e342e; box-shadow: 0 0 50px rgba(0,0,0,0.5); width: 100%; height: 100%; max-width: 56.25vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Header */
        .header-panel { flex: 0 0 auto; background: linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.0)); color: white; padding: 8px 12px; padding-top: max(8px, env(safe-area-inset-top)); z-index: 20; }
        .res-pill { background: rgba(0,0,0,0.6); border: 1px solid #555; border-radius: 99px; padding: 4px 10px; display: flex; align-items: center; gap: 6px; font-weight: bold; font-size: 12px; color: #fff; cursor: pointer; transition: transform 0.1s; }
        .res-pill:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }
        .res-icon { width: 18px; height: 18px; object-fit: contain; display: inline-flex; align-items: center; justify-content: center; }

        /* Canvas */
        #canvas-wrapper { flex: 1; position: relative; overflow: hidden; background-color: #3e2723; width: 100%; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* Footer */
        .footer-panel { flex: 0 0 auto; background: #d7ccc8; border-top: 4px solid #8d6e63; padding: 8px 12px; padding-bottom: max(10px, env(safe-area-inset-bottom)); display: flex; align-items: center; justify-content: space-between; min-height: 90px; z-index: 20; }
        .info-box { flex: 1; background: #f5f5f5; border: 1px solid #8d6e63; border-radius: 6px; padding: 4px 8px; height: 60px; display: flex; flex-direction: column; justify-content: center; color: #3e2723; margin: 0 6px; overflow: hidden; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; font-size: 10px; font-weight: bold; color: #444; margin-top: 2px; }
        
        /* Action Buttons */
        .action-btn { 
            width: 56px; 
            height: 56px; 
            background: linear-gradient(to bottom, #ffca28, #ff6f00); 
            border: 1px solid #e65100; 
            border-radius: 10px; 
            color: white; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            box-shadow: 0 3px 0 #bf360c, 0 5px 5px rgba(0,0,0,0.3); 
            transition: all 0.1s;
            position: relative;
            padding-bottom: 2px;
        }
        .action-btn:active { transform: translateY(3px); box-shadow: 0 0 0 #bf360c, 0 0 0 rgba(0,0,0,0); border-bottom-width: 0; }
        .world-btn { background: linear-gradient(to bottom, #42a5f5, #1565c0); border-color: #0d47a1; box-shadow: 0 3px 0 #0d47a1, 0 5px 5px rgba(0,0,0,0.3); }
        .world-btn:active { box-shadow: 0 0 0 #0d47a1; }
        .build-btn { background: linear-gradient(to bottom, #8d6e63, #5d4037); border-color: #3e2723; box-shadow: 0 3px 0 #3e2723, 0 5px 5px rgba(0,0,0,0.3); }
        .build-btn:active { box-shadow: 0 0 0 #3e2723; }
        
        .btn-icon { font-size: 22px; line-height: 1; margin-bottom: 2px; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2)); }
        .btn-label { font-size: 11px; font-weight: bold; line-height: 1; text-shadow: 0 1px 1px rgba(0,0,0,0.4); letter-spacing: -0.5px; }

        /* Modals & Popups */
        .modal-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.8); z-index: 100; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.2s; backdrop-filter: blur(2px); }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-content { background: #3e2723; border: 2px solid #8d6e63; border-radius: 12px; padding: 20px; width: 85%; max-width: 320px; text-align: center; color: white; transform: scale(0.9); transition: transform 0.2s; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .modal-overlay.open .modal-content { transform: scale(1); }
        .modal-content.wide { max-width: 360px; }
        
        #field-modal { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; background: #222; z-index: 90; transform: translateY(100%); transition: transform 0.3s ease-out; display: flex; flex-direction: column; color: white; }
        #field-modal.open { transform: translateY(0); }
        
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; overflow-y: auto; padding: 10px; }
        .shop-item { background: #4e342e; border: 2px solid #8d6e63; border-radius: 10px; padding: 10px; display: flex; flex-direction: column; align-items: center; position: relative; }
        .toggle-switch { width: 40px; height: 20px; background: #555; border-radius: 20px; position: relative; transition: 0.3s; }
        .toggle-switch.on { background: #4caf50; }
        .toggle-knob { width: 16px; height: 16px; background: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: 0.3s; }
        .toggle-switch.on .toggle-knob { left: 22px; }

        /* Field Styles */
        .field-cell { width: 12px; height: 12px; transition: all 0.2s; border-radius: 1px; position: relative; z-index: 10; }
        .field-occupied { border: 1px solid #42a5f5; box-shadow: 0 0 2px #42a5f5; z-index: 10; opacity: 1.0 !important; }
        .field-target { outline: 1px solid #ffd700; box-shadow: 0 0 4px #ffd700; z-index: 15; }
        .field-selected { outline: 2px solid #22d3ee; box-shadow: 0 0 6px rgba(34,211,238,0.9); z-index: 16; }
        .field-path { outline: 1px solid rgba(255,255,255,0.5); background: rgba(255,255,255,0.08); z-index: 12; }
        #path-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 15; }
        .path-line-bg { stroke: rgba(0,0,0,0.6); stroke-width: 4; fill: none; stroke-linecap: round; stroke-linejoin: round; }
        .path-line { stroke: #ffd700; stroke-width: 2; fill: none; stroke-linecap: round; stroke-linejoin: round; }
        .field-time { position: absolute; left: 0; right: 0; bottom: 0; height: 6px; display: flex; align-items: center; justify-content: center; font-size: 4px; font-weight: 700; color: #ffe08a; text-shadow: 0 1px 0 rgba(0,0,0,0.75); pointer-events: none; letter-spacing: -0.4px; z-index: 25; line-height: 1; opacity: 0.5; transform: translateY(var(--label-offset, 0px)) scale(var(--label-scale, 1)); transform-origin: center bottom; }
        .field-time.lower { --label-offset: 1px; }
        .field-cell::after { z-index: 12; }
        .field-move-eligible { outline: 1px dashed rgba(255,255,255,0.35); }
        .field-move-source { outline: 1px solid #4ade80; box-shadow: 0 0 4px rgba(74,222,128,0.9); }

        /* Fog of War */
        .field-fog { background-color: #000 !important; border: none; cursor: default; z-index: 100; opacity: 1 !important; }
        .field-fog::after { content: ''; }
        
        /* Object Icons */
        .field-gate { border: 1px solid #ef4444; }
        .field-gate.locked::after { content: 'üîí'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-gate.unlocked::after { content: 'üëê'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-castle::after { content: 'üè∞'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-fortress::after { content: 'üèØ'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-citadel::after { content: 'üèØ'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-dragon::after { content: 'üêâ'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-shop::after { content: 'üè™'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-tavern::after { content: 'üç∫'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-ruins::after { content: 'üè∫'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-statue::after { content: 'üóø'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        
        /* New Objects: Gold Mine & Fountain */
        .field-goldmine::after { content: '‚õèÔ∏è'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .field-fountain::after { content: '‚õ≤'; font-size: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .field-move-info { background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 4px 8px; font-size: 11px; color: #f8fafc; display: flex; justify-content: space-between; gap: 6px; box-shadow: 0 4px 10px rgba(0,0,0,0.35); }
        .field-overlay { position: absolute; top: 0; left: 0; right: 0; z-index: 60; display: flex; flex-direction: column; gap: 4px; padding: 6px 8px 0; pointer-events: none; }
        .field-overlay > * { pointer-events: auto; }
        .field-floating-wrap { position: relative; z-index: 70; display: none; flex-direction: column; gap: 6px; width: min(240px, 78vw); pointer-events: auto; align-self: flex-start; }
        .field-info-panel { background: rgba(20,20,20,0.94); border: 1px solid rgba(255,255,255,0.18); border-radius: 8px; padding: 8px 10px; margin-bottom: 0; font-size: 12px; color: #fff; transform: translateY(6px) scale(0.98); opacity: 0; max-height: 0; overflow: hidden; transition: transform 0.2s ease, opacity 0.2s ease, max-height 0.2s ease; box-shadow: 0 8px 18px rgba(0,0,0,0.4); }
        .field-info-panel.open { transform: translateY(0) scale(1); opacity: 1; max-height: 240px; }
        .field-info-title { font-weight: bold; color: #ffd700; font-size: 13px; margin-bottom: 4px; }
        .field-info-row { display: flex; justify-content: space-between; gap: 8px; }
        .field-info-small { font-size: 11px; color: #ccc; margin-top: 4px; }
        .field-move-options { margin-top: 6px; display: flex; flex-direction: column; gap: 4px; }
        .field-eta-btn { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.18); color: #e5e7eb; padding: 3px 6px; border-radius: 6px; font-size: 11px; text-align: left; }
        .field-eta-btn.active { border-color: #fbbf24; color: #fbbf24; box-shadow: 0 0 0 1px rgba(251,191,36,0.4); }
        .field-eta-btn.disabled { opacity: 0.5; }
        .field-action-btn.disabled { opacity: 0.5; }
        .field-info-bar { height: 6px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden; margin-top: 2px; }
        .field-info-bar-fill { height: 100%; background: #fbbf24; }
        .shop-list { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 8px; }
        .shop-card { background: #2b2b2b; border: 1px solid #4b4b4b; border-radius: 10px; padding: 8px; text-align: left; font-size: 11px; display: flex; flex-direction: column; gap: 6px; }
        .shop-card .name { font-weight: bold; color: #f8fafc; }
        .shop-card .meta { color: #cbd5f5; font-size: 10px; }
        .shop-card .price-btn { align-self: stretch; background: #f59e0b; color: #111827; border-radius: 8px; padding: 6px 0; font-weight: bold; font-size: 11px; }
        .shop-card .price-btn:active { transform: scale(0.98); }
        .shop-card.disabled { opacity: 0.45; }
        .shop-card.disabled .price-btn { background: #374151; color: #9ca3af; }
        .shop-icon { width: 26px; height: 26px; border-radius: 6px; background: rgba(255,255,255,0.08); display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .shop-icon-img { width: 100%; height: 100%; object-fit: contain; }
        .shop-row { display: flex; align-items: center; gap: 6px; }
        .shop-card.restock { animation: restockPulse 0.8s ease-out; box-shadow: 0 0 0 2px rgba(34,197,94,0.6); }
        @keyframes restockPulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34,197,94,0.0); }
            50% { transform: scale(1.03); box-shadow: 0 0 0 3px rgba(34,197,94,0.5); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34,197,94,0.0); }
        }
        .field-action-menu { position: absolute; background: rgba(15,15,15,0.95); border: 1px solid #666; border-radius: 8px; padding: 6px; display: flex; flex-direction: column; gap: 6px; z-index: 120; min-width: 90px; box-shadow: 0 6px 14px rgba(0,0,0,0.5); }
        .field-action-btn { background: #2f2f2f; border: 1px solid #555; color: #fff; padding: 6px 8px; border-radius: 6px; font-size: 12px; font-weight: bold; }

        @media (max-width: 820px) {
            .field-time { font-size: 3px; letter-spacing: -0.3px; }
        }
        @media (max-width: 480px) {
            .field-time { font-size: 2.6px; letter-spacing: -0.25px; }
        }
        .field-action-btn:active { transform: scale(0.97); }
        
        #income-float { position:absolute; color:#ffd700; font-weight:bold; font-size:12px; pointer-events:none; animation: floatUp 1s forwards; z-index: 200; text-shadow: 1px 1px 0 #000; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity:1; } 100% { transform: translateY(-20px); opacity:0; } }
        .join-float { position: absolute; left: 50%; bottom: 18%; transform: translateX(-50%); color: #4ade80; font-weight: bold; font-size: 12px; pointer-events: none; animation: floatUp 1s forwards; z-index: 220; text-shadow: 1px 1px 0 #000; }
        
        #toast { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; opacity: 0; transition: opacity 0.3s; z-index: 200; border: 2px solid #ffd700; white-space: nowrap; pointer-events: none; }
        
        /* Army Marker */
        .army-marker { position: absolute; width: 12px; height: 12px; box-shadow: 0 0 4px rgba(0,0,0,0.5); transition: transform 0.1s linear; z-index: 50; pointer-events: none; display: flex; justify-content: center; align-items: center; font-size: 8px; font-weight: bold; color: black; overflow: visible; background-size: contain; background-repeat: no-repeat; background-position: center; }
        .army-marker.selected { box-shadow: 0 0 15px 2px #ffd700; transform: scale(1.3); z-index: 51; }
        
        .squad-selector { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.95); border: 2px solid #8d6e63; border-radius: 12px; padding: 10px; display: flex; gap: 10px; z-index: 100; width: 90%; max-width: 300px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .squad-card { flex: 1; background: #3e2723; border: 1px solid #555; border-radius: 8px; padding: 8px; text-align: center; cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden; }
        .squad-card:active { transform: scale(0.95); }
        .squad-card.disabled { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        .squad-status { font-size: 10px; color: #aaa; margin-top: 2px; }
        
        .selected-army-hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.9); border: 1px solid #ffd700; border-radius: 30px; padding: 8px 20px; z-index: 95; display: flex; gap: 15px; align-items: center; color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.6); }
        .hud-name { font-weight: bold; color: #ffd700; font-size: 14px; }
        .hud-btn { background: #d32f2f; border: none; border-radius: 12px; padding: 4px 12px; font-size: 10px; font-weight: bold; cursor: pointer; color: white; }
        
        #levelup-banner { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) scale(0); z-index: 150; pointer-events: none; transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #levelup-banner.show { transform: translate(-50%, -50%) scale(1); }
        .levelup-stat { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .levelup-old { color: #aaa; }
        .levelup-arrow { color: #fbbf24; margin: 0 10px; }
        .levelup-new { color: #4ade80; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="levelup-banner"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/levelup.png" onerror="this.style.display='none'"></div>

    <!-- Header -->
    <div class="header-panel">
        <div class="flex justify-between mb-1">
            <div class="res-pill" onclick="game.openRefill('energy')">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/energy.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='‚ö°'+this.nextElementSibling.innerText">
                <span id="energy-display">50/50</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
            <div class="res-pill" onclick="game.openRefill('cp')">
                <span class="res-icon">üß≠</span>
                <span id="cp-display">20/20</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
            <div class="res-pill" onclick="game.openRefill('gold')">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/gold.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üí∞'+this.nextElementSibling.innerText">
                <span id="gold-display">3000</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
            <div class="res-pill" onclick="game.openRefill('crystal')">
                <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/crystal.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üíé'+this.nextElementSibling.innerText">
                <span id="gem-display">50</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            </div>
        </div>
        <div class="flex flex-col w-full">
            <div class="flex justify-between items-end px-1">
                <span class="font-bold text-yellow-400 text-xs" id="level-display">LORD LV.1</span>
                <span class="font-bold text-gray-300 text-xs flex items-center gap-1"><span id="xp-text">0 / 10</span> XP</span>
            </div>
            <div class="w-full bg-gray-800 h-2 mt-1 rounded-full overflow-hidden border border-gray-600 relative">
                <div id="xp-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
            </div>
        </div>
        <!-- Dev Tools -->
        <div class="flex gap-2 mt-1 opacity-30 hover:opacity-100 transition-opacity justify-end items-center">
            <button onclick="game.resetGame()" class="bg-red-800 text-white px-2 py-1 rounded text-[10px] border border-red-500 hover:bg-red-600">üîÑÎ¶¨ÏÖã</button>
            <button onclick="game.cheatEnergy()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚ö°+30</button>
            <button onclick="game.spawnChest()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">üéÅÏÉÅÏûê</button>
            <button onclick="game.cheatLevelUp()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚¨ÜÔ∏èLvUP</button>
        </div>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Footer -->
    <div class="footer-panel">
        <button class="action-btn chat-btn bg-gray-700 border-gray-600" onclick="game.openSettings()">
            <span class="text-2xl filter drop-shadow">‚öôÔ∏è</span>
        </button>
        
        <div class="info-box" id="info-panel">
            <div class="flex justify-between items-center"><span class="font-bold text-sm truncate" id="info-name">ÏÑ†ÌÉù ÏóÜÏùå</span><span class="text-[10px] text-gray-500 font-bold" id="info-class"></span></div>
            <div class="stat-grid hidden" id="unit-stats-grid">
                <div class="stat-item">‚ù§<span id="st-hp">0</span></div>
                <div class="stat-item">‚öî<span id="st-atk">0</span></div>
                <div class="stat-item">üõ°Ô∏è<span id="st-def">0</span></div>
                <div class="stat-item">ü¶∂<span id="st-spd">0</span></div>
                <div class="stat-item">üéØ<span id="st-rng">0</span></div>
                <div class="stat-item">üèÉ<span id="st-mov">0</span></div>
            </div>
            <div class="text-[10px] text-gray-600 truncate mt-1" id="info-desc">Ïò§Î∏åÏ†ùÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>
        </div>
        
        <button class="action-btn" id="btn-action" onclick="game.handleAction()">
            <span class="btn-icon" id="action-icon">üí∞</span>
            <span class="btn-label" id="action-label">Sell</span>
        </button>
        <button class="action-btn build-btn" style="margin-left:5px;" onclick="game.toggleShop()">
            <span class="btn-icon">üè†</span>
            <span class="btn-label">Í±¥ÏÑ§</span>
        </button>
        <button class="action-btn world-btn" style="margin-left:5px;" onclick="game.toggleField()">
            <span class="btn-icon">üåç</span>
            <span class="btn-label">ÌïÑÎìú</span>
        </button>
    </div>

    <!-- Modals -->
    <div id="field-modal">
        <div class="flex justify-between items-center p-4 border-b border-gray-600 bg-gray-900">
            <h2 class="text-xl font-bold text-yellow-400" id="modal-title">Î©îÎâ¥</h2>
            <button onclick="game.closeModal()" class="w-8 h-8 text-gray-400 font-bold">‚úñ</button>
        </div>
        <div class="flex-1 overflow-auto bg-gray-800 p-2 relative" id="modal-content"></div>
    </div>
    
    <div id="modal-levelup" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-yellow-400 mb-4">LEVEL UP!</h2>
            <div class="text-6xl mb-4">üÜô</div>
            <div class="bg-gray-800 rounded p-4 mb-4 text-left text-sm">
                <div class="levelup-stat">
                    <span>Î†àÎ≤® (Lord Level)</span>
                    <span><span id="lv-old" class="levelup-old">1</span> <span class="levelup-arrow">‚ñ∂</span> <span id="lv-new" class="levelup-new">2</span></span>
                </div>
                <div class="levelup-stat" style="border:none">
                    <span>ÏµúÎåÄ ÏóêÎÑàÏßÄ</span>
                    <span><span id="en-old" class="levelup-old">50</span> <span class="levelup-arrow">‚ñ∂</span> <span id="en-new" class="levelup-new">52</span></span>
                </div>
            </div>
            <button onclick="document.getElementById('modal-levelup').classList.remove('open')" class="w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-lg font-bold">ÌôïÏù∏</button>
        </div>
    </div>

    <div id="modal-refill" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold text-white" id="refill-title">Î¶¨ÏÜåÏä§ Ï∂©Ï†Ñ</h2>
                <button onclick="document.getElementById('modal-refill').classList.remove('open')" class="text-gray-400">‚úñ</button>
            </div>
            <div id="refill-options" class="grid gap-3"></div>
        </div>
    </div>

    <div id="modal-settings" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold text-gray-200 mb-6">ÏÑ§Ï†ï (Settings)</h2>
            <div class="space-y-4 text-left">
                <div class="flex justify-between items-center bg-gray-800 p-3 rounded">
                    <span>Î∞∞Í≤ΩÏùåÏïÖ (BGM)</span>
                    <div class="toggle-switch on" onclick="game.toggleSetting('bgm', this)"><div class="toggle-knob"></div></div>
                </div>
                <div class="flex justify-between items-center bg-gray-800 p-3 rounded">
                    <span>Ìö®Í≥ºÏùå (SFX)</span>
                    <div class="toggle-switch on" onclick="game.toggleSetting('sfx', this)"><div class="toggle-knob"></div></div>
                </div>
                <div class="bg-gray-800 p-3 rounded text-xs text-gray-400">
                    <p>UID: <span id="settings-uid" class="text-gray-200">User_1234</span></p>
                    <p>Version: 0.3.3 (Hotfix: Data & Field Objects)</p>
                </div>
            </div>
            <div class="mt-6 flex gap-2">
                <button onclick="game.resetGame()" class="flex-1 bg-red-800 py-2 rounded text-xs text-red-200 border border-red-600 hover:bg-red-700">Í≥ÑÏ†ï Ï¥àÍ∏∞Ìôî</button>
                <button onclick="document.getElementById('modal-settings').classList.remove('open')" class="flex-1 bg-gray-600 py-2 rounded text-xs border border-gray-500 hover:bg-gray-500">Îã´Í∏∞</button>
            </div>
        </div>
    </div>

    <div id="modal-object" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold text-white" id="object-modal-title">Ïò§Î∏åÏ†ùÌä∏</h2>
            <button onclick="document.getElementById('modal-object').classList.remove('open'); document.querySelector('#modal-object .modal-content')?.classList.remove('wide')" class="text-gray-400">‚úñ</button>
            </div>
            <div id="object-modal-body" class="text-left text-sm text-gray-200 space-y-2"></div>
            <button onclick="document.getElementById('modal-object').classList.remove('open'); document.querySelector('#modal-object .modal-content')?.classList.remove('wide')" class="w-full bg-gray-700 hover:bg-gray-600 py-2 rounded text-xs border border-gray-600 mt-4">Îã´Í∏∞</button>
        </div>
    </div>

    <div id="toast">Î©îÏãúÏßÄ</div>
</div>

<script>
// --- CONFIGURATION ---
const GITHUB_REPO = "nod-sean/bmo";
const GITHUB_BRANCH = "main";
const ASSET_KEYS = [
    '1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110',
    '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210',
    '1301', '1302', '1303', '1304', '1305', '1306', '1307', '1308', '1309', '1310',
    '2101', '2102', '2103', '2104', '2105', '2201', '2204', '2205',
    '2301', '2302', '2303', '2304', '2801', '2802', '2803', '2804', '2805',
    '3101', '3102', '3103', '3104', '3105',
    '1801', '1802', '1803', '1804', '1805', '1811', '1812', '1813', '1814', '1815',
    '1821', '1822', '1823', '1824', '1825', 'lock', 'gold', 'energy', 'crystal', 'xp', 'levelup', 'field_bg'
];

const CONFIG = { gridCols: 8, gridRows: 8, gridTopY: 520, gridPadding: 20, squadCols: 3, squadRows: 3, squadTopY: 55, squadGap: 80, squadCellSize: 130, squadGap3: 24, squadCellSize3: 110 };
const ITEM_TYPE = { EMPTY: 0, BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3, BUILDING_CHEST: 4, BUILDING_CAMP: 5, UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12, ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22 };
const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2', SQUAD3: 'squad3' };
const BUILDING_LIMITS = { [ITEM_TYPE.BUILDING_BARRACKS]: 3, [ITEM_TYPE.BUILDING_RANGE]: 2, [ITEM_TYPE.BUILDING_STABLE]: 2, [ITEM_TYPE.BUILDING_CAMP]: 2, [ITEM_TYPE.BUILDING_CHEST]: 99 };
const SHOP_DATA = [ { type: ITEM_TYPE.BUILDING_BARRACKS, name: "Î≥ëÏòÅ", price: 100, icon: "üè†" }, { type: ITEM_TYPE.BUILDING_RANGE, name: "ÏÇ¨Í≤©Ïû•", price: 200, icon: "üéØ" }, { type: ITEM_TYPE.BUILDING_STABLE, name: "ÎßàÍµ¨Í∞Ñ", price: 500, icon: "üê¥" }, { type: ITEM_TYPE.BUILDING_CAMP, name: "Ï∫†ÌîÑ", price: 300, icon: "‚õ∫" }, { type: ITEM_TYPE.BUILDING_CHEST, name: "Î≥¥Î¨ºÏÉÅÏûê", price: 500, icon: "üéÅ" } ];
const CAMP_CAPACITY = {1:4, 2:6, 3:8, 4:12, 5:16};
const MOVE_MS_PER_MIN = 120; // Îç∞Î™®Ïö© Ïä§ÏºÄÏùº: 1Î∂Ñ = 120ms
const CP_COST_PER_TILE = 1;
const TERRAIN_COLORS = { 100: "#4a6e3a", 200: "#2e5a2a", 300: "#8b6f3d", 400: "#7a7a7a", 500: "#7a1f1f" };
const TERRAIN_COLORS_BORDER = { 100: "#5b7b47", 200: "#3b6a36", 300: "#9b7e4a", 400: "#8a8a8a", 500: "#8a2b2b" };

function isTerrainCode(code) { return code >= 100 && code < 600; }
function getTerrainBase(code) { return Math.floor(code / 100) * 100; }
function getTerrainName(code) {
    const base = getTerrainBase(code);
    const name = base === 100 ? "ÌèâÏõê" : base === 200 ? "Ïà≤" : base === 300 ? "Í≥†Ïõê" : base === 400 ? "ÏÇ∞ÏïÖ" : base === 500 ? "ÌôîÏÇ∞" : "ÏßÄÌòï";
    return (code % 100 === 1) ? `${name} Í≤ΩÍ≥Ñ` : name;
}
function getTerrainBaseName(code) {
    const base = getTerrainBase(code);
    return base === 100 ? "ÌèâÏõê" : base === 200 ? "Ïà≤" : base === 300 ? "Í≥†Ïõê" : base === 400 ? "ÏÇ∞ÏïÖ" : base === 500 ? "ÌôîÏÇ∞" : "ÏßÄÌòï";
}

function isCastleTile(code) { return code === 1 || code === 5101; }
function isGateTile(code) { return code === 2 || (code >= 5111 && code <= 5114); }
function isCitadelTile(code) { return code === 3 || (code >= 5121 && code <= 5123); }
function isDragonTile(code) { return code === 5131; }
function isGoldMineTile(code) { return code === 5 || (code >= 5201 && code <= 5202); }
function isFountainTile(code) { return code === 6 || (code >= 5211 && code <= 5212); }
function isShopTile(code) { return code === 5221; }
function isTavernTile(code) { return code === 5231; }
function isRuinsTile(code) { return code === 5241 || code === 5242; }
function isStatueTile(code) { return code >= 5301 && code <= 5332; }
function isBorderTerrain(code) { return isTerrainCode(code) && code % 100 === 1; }
function isBlockingField(code) { return isGateTile(code) || isCitadelTile(code) || isDragonTile(code) || isBorderTerrain(code); }
function getStatueKind(code) {
    if (code >= 5301 && code <= 5302) return "atk";
    if (code >= 5311 && code <= 5312) return "def";
    if (code >= 5321 && code <= 5322) return "hp";
    if (code >= 5331 && code <= 5332) return "spd";
    return null;
}
function getObjectLevelFromCode(type) {
    if (isGateTile(type)) return Math.max(1, type - 5110);
    if (isCitadelTile(type)) return Math.max(1, type - 5120);
    if (isGoldMineTile(type)) return Math.max(1, type - 5200);
    if (isFountainTile(type)) return Math.max(1, type - 5210);
    if (isRuinsTile(type)) return Math.max(1, type - 5240);
    if (isStatueTile(type)) return type % 10;
    return 1;
}

const FIELD_DEFENDERS = {
    1: [ { code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 } ],
    2: [ { code: 1105, count: 3 }, { code: 1205, count: 3 }, { code: 1305, count: 3 } ],
    3: [ { code: 1106, count: 3 }, { code: 1206, count: 3 }, { code: 1306, count: 3 } ],
    4: [ { code: 1107, count: 3 }, { code: 1207, count: 3 }, { code: 1307, count: 3 } ]
};

// --- LEVEL COLORS ---
const LEVEL_COLORS = {
    1: "#FFFFFF", 2: "#BDBDBD", 3: "#6D4C41", 4: "#2E7D32", 5: "#00897B",
    6: "#1E88E5", 7: "#6A1B9A", 8: "#F57C00", 9: "#C62828", 10: "#212121"
};

// --- GAME DATA ---
const LEVEL_DATA = [
    { level: 1, xp: 0, maxEnergy: 50 }, { level: 2, xp: 10, maxEnergy: 52 }, { level: 3, xp: 25, maxEnergy: 54 },
    { level: 4, xp: 43, maxEnergy: 56 }, { level: 5, xp: 65, maxEnergy: 58 }, { level: 6, xp: 91, maxEnergy: 60 },
    { level: 7, xp: 122, maxEnergy: 62 }, { level: 8, xp: 157, maxEnergy: 64 }, { level: 9, xp: 197, maxEnergy: 66 },
    { level: 10, xp: 242, maxEnergy: 68 }, { level: 11, xp: 292, maxEnergy: 70 }, { level: 12, xp: 347, maxEnergy: 72 },
    { level: 13, xp: 408, maxEnergy: 74 }, { level: 14, xp: 474, maxEnergy: 76 }, { level: 15, xp: 546, maxEnergy: 78 }
];

const REFILL_DATA = {
    energy: [
        { cost: 10, amount: 30, currency: 'crystal', name: "‚ö° 30 Ï∂©Ï†Ñ" },
        { cost: 30, amount: 100, currency: 'crystal', name: "‚ö° 100 Ï∂©Ï†Ñ" }
    ],
    cp: [
        { cost: 2, amount: 5, currency: 'crystal', name: "üß≠ 5 Ï∂©Ï†Ñ" },
        { cost: 11, amount: 30, currency: 'crystal', name: "üß≠ 30 Ï∂©Ï†Ñ" }
    ],
    gold: [
        { cost: 10, amount: 1000, currency: 'crystal', name: "üí∞ 1,000 Ï∂©Ï†Ñ" },
        { cost: 50, amount: 6000, currency: 'crystal', name: "üí∞ 6,000 Ï∂©Ï†Ñ" }
    ],
    crystal: [
        { cost: 0.99, amount: 100, currency: 'usd', name: "üíé 100 (ÏÜåÎß§)" },
        { cost: 4.99, amount: 550, currency: 'usd', name: "üíé 550 (Ìè¨ÎåÄ)" }
    ]
};

const ABILITY_CODES = {
    GOLD_CAP: 1,
    GOLD_REGEN: 2,
    ENERGY_CAP: 3,
    ENERGY_REGEN: 4,
    CP_CAP: 5,
    CP_REGEN: 6
};

const FIELD_OBJECT_DATA = {
  5101: { name: "ÏÑ±", level: 1, defenders: [], abilities: [] },
  5111: { name: "Í¥ÄÎ¨∏", level: 1, defenders: [{ code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 }], abilities: [] },
  5112: { name: "Í¥ÄÎ¨∏", level: 2, defenders: [{ code: 1105, count: 3 }, { code: 1205, count: 3 }, { code: 1305, count: 3 }], abilities: [] },
  5113: { name: "Í¥ÄÎ¨∏", level: 3, defenders: [{ code: 1106, count: 3 }, { code: 1206, count: 3 }, { code: 1306, count: 3 }], abilities: [] },
  5114: { name: "Í¥ÄÎ¨∏", level: 4, defenders: [{ code: 1107, count: 3 }, { code: 1207, count: 3 }, { code: 1307, count: 3 }], abilities: [] },
  5121: { name: "ÏÑ±Ï±Ñ", level: 1, defenders: [{ code: 1105, count: 3 }, { code: 1205, count: 3 }, { code: 1305, count: 3 }], abilities: [] },
  5122: { name: "ÏÑ±Ï±Ñ", level: 2, defenders: [{ code: 1106, count: 3 }, { code: 1206, count: 3 }, { code: 1306, count: 3 }], abilities: [] },
  5123: { name: "ÏÑ±Ï±Ñ", level: 3, defenders: [{ code: 1107, count: 3 }, { code: 1207, count: 3 }, { code: 1307, count: 3 }], abilities: [] },
  5131: { name: "Ïö©", level: 1, defenders: [], abilities: [] },
  5201: { name: "Í∏àÍ¥ë", level: 1, defenders: [{ code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 }], abilities: [{ code: 1, value: 10 }, { code: 2, value: 1 }] },
  5202: { name: "Í∏àÍ¥ë", level: 2, defenders: [{ code: 1106, count: 3 }, { code: 1206, count: 3 }, { code: 1306, count: 3 }], abilities: [{ code: 1, value: 20 }, { code: 2, value: 1 }] },
  5211: { name: "ÏóêÎÑàÏßÄ Î∂ÑÏàò", level: 1, defenders: [{ code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 }], abilities: [{ code: 3, value: 10 }, { code: 4, value: 1 }] },
  5212: { name: "ÏóêÎÑàÏßÄ Î∂ÑÏàò", level: 2, defenders: [{ code: 1106, count: 3 }, { code: 1206, count: 3 }, { code: 1306, count: 3 }], abilities: [{ code: 3, value: 20 }, { code: 4, value: 1 }] },
  5221: { name: "ÏÉÅÏ†ê", level: 1, defenders: [{ code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 }], abilities: [] },
  5231: { name: "Ï£ºÏ†ê", level: 1, defenders: [{ code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 }], abilities: [] },
  5241: { name: "Ïú†Ï†Å", level: 1, defenders: [{ code: 1104, count: 3 }, { code: 1204, count: 3 }, { code: 1304, count: 3 }], abilities: [{ code: 5, value: 5 }, { code: 6, value: 1 }] },
  5242: { name: "Ïú†Ï†Å", level: 2, defenders: [{ code: 1106, count: 3 }, { code: 1206, count: 3 }, { code: 1306, count: 3 }], abilities: [{ code: 5, value: 10 }, { code: 6, value: 1 }] },
  5301: { name: "Í≥µÍ≤©Î†• ÏÑùÏÉÅ", level: 1, defenders: [], abilities: [], statue: { kind: "atk", value: 0.05 } },
  5302: { name: "Í≥µÍ≤©Î†• ÏÑùÏÉÅ", level: 2, defenders: [], abilities: [], statue: { kind: "atk", value: 0.1 } },
  5311: { name: "Î∞©Ïñ¥Î†• ÏÑùÏÉÅ", level: 1, defenders: [], abilities: [], statue: { kind: "def", value: 0.05 } },
  5312: { name: "Î∞©Ïñ¥Î†• ÏÑùÏÉÅ", level: 2, defenders: [], abilities: [], statue: { kind: "def", value: 0.1 } },
  5321: { name: "Ï≤¥Î†• ÏÑùÏÉÅ", level: 1, defenders: [], abilities: [], statue: { kind: "hp", value: 0.05 } },
  5322: { name: "Ï≤¥Î†• ÏÑùÏÉÅ", level: 2, defenders: [], abilities: [], statue: { kind: "hp", value: 0.1 } },
  5331: { name: "ÏÜçÎèÑ ÏÑùÏÉÅ", level: 1, defenders: [], abilities: [], statue: { kind: "spd", value: 0.05 } },
  5332: { name: "ÏÜçÎèÑ ÏÑùÏÉÅ", level: 2, defenders: [], abilities: [], statue: { kind: "spd", value: 0.1 } },
};

const STATUE_BUFF_FALLBACK = { 1: 0.05, 2: 0.10 };
const CITADEL_CP_BONUS = 0;
const GATE_UPKEEP_PER_LEVEL = 1;
const CITADEL_UPKEEP_PER_LEVEL = 2;

const ITEM_TABLE = {
    1801: { name_kr: "Í≥®Îìú", name: "Gold", earn: 1 },
    1802: { name_kr: "Í≥®Îìú", name: "Gold", earn: 2 },
    1803: { name_kr: "Í≥®Îìú", name: "Gold", earn: 6 },
    1804: { name_kr: "Í≥®Îìú", name: "Gold", earn: 14 },
    1805: { name_kr: "Í≥®Îìú", name: "Gold", earn: 32 },
    1811: { name_kr: "ÏóêÎÑàÏßÄ", name: "Energy", earn: 1 },
    1812: { name_kr: "ÏóêÎÑàÏßÄ", name: "Energy", earn: 2 },
    1813: { name_kr: "ÏóêÎÑàÏßÄ", name: "Energy", earn: 6 },
    1814: { name_kr: "ÏóêÎÑàÏßÄ", name: "Energy", earn: 14 },
    1815: { name_kr: "ÏóêÎÑàÏßÄ", name: "Energy", earn: 32 },
    1821: { name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", name: "Crystal", earn: 1 },
    1822: { name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", name: "Crystal", earn: 2 },
    1823: { name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", name: "Crystal", earn: 6 },
    1824: { name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", name: "Crystal", earn: 14 },
    1825: { name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", name: "Crystal", earn: 32 }
};

// --- DATA INTEGRATION (From CSV) ---
const UNIT_STATS = {
    1101: { name: "ÎØºÎ≥ë", hp: 10, atk: 5, def: 10, spd: 5, rng: 1, mov: 1, sell: 0 },
    1102: { name: "Î≥¥Î≥ë", hp: 20, atk: 7, def: 15, spd: 7, rng: 1, mov: 1, sell: 1 },
    1103: { name: "Í≤ÄÎ≥ë", hp: 30, atk: 9, def: 20, spd: 9, rng: 1, mov: 1, sell: 1 },
    1104: { name: "Î∞©Ìå®Î≥ë", hp: 40, atk: 11, def: 25, spd: 11, rng: 1, mov: 1, sell: 2 },
    1105: { name: "Ï§ëÍ∞ëÎ≥ë", hp: 50, atk: 13, def: 30, spd: 13, rng: 1, mov: 1, sell: 3 },
    1106: { name: "Ï†ïÏòàÎ≥ë", hp: 60, atk: 15, def: 35, spd: 15, rng: 1, mov: 1, sell: 6 },
    1107: { name: "Í∑ºÏúÑÎ≥ë", hp: 70, atk: 17, def: 40, spd: 17, rng: 1, mov: 1, sell: 12 },
    1108: { name: "ÌÖúÌîåÎü¨", hp: 80, atk: 19, def: 45, spd: 19, rng: 1, mov: 1, sell: 25 },
    1109: { name: "ÌåîÎùºÎîò", hp: 90, atk: 21, def: 50, spd: 21, rng: 1, mov: 1, sell: 50 },
    1110: { name: "ÏòÅÏõÖ", hp: 100, atk: 23, def: 55, spd: 23, rng: 1, mov: 1, sell: 100 },
    1201: { name: "Ï¥àÎ≥¥ Í∂ÅÏàò", hp: 8, atk: 8, def: 5, spd: 7, rng: 3, mov: 1, sell: 0 },
    1202: { name: "Í∂ÅÏàò", hp: 16, atk: 11, def: 7, spd: 9, rng: 3, mov: 1, sell: 1 },
    1203: { name: "ÏÇ¨ÎÉ•Íæº", hp: 24, atk: 14, def: 9, spd: 11, rng: 3, mov: 1, sell: 1 },
    1204: { name: "Î™ÖÏÇ¨Ïàò", hp: 32, atk: 17, def: 11, spd: 13, rng: 4, mov: 1, sell: 2 },
    1205: { name: "Ï†ÄÍ≤©Ïàò", hp: 40, atk: 20, def: 13, spd: 15, rng: 4, mov: 1, sell: 3 },
    1206: { name: "Ï†ïÏòà Í∂ÅÏàò", hp: 48, atk: 23, def: 15, spd: 17, rng: 4, mov: 1, sell: 6 },
    1207: { name: "Îç∞ÎìúÏïÑÏù¥", hp: 56, atk: 26, def: 17, spd: 19, rng: 5, mov: 1, sell: 12 },
    1208: { name: "Ìå®Ïä§ÌååÏù∏Îçî", hp: 64, atk: 29, def: 19, spd: 21, rng: 5, mov: 1, sell: 25 },
    1209: { name: "Î≥¥Ïö∞ÎßàÏä§ÌÑ∞", hp: 72, atk: 32, def: 21, spd: 23, rng: 5, mov: 1, sell: 50 },
    1210: { name: "Ïã†Í∂Å", hp: 80, atk: 35, def: 23, spd: 25, rng: 6, mov: 1, sell: 100 },
    1301: { name: "Í∏∞Î≥ë", hp: 12, atk: 6, def: 8, spd: 10, rng: 1, mov: 2, sell: 0 },
    1302: { name: "Í≤ΩÍ∏∞Î≥ë", hp: 24, atk: 9, def: 12, spd: 12, rng: 1, mov: 1, sell: 1 },
    1303: { name: "Ï∞ΩÍ∏∞Î≥ë", hp: 36, atk: 12, def: 16, spd: 14, rng: 1, mov: 2, sell: 1 },
    1304: { name: "Í∏∞ÏÇ¨", hp: 48, atk: 15, def: 20, spd: 16, rng: 1, mov: 2, sell: 2 },
    1305: { name: "Ï§ëÍ∏∞Î≥ë", hp: 60, atk: 18, def: 24, spd: 18, rng: 1, mov: 2, sell: 3 },
    1306: { name: "Ï†ïÏòà Í∏∞Î≥ë", hp: 72, atk: 21, def: 28, spd: 20, rng: 1, mov: 2, sell: 6 },
    1307: { name: "Î°úÏñÑ ÎÇòÏù¥Ìä∏", hp: 84, atk: 24, def: 32, spd: 22, rng: 1, mov: 2, sell: 12 },
    1308: { name: "ÎìúÎûòÍ≥§ ÎÇòÏù¥Ìä∏", hp: 96, atk: 27, def: 36, spd: 24, rng: 1, mov: 2, sell: 25 },
    1309: { name: "Î∞úÌÇ§Î¶¨", hp: 108, atk: 30, def: 40, spd: 26, rng: 1, mov: 2, sell: 50 },
    1310: { name: "Ï†ÑÏÑ§Ïùò Í∏∞ÏÇ¨", hp: 120, atk: 33, def: 44, spd: 28, rng: 1, mov: 2, sell: 100 }
};

const BUILDING_DATA = {
    [ITEM_TYPE.BUILDING_BARRACKS]: {
        1: { merge_max: 6, energy: 1, probs: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] },
        2: { merge_max: 7, energy: 2, probs: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        3: { merge_max: 8, energy: 3, probs: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] },
        4: { merge_max: 9, energy: 4, probs: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        5: { merge_max: 10, energy: 5, probs: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] }
    },
    [ITEM_TYPE.BUILDING_RANGE]: {
        1: { merge_max: 6, energy: 1, probs: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] },
        2: { merge_max: 7, energy: 2, probs: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        3: { merge_max: 8, energy: 3, probs: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] },
        4: { merge_max: 9, energy: 4, probs: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        5: { merge_max: 10, energy: 5, probs: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] }
    },
    [ITEM_TYPE.BUILDING_STABLE]: {
        1: { merge_max: 6, energy: 1, probs: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] },
        2: { merge_max: 7, energy: 2, probs: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        3: { merge_max: 8, energy: 3, probs: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] },
        4: { merge_max: 9, energy: 4, probs: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        5: { merge_max: 10, energy: 5, probs: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] }
    }
};

const MERGE_XP_DATA = { 1:1, 2:2, 3:4, 4:5, 5:6, 6:8, 7:10, 8:15, 9:20, 10:0 };
const ITEM_VALUES = { 1: 1, 2: 2, 3: 6, 4: 14, 5: 32 };
const UNLOCK_GOLD_MAP = [[100, 50, 30, 20, 20, 30, 50, 100], [50, 40, 10, 5, 5, 10, 40, 50], [30, 10, 0, 0, 0, 0, 10, 30], [20, 5, 0, 0, 0, 0, 5, 20], [20, 5, 0, 0, 0, 0, 5, 20], [30, 10, 0, 0, 0, 0, 10, 30], [50, 40, 10, 5, 5, 10, 40, 50], [100, 50, 30, 20, 20, 30, 50, 100]];
const UNLOCK_LEVEL_MAP = [[24, 20, 14, 10, 10, 14, 20, 24], [23, 18, 6, 2, 2, 6, 18, 21], [17, 8, 0, 0, 0, 0, 9, 15], [13, 5, 0, 0, 0, 0, 3, 11], [13, 5, 0, 0, 0, 0, 3, 11], [17, 8, 0, 0, 0, 0, 9, 15], [23, 19, 7, 4, 4, 7, 19, 21], [25, 22, 16, 12, 12, 16, 22, 25]];
const CHEST_DROP_TABLE = { 1: [ {code: 1801, prob: 50}, {code: 1811, prob: 50} ], 2: [ {code: 1801, prob: 25}, {code: 1802, prob: 25}, {code: 1811, prob: 25}, {code: 1812, prob: 25} ], 3: [ {code: 1801, prob: 20}, {code: 1802, prob: 20}, {code: 1803, prob: 10}, {code: 1811, prob: 20}, {code: 1812, prob: 20}, {code: 1813, prob: 10} ], 4: [ {code: 1802, prob: 20}, {code: 1803, prob: 20}, {code: 1804, prob: 5}, {code: 1812, prob: 20}, {code: 1813, prob: 20}, {code: 1814, prob: 5}, {code: 1821, prob: 10} ], 5: [ {code: 1802, prob: 15}, {code: 1803, prob: 20}, {code: 1804, prob: 10}, {code: 1812, prob: 15}, {code: 1813, prob: 20}, {code: 1814, prob: 10}, {code: 1821, prob: 5}, {code: 1825, prob: 5} ] };

// --- PHASE 2 MAP DATA (FIELD_OBJECT_1) ---
const FIELD_MAP_DATA = [
  [200, 200, 200, 200, 201, 101, 100, 100, 100, 101, 201, 200, 200, 200, 201, 101, 100, 100, 100, 101, 201, 200, 200, 200, 200],
  [200, 200, 200, 200, 201, 101, 5221, 100, 5231, 101, 201, 200, 200, 200, 201, 101, 5231, 100, 5221, 101, 201, 200, 200, 200, 200],
  [200, 200, 5121, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 5121, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 5121, 200, 200],
  [200, 200, 200, 200, 201, 101, 5211, 100, 5201, 101, 201, 200, 200, 200, 201, 101, 5201, 100, 5211, 101, 201, 200, 200, 200, 200],
  [201, 201, 5111, 201, 201, 101, 101, 100, 101, 101, 201, 201, 200, 201, 201, 101, 101, 100, 101, 101, 201, 201, 5111, 201, 201],
  [101, 101, 101, 101, 101, 301, 301, 5112, 301, 301, 401, 401, 5113, 401, 401, 301, 301, 5112, 301, 301, 101, 101, 100, 101, 101],
  [100, 5221, 100, 5211, 101, 301, 300, 300, 300, 301, 401, 400, 400, 400, 401, 301, 300, 300, 300, 301, 101, 5211, 100, 5221, 100],
  [100, 100, 5101, 100, 100, 5112, 300, 5122, 300, 300, 5113, 400, 5123, 400, 5113, 300, 300, 5122, 300, 5112, 100, 100, 5101, 100, 100],
  [100, 5231, 100, 5201, 101, 301, 300, 300, 300, 301, 401, 400, 400, 400, 401, 301, 300, 300, 300, 301, 101, 5201, 100, 5231, 100],
  [101, 101, 101, 101, 101, 301, 301, 300, 301, 301, 401, 401, 400, 401, 401, 301, 301, 300, 301, 301, 101, 101, 100, 101, 101],
  [201, 201, 5111, 201, 201, 401, 401, 5113, 401, 401, 501, 501, 5114, 501, 501, 401, 401, 5113, 401, 401, 201, 201, 5111, 201, 201],
  [200, 200, 200, 200, 201, 401, 400, 400, 400, 401, 501, 500, 500, 500, 501, 401, 400, 400, 400, 401, 201, 200, 200, 200, 200],
  [200, 200, 5121, 200, 201, 5113, 400, 5123, 400, 400, 5114, 500, 5131, 500, 5114, 400, 400, 5123, 400, 5113, 200, 200, 5121, 200, 200],
  [200, 200, 200, 200, 201, 401, 400, 400, 400, 401, 501, 500, 500, 500, 501, 401, 400, 400, 400, 401, 201, 200, 200, 200, 200],
  [201, 201, 5111, 201, 201, 401, 401, 5113, 401, 401, 501, 501, 5114, 501, 501, 401, 401, 5113, 401, 401, 201, 201, 5111, 201, 201],
  [101, 101, 100, 101, 101, 301, 301, 300, 301, 301, 401, 401, 400, 401, 401, 301, 301, 300, 301, 301, 101, 101, 100, 101, 101],
  [100, 5231, 100, 5201, 101, 301, 300, 300, 300, 301, 401, 400, 400, 400, 401, 301, 300, 300, 300, 301, 101, 5201, 100, 5231, 100],
  [100, 100, 5101, 100, 100, 5112, 300, 5122, 300, 300, 5113, 400, 5123, 400, 5113, 300, 300, 5122, 300, 5112, 100, 100, 5101, 100, 100],
  [100, 5221, 100, 5211, 101, 301, 300, 300, 300, 301, 401, 400, 400, 400, 401, 301, 300, 300, 300, 301, 101, 5211, 100, 5221, 100],
  [101, 101, 100, 101, 101, 301, 301, 5112, 301, 301, 401, 401, 5113, 401, 401, 301, 301, 5112, 301, 301, 101, 101, 100, 101, 101],
  [201, 201, 5111, 201, 201, 101, 101, 100, 101, 101, 201, 201, 200, 201, 201, 101, 101, 100, 101, 101, 201, 201, 5111, 201, 201],
  [200, 200, 200, 200, 201, 101, 5211, 100, 5201, 101, 201, 200, 200, 200, 201, 101, 5201, 100, 5211, 101, 201, 200, 200, 200, 200],
  [200, 200, 5121, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 5101, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 5121, 200, 200],
  [200, 200, 200, 200, 201, 101, 5221, 100, 5231, 101, 201, 200, 200, 200, 201, 101, 5231, 100, 5221, 101, 201, 200, 200, 200, 200],
  [200, 200, 200, 200, 201, 101, 100, 100, 100, 101, 201, 200, 200, 200, 201, 101, 100, 100, 100, 101, 201, 200, 200, 200, 200]
];
const FIELD_TERRAIN_DATA = FIELD_MAP_DATA.map(row => row.slice());
const MAP_SIZE = 25;
const PLAYER_START = { r: 22, c: 7 };
const FOG_RADIUS = 8;

const FIELD_OBJECT_PROB = [
  { code: 5301, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
  { code: 5302, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
  { code: 5311, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
  { code: 5312, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
  { code: 5321, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
  { code: 5322, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
  { code: 5331, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
  { code: 5332, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
  { code: 1801, fields: [50, 50, 0, 0, 0], min: 24, max: 32 },
  { code: 1802, fields: [0, 50, 50, 0, 0], min: 12, max: 16 },
  { code: 1803, fields: [0, 0, 50, 50, 0], min: 6, max: 8 },
  { code: 1804, fields: [0, 0, 0, 50, 50], min: 3, max: 5 },
  { code: 1805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1811, fields: [50, 50, 0, 0, 0], min: 24, max: 32 },
  { code: 1812, fields: [0, 50, 50, 0, 0], min: 12, max: 16 },
  { code: 1813, fields: [0, 0, 50, 50, 0], min: 6, max: 8 },
  { code: 1814, fields: [0, 0, 0, 50, 50], min: 3, max: 5 },
  { code: 1815, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1821, fields: [0, 0, 50, 50, 0], min: 8, max: 12 },
  { code: 1822, fields: [0, 0, 0, 50, 50], min: 4, max: 6 },
  { code: 1823, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1824, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1825, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2101, fields: [0, 20, 20, 30, 30], min: 8, max: 16 },
  { code: 2102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2201, fields: [0, 20, 20, 30, 30], min: 8, max: 16 },
  { code: 2202, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2203, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2204, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2205, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2301, fields: [0, 20, 20, 30, 30], min: 8, max: 16 },
  { code: 2302, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2303, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2304, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2305, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2801, fields: [0, 30, 30, 40, 0], min: 10, max: 20 },
  { code: 2802, fields: [0, 10, 20, 30, 40], min: 5, max: 10 },
  { code: 2803, fields: [0, 0, 0, 30, 70], min: 2, max: 5 },
  { code: 2804, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3101, fields: [0, 20, 20, 30, 30], min: 15, max: 30 },
  { code: 3102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
];

const FIELD_OBJECT_REGEN = [
  { code: 1801, fields: [50, 50, 0, 0, 0], min: 8, max: 16 },
  { code: 1802, fields: [0, 50, 50, 0, 0], min: 4, max: 8 },
  { code: 1803, fields: [0, 0, 50, 50, 0], min: 2, max: 4 },
  { code: 1804, fields: [0, 0, 0, 50, 50], min: 1, max: 2 },
  { code: 1805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1811, fields: [50, 50, 0, 0, 0], min: 8, max: 16 },
  { code: 1812, fields: [0, 50, 50, 0, 0], min: 4, max: 8 },
  { code: 1813, fields: [0, 0, 50, 50, 0], min: 2, max: 4 },
  { code: 1814, fields: [0, 0, 0, 50, 50], min: 1, max: 2 },
  { code: 1815, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1821, fields: [0, 0, 50, 50, 0], min: 1, max: 2 },
  { code: 1822, fields: [0, 0, 0, 50, 50], min: 0, max: 0 },
  { code: 1823, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1824, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 1825, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2101, fields: [0, 20, 20, 30, 30], min: 1, max: 2 },
  { code: 2102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2201, fields: [0, 20, 20, 30, 30], min: 1, max: 2 },
  { code: 2202, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2203, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2204, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2205, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2301, fields: [0, 20, 20, 30, 30], min: 1, max: 2 },
  { code: 2302, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2303, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2304, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2305, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2801, fields: [0, 30, 30, 40, 0], min: 4, max: 8 },
  { code: 2802, fields: [0, 10, 20, 30, 40], min: 2, max: 4 },
  { code: 2803, fields: [0, 0, 0, 30, 70], min: 1, max: 2 },
  { code: 2804, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 2805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3101, fields: [0, 20, 20, 30, 30], min: 2, max: 4 },
  { code: 3102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
  { code: 3105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
];

const OBJECT_REGEN_INTERVAL_MIN = 10;
const OBJECT_REGEN_INTERVAL_MS = OBJECT_REGEN_INTERVAL_MIN * 60 * 1000;


function getTerrainGroupFromCode(code) {
    const base = getTerrainBase(code);
    if (base === 100) return 1;
    if (base === 200) return 2;
    if (base === 300) return 3;
    if (base === 400) return 4;
    if (base === 500) return 5;
    return null;
}

function pickWeightedGroup(weights, pools) {
    const candidates = weights.map((weight, idx) => ({ group: idx + 1, weight, size: pools[idx + 1]?.length || 0 }));
    const eligible = candidates.filter(c => c.weight > 0 && c.size > 0);
    if (eligible.length === 0) {
        const fallback = candidates.filter(c => c.size > 0);
        if (fallback.length === 0) return null;
        return fallback[Math.floor(Math.random() * fallback.length)].group;
    }
    const total = eligible.reduce((sum, c) => sum + c.weight, 0);
    let roll = Math.random() * total;
    for (const c of eligible) {
        roll -= c.weight;
        if (roll <= 0) return c.group;
    }
    return eligible[eligible.length - 1].group;
}

function pickFromPool(group, pools) {
    const pool = pools[group];
    if (!pool || pool.length === 0) return null;
    const idx = Math.floor(Math.random() * pool.length);
    return pool.splice(idx, 1)[0];
}

function buildTerrainPools() {
    const pools = { 1: [], 2: [], 3: [], 4: [], 5: [] };
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const type = FIELD_MAP_DATA[r][c];
            if (!isTerrainCode(type)) continue;
            const group = getTerrainGroupFromCode(type);
            if (group) pools[group].push({ r, c });
        }
    }
    return pools;
}

function applyObjectProbPlacements() {
    const pools = buildTerrainPools();
    const placements = [];
    FIELD_OBJECT_PROB.forEach(entry => {
        const min = entry.min || 0;
        const max = entry.max || 0;
        if (max <= 0) return;
        const count = min === max ? min : (min + Math.floor(Math.random() * (max - min + 1)));
        for (let i = 0; i < count; i++) {
            const group = pickWeightedGroup(entry.fields, pools);
            let cell = group ? pickFromPool(group, pools) : null;
            if (!cell) {
                const fallback = Object.keys(pools).map(n => parseInt(n, 10)).filter(g => pools[g].length > 0);
                if (fallback.length === 0) break;
                const g = fallback[Math.floor(Math.random() * fallback.length)];
                cell = pickFromPool(g, pools);
            }
            if (!cell) break;
            FIELD_MAP_DATA[cell.r][cell.c] = entry.code;
            placements.push({ r: cell.r, c: cell.c, code: entry.code });
        }
    });
    return placements;
}

function applyObjectProbToMap() {
    if (typeof window === 'undefined') return;
    const key = 'kov_field_object_prob_v1';
    let placements = null;
    try {
        const raw = localStorage.getItem(key);
        if (raw) placements = JSON.parse(raw);
    } catch (e) {}
    if (!Array.isArray(placements)) {
        placements = applyObjectProbPlacements();
        try {
            localStorage.setItem(key, JSON.stringify(placements));
        } catch (e) {}
    } else {
        placements.forEach(p => {
            if (!FIELD_MAP_DATA[p.r] || typeof FIELD_MAP_DATA[p.r][p.c] === 'undefined') return;
            if (!isTerrainCode(FIELD_MAP_DATA[p.r][p.c])) return;
            FIELD_MAP_DATA[p.r][p.c] = p.code;
        });
    }
}

applyObjectProbToMap();

function buildRegenPools() {
    const pools = { 1: [], 2: [], 3: [], 4: [], 5: [] };
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const base = FIELD_TERRAIN_DATA?.[r]?.[c];
            if (!isTerrainCode(base)) continue;
            if (!isTerrainCode(FIELD_MAP_DATA[r][c])) continue;
            const group = getTerrainGroupFromCode(base);
            if (group) pools[group].push({ r, c });
        }
    }
    return pools;
}

function countFieldObjects() {
    const counts = {};
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const code = FIELD_MAP_DATA[r][c];
            counts[code] = (counts[code] || 0) + 1;
        }
    }
    return counts;
}

function applyObjectRegenCycle(regenByCode, regenTargets, now) {
    const pools = buildRegenPools();
    const counts = countFieldObjects();
    const placements = [];
    FIELD_OBJECT_REGEN.forEach(entry => {
        const max = entry.max || 0;
        const min = entry.min || 0;
        if (max <= 0) return;
        const current = counts[entry.code] || 0;
        if (!regenTargets[entry.code]) {
            const span = Math.max(0, max - min);
            regenTargets[entry.code] = min + (span > 0 ? Math.floor(Math.random() * (span + 1)) : 0);
        }
        const target = regenTargets[entry.code];
        if (current >= target) return;
        const last = regenByCode?.[entry.code] || 0;
        if (now - last < OBJECT_REGEN_INTERVAL_MS) return;

        const group = pickWeightedGroup(entry.fields, pools);
        let cell = group ? pickFromPool(group, pools) : null;
        if (!cell) {
            const fallback = Object.keys(pools).map(n => parseInt(n, 10)).filter(g => pools[g].length > 0);
            if (fallback.length === 0) return;
            const g = fallback[Math.floor(Math.random() * fallback.length)];
            cell = pickFromPool(g, pools);
        }
        if (!cell) return;
        FIELD_MAP_DATA[cell.r][cell.c] = entry.code;
        counts[entry.code] = current + 1;
        placements.push({ r: cell.r, c: cell.c, code: entry.code });
        if (regenByCode) regenByCode[entry.code] = now;
    });
    return placements;
}

// Helper Functions
function getCode(type, level) {
    if (type === ITEM_TYPE.UNIT_INFANTRY) return 1100 + level;
    if (type === ITEM_TYPE.UNIT_ARCHER) return 1200 + level;
    if (type === ITEM_TYPE.UNIT_CAVALRY) return 1300 + level;
    if (type === ITEM_TYPE.BUILDING_BARRACKS) return 2100 + level;
    if (type === ITEM_TYPE.BUILDING_RANGE) return 2200 + level;
    if (type === ITEM_TYPE.BUILDING_STABLE) return 2300 + level;
    if (type === ITEM_TYPE.BUILDING_CHEST) return 2800 + level;
    if (type === ITEM_TYPE.BUILDING_CAMP) return 3100 + level;
    if (type === ITEM_TYPE.ITEM_GOLD) return 1800 + level;
    if (type === ITEM_TYPE.ITEM_ENERGY) return 1810 + level;
    if (type === ITEM_TYPE.ITEM_CRYSTAL) return 1820 + level;
    return 0;
}
function getInfoFromCode(code) {
    if (code >= 1100 && code < 1200) return { type: ITEM_TYPE.UNIT_INFANTRY, level: code % 100 };
    if (code >= 1200 && code < 1300) return { type: ITEM_TYPE.UNIT_ARCHER, level: code % 100 };
    if (code >= 1300 && code < 1400) return { type: ITEM_TYPE.UNIT_CAVALRY, level: code % 100 };
    if (code >= 2100 && code < 2110) return { type: ITEM_TYPE.BUILDING_BARRACKS, level: code - 2100 };
    if (code >= 2200 && code < 2210) return { type: ITEM_TYPE.BUILDING_RANGE, level: code - 2200 };
    if (code >= 2300 && code < 2310) return { type: ITEM_TYPE.BUILDING_STABLE, level: code - 2300 };
    if (code >= 2800 && code < 2810) return { type: ITEM_TYPE.BUILDING_CHEST, level: code - 2800 };
    if (code >= 3100 && code < 3110) return { type: ITEM_TYPE.BUILDING_CAMP, level: code - 3100 };
    if (code >= 1800 && code < 1810) return { type: ITEM_TYPE.ITEM_GOLD, level: code - 1800 };
    if (code >= 1810 && code < 1820) return { type: ITEM_TYPE.ITEM_ENERGY, level: code - 1810 };
    if (code >= 1820 && code < 1830) return { type: ITEM_TYPE.ITEM_CRYSTAL, level: code - 1820 };
    return null;
}
function getData(type, level) {
    if (type >= 20) {
        if(type === ITEM_TYPE.ITEM_GOLD) return { name: "Í≥®Îìú", earn: ITEM_VALUES[level] };
        if(type === ITEM_TYPE.ITEM_ENERGY) return { name: "ÏóêÎÑàÏßÄ", earn: ITEM_VALUES[level] };
        if(type === ITEM_TYPE.ITEM_CRYSTAL) return { name: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: ITEM_VALUES[level] };
    }
    if (type < 10) {
        if(type === ITEM_TYPE.BUILDING_BARRACKS) return { name: "Î≥ëÏòÅ", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_BARRACKS][level]?.energy };
        if(type === ITEM_TYPE.BUILDING_RANGE) return { name: "ÏÇ¨Í≤©Ïû•", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_RANGE][level]?.energy };
        if(type === ITEM_TYPE.BUILDING_STABLE) return { name: "ÎßàÍµ¨Í∞Ñ", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_STABLE][level]?.energy };
        if(type === ITEM_TYPE.BUILDING_CHEST) return { name: "Î≥¥Î¨ºÏÉÅÏûê" };
        if(type === ITEM_TYPE.BUILDING_CAMP) return { name: "ÎßâÏÇ¨" };
    }
    if (type >= 10 && type < 20) {
        const code = getCode(type, level);
        const stat = UNIT_STATS[code];
        if (stat) return { name: stat.name, class: type===10?"Î≥¥Î≥ë":(type===11?"Í∂ÅÎ≥ë":"Í∏∞Î≥ë"), hp: stat.hp, atk: stat.atk, def: stat.def, spd: stat.spd, rng: stat.rng, mov: stat.mov, sell: stat.sell };
    }
    return { name: "Unknown", earn: 0, sell: 0 };
}

// --- CLASSES ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true; this.bgmStarted = false;
        const BASE = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/audio/`;
        this.files = { bgm: new Audio(BASE+'bgm.mp3'), merge: new Audio(BASE+'merge.mp3'), coin: new Audio(BASE+'coin.mp3'), pop: new Audio(BASE+'pop.mp3') };
        this.files.bgm.loop = true; this.files.bgm.volume = 0.5;
    }
    resume() { if(this.ctx.state==='suspended')this.ctx.resume(); if(this.enabled&&!this.bgmStarted){this.files.bgm.play().then(()=>this.bgmStarted=true).catch(()=>{});} }
    playFile(n, v=1.0) { if(!this.enabled||!this.files[n])return; const s=this.files[n].cloneNode(); s.crossOrigin="anonymous"; s.volume=v; s.play().catch(()=>{}); }
    playTone(f, t, d) { if(!this.enabled)return; const o=this.ctx.createOscillator(), g=this.ctx.createGain(); o.type=t; o.frequency.value=f; g.gain.setValueAtTime(0.1,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); }
    playClick() { this.playFile('pop', 0.6); }
    playError() { this.playTone(150, 'sawtooth', 0.3); }
    playSpawn() { this.playFile('pop', 0.5); }
    playMerge() { this.playFile('merge', 0.8); }
    playCollect() { this.playFile('coin', 0.6); }
    playUnlock() { this.playFile('merge', 0.8); }
    playLevelUp() { [440,554,659,880].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.3),i*100)); }
}

class AssetLoader {
    constructor() { this.images = {}; }
    loadAll(cb) {
        let loaded = 0;
        ASSET_KEYS.forEach(key => {
            const img = new Image(); img.crossOrigin = "Anonymous";
            img.onload = () => { this.images[key] = img; loaded++; if(loaded===ASSET_KEYS.length) cb(); };
            img.onerror = () => { 
                const ext = key === 'field_bg' ? '.jpg' : '.png';
                img.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/img/${key}${ext}`;
                loaded++; if(loaded===ASSET_KEYS.length) cb();
            };
            img.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/img/${key}.png`;
        });
        setTimeout(cb, 2000); 
    }
    getImage(type, level) {
        if(typeof type === 'string') return this.images[type];
        const code = getCode(type, level);
        return this.images[code] || (level > 1 ? this.getImage(type, level - 1) : null);
    }
}

class Particle {
    constructor(x, y, color, type) {
        this.x = x; this.y = y; this.vx = (Math.random()-0.5)*8; this.vy = (Math.random()-0.5)*8;
        this.life = 1.0; this.decay = Math.random()*0.03+0.02; this.color = color; this.size = Math.random()*6+4; this.type = type;
        if(type==='smoke') { this.vy = -Math.abs(this.vy)*0.5; this.decay=0.015; }
    }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; if(this.type==='smoke')this.size+=0.3; else this.vy+=0.2; }
    draw(ctx) { ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color; if(this.type==='confetti'){ ctx.translate(this.x,this.y); ctx.rotate(this.life*5); ctx.fillRect(-this.size/2,-this.size/2,this.size,this.size); ctx.resetTransform(); const s=ctx.canvas.width/1080; ctx.scale(s,s); } else if(this.type==='smoke'){ ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); } else ctx.fillRect(this.x,this.y,this.size,this.size); ctx.globalAlpha=1.0; }
}

class AStar {
    static findPath(start, end, mapData, occupiedTiles) {
        const rows = MAP_SIZE, cols = MAP_SIZE;
        const openSet = [], closedSet = new Set();
        const startNode = { r: start.r, c: start.c, g: 0, h: 0, f: 0, parent: null };
        openSet.push(startNode);
        
        while(openSet.length > 0) {
            let lowInd = 0;
            for(let i=0; i<openSet.length; i++) if(openSet[i].f < openSet[lowInd].f) lowInd = i;
            const current = openSet[lowInd];
            
            if(current.r === end.r && current.c === end.c) {
                const path = []; let temp = current;
                while(temp) { path.push({r: temp.r, c: temp.c}); temp = temp.parent; }
                return path.reverse();
            }
            
            openSet.splice(lowInd, 1);
            closedSet.add(`${current.r},${current.c}`);
            
            const neighbors = [[0,1], [0,-1], [1,0], [-1,0]];
            for(let i=0; i<neighbors.length; i++) {
                const nr = current.r + neighbors[i][0], nc = current.c + neighbors[i][1];
                if(nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    if(closedSet.has(`${nr},${nc}`)) continue;
                    
                    const type = mapData[nr][nc];
                    const isTarget = (nr === end.r && nc === end.c);
                    const isOccupied = occupiedTiles.has(`${nr},${nc}`);
                    
                    let isWalkable = true;
                    if (isBlockingField(type) && !isOccupied && !isTarget) isWalkable = false;
                    
                    if(!isWalkable) continue;
                    
                    const gScore = current.g + 1;
                    let neighbor = openSet.find(n => n.r === nr && n.c === nc);
                    
                    if(!neighbor) {
                        neighbor = { r: nr, c: nc, g: gScore, h: Math.abs(nr-end.r)+Math.abs(nc-end.c), f: 0, parent: current };
                        neighbor.f = neighbor.g + neighbor.h;
                        openSet.push(neighbor);
                    } else if(gScore < neighbor.g) {
                        neighbor.g = gScore; neighbor.f = neighbor.g + neighbor.h; neighbor.parent = current;
                    }
                }
            }
        }
        return null;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        this.width = 1080; this.height = 1920; this.assets = new AssetLoader(); this.sound = new SoundManager();
        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null); this.squad2 = Array(9).fill(null); this.squad3 = Array(9).fill(null);
        this.particles = [];
        this.lordLevel = 1; this.currentXp = 0; 
        this.energy = 50; this.gold = 3000; this.gem = 50; 
        this.cp = 20;
        this.baseMaxCp = 20; this.baseCpRegen = 1;
        this.cpBonus = 0; this.cpRegenBonus = 0;
        this.maxCp = this.baseMaxCp; this.cpRegen = this.baseCpRegen;
        
        this.occupiedTiles = new Set();
        this.occupiedTiles.add(`${PLAYER_START.r},${PLAYER_START.c}`); 
        this.income = 0;
        
        this.selectedArmyId = null;
        this.lastSelectedArmyId = null;
        this.currentFieldTargetKey = null;
        this.currentFieldTargetType = null;
        this.fieldResourceState = {};
        this.fieldShopState = {};
        this.currentShopContext = null;
        this.shopTimer = null;
        this.fieldObjectState = {};
        this.fieldBuffs = { atk: 0, def: 0, hp: 0, spd: 0 };
        this.citadelCount = 0;
        this.thirdSquadUnlocked = false;
        this.moveTargetMode = null;
        this.previewPath = null;
        this.movePreviewText = "";
        this.isResetting = false;

        this.visibilityMap = new Set();
        this.revealFog(PLAYER_START.r, PLAYER_START.c, FOG_RADIUS);
        
        this.grassTexture = this.createGrassPattern();

        this.settings = { bgm: true, sfx: true };

        this.drag = null; this.hover = null; this.selectedItem = null; this.potentialDrag = null; this.dpr = window.devicePixelRatio || 1;
        
        this.armies = [
            { id: 0, name: "Ï†ú1Î∂ÄÎåÄ", color: "#4caf50", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 },
            { id: 1, name: "Ï†ú2Î∂ÄÎåÄ", color: "#2196f3", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 },
            { id: 2, name: "Ï†ú3Î∂ÄÎåÄ", color: "#f59e0b", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 }
        ];

        this.calcLayout(); 
        const resetFlag = localStorage.getItem('kov_force_reset') === '1';
        if (resetFlag) {
            try {
                localStorage.removeItem('kov_force_reset');
                localStorage.removeItem('kov_save_v1');
                localStorage.removeItem('kov_field_object_prob_v1');
                localStorage.removeItem('kov_uid');
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('kov_')) localStorage.removeItem(key);
                }
            } catch (e) {}
        }
        if(!resetFlag && this.loadGame()) { this.updateLevelStats(); }
        else { this.initGame(); }
        this.recalcFieldBonuses();
        this.updateUI();

        setInterval(() => this.regenEnergy(), 1000);
        setInterval(() => this.regenCp(), 1000);
        setInterval(() => this.collectTerritoryIncome(), 3000); 
        this.initObjectRegen();
        window.addEventListener('resize', () => { this.resize(); this.requestRender(); });
        this.resize(); this.setupInput();
        this.assets.loadAll(() => { this.requestRender(); });
        this.loop(); this.updateUI();
        
        if(!localStorage.getItem('kov_uid')) localStorage.setItem('kov_uid', 'U' + Math.floor(Math.random()*1000000));
        document.getElementById('settings-uid').innerText = localStorage.getItem('kov_uid');
    }
    
    createGrassPattern() {
        const c = document.createElement('canvas');
        c.width = 32; c.height = 32;
        const x = c.getContext('2d');
        x.fillStyle = '#4a6e3a';
        x.fillRect(0,0,32,32);
        for(let i=0; i<30; i++) {
            x.fillStyle = Math.random() > 0.5 ? '#567d46' : '#3e5c30'; 
            const px = Math.floor(Math.random()*32);
            const py = Math.floor(Math.random()*32);
            x.fillRect(px, py, 1, 1);
        }
        return c.toDataURL();
    }

    saveGame() {
        try {
            if (this.isResetting || localStorage.getItem('kov_force_reset') === '1') return;
            const data = {
                grid: this.grid, gridState: this.gridState, squad1: this.squad1, squad2: this.squad2, squad3: this.squad3,
                lordLevel: this.lordLevel, currentXp: this.currentXp, energy: this.energy, gold: this.gold, gem: this.gem,
                cp: this.cp, maxCp: this.maxCp,
                occupiedTiles: Array.from(this.occupiedTiles), settings: this.settings,
                visibilityMap: Array.from(this.visibilityMap),
                lastSelectedArmyId: this.lastSelectedArmyId,
                fieldResourceState: this.fieldResourceState,
                fieldShopState: this.fieldShopState,
                fieldObjectState: this.fieldObjectState,
                fieldBuffs: this.fieldBuffs,
                armies: this.armies 
            };
            localStorage.setItem('kov_save_v1', JSON.stringify(data));
        } catch(e) {}
    }
    loadGame() {
        try {
            const saved = localStorage.getItem('kov_save_v1'); if(!saved) return false;
            const data = JSON.parse(saved);
            const isValidGrid = (grid) => Array.isArray(grid) && grid.length === CONFIG.gridRows && grid.every(row => Array.isArray(row) && row.length === CONFIG.gridCols);
            const isValidSquad = (squad) => Array.isArray(squad) && squad.length === 9;
            const validGrid = isValidGrid(data.grid);
            const validGridState = isValidGrid(data.gridState);
            if (!validGrid) {
                try { localStorage.removeItem('kov_save_v1'); } catch (e) {}
                return false;
            }
            this.grid = data.grid;
            this.gridState = validGridState ? data.gridState : this.gridState;
            this.squad1 = isValidSquad(data.squad1) ? data.squad1 : this.squad1;
            this.squad2 = isValidSquad(data.squad2) ? data.squad2 : this.squad2;
            this.squad3 = isValidSquad(data.squad3) ? data.squad3 : this.squad3;
            this.lordLevel = data.lordLevel || 1; this.currentXp = data.currentXp || 0;
            this.energy = data.energy ?? 50; this.gold = data.gold ?? 3000; this.gem = data.gem ?? 50;
            this.cp = data.cp ?? 20; this.maxCp = data.maxCp ?? 20;
            if(data.occupiedTiles) this.occupiedTiles = new Set(data.occupiedTiles);
            if(data.visibilityMap) this.visibilityMap = new Set(data.visibilityMap);
            if(data.lastSelectedArmyId !== undefined) this.lastSelectedArmyId = data.lastSelectedArmyId;
            if(data.fieldResourceState) this.fieldResourceState = data.fieldResourceState;
            if(data.fieldShopState) this.fieldShopState = data.fieldShopState;
            if(data.fieldObjectState) this.fieldObjectState = data.fieldObjectState;
            if(data.fieldBuffs) this.fieldBuffs = data.fieldBuffs;
            if(data.settings) { this.settings = data.settings; this.applySettings(); }
            if(data.armies) {
                this.armies = data.armies;
                if (this.armies.length < 3) {
                    this.armies.push({ id: 2, name: "Ï†ú3Î∂ÄÎåÄ", color: "#f59e0b", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 });
                }
            }
            if (!validGridState) this.refreshLockState();
            if (!this.occupiedTiles || this.occupiedTiles.size === 0) this.occupiedTiles = new Set([`${PLAYER_START.r},${PLAYER_START.c}`]);
            else this.occupiedTiles.add(`${PLAYER_START.r},${PLAYER_START.c}`);
            this.revealFog(PLAYER_START.r, PLAYER_START.c, FOG_RADIUS);
            return true;
        } catch(e) {
            try { localStorage.removeItem('kov_save_v1'); } catch (err) {}
            return false;
        }
    }
    resetGame() {
        if(confirm("Ï†ïÎßê Í≤åÏûÑÏùÑ Ï¥àÍ∏∞Ìôî ÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
            this.isResetting = true;
            try {
                localStorage.setItem('kov_force_reset', '1');
                localStorage.removeItem('kov_save_v1');
                localStorage.removeItem('kov_field_object_prob_v1');
                localStorage.removeItem('kov_uid');
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('kov_')) localStorage.removeItem(key);
                }
                if (localStorage.getItem('kov_save_v1')) {
                    localStorage.clear();
                }
            } catch (e) {}
            window.location.reload();
        }
    }

    openSettings() { document.getElementById('modal-settings').classList.add('open'); }
    toggleSetting(key, el) {
        this.settings[key] = !this.settings[key]; el.classList.toggle('on');
        const knob = el.querySelector('.toggle-knob'); knob.style.left = this.settings[key] ? '22px' : '2px';
        if (key === 'bgm') { if(this.settings.bgm) this.sound.files.bgm.play().catch(()=>{}); else this.sound.files.bgm.pause(); }
        this.sound.enabled = this.settings.sfx; this.saveGame();
    }
    applySettings() { this.sound.enabled = this.settings.sfx; }
    openRefill(type) {
        const modal = document.getElementById('modal-refill'); const content = document.getElementById('refill-options'); const title = document.getElementById('refill-title');
        content.innerHTML = ""; modal.classList.add('open');
        let data = REFILL_DATA[type];
        title.innerText = type === 'energy' ? "ÏóêÎÑàÏßÄ Ï∂©Ï†Ñ" : (type === 'gold' ? "Í≥®Îìú Íµ¨Îß§" : (type === 'cp' ? "ÏßÄÌúòÎ†• Ï∂©Ï†Ñ" : "ÌÅ¨Î¶¨Ïä§ÌÉà ÏÉÅÏ†ê"));
        data.forEach(item => {
            const btn = document.createElement('button'); btn.className = "bg-gray-700 hover:bg-gray-600 p-4 rounded-lg flex justify-between items-center text-white border border-gray-600";
            btn.innerHTML = `<span class="font-bold">${item.name}</span><span class="bg-blue-600 px-3 py-1 rounded text-sm">${item.currency==='usd'?'$'+item.cost:'üíé '+item.cost}</span>`;
            btn.onclick = () => {
                if (item.currency === 'crystal') {
                    if (this.gem >= item.cost) {
                        this.gem -= item.cost;
                        if (type === 'energy') this.energy += item.amount;
                        else if (type === 'cp') this.cp += item.amount;
                        else this.gold += item.amount;
                        this.sound.playCollect(); this.updateUI(); modal.classList.remove('open');
                    }
                    else { this.showToast("üíé ÌÅ¨Î¶¨Ïä§ÌÉàÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); this.sound.playError(); }
                } else this.showToast("Ïù∏Ïï± Í≤∞Ï†ú Ï§ÄÎπÑ Ï§ëÏûÖÎãàÎã§.");
            }; content.appendChild(btn);
        });
    }
    showLevelUpModal(prevLv, prevEn) {
        document.getElementById('lv-old').innerText = prevLv; document.getElementById('lv-new').innerText = this.lordLevel;
        document.getElementById('en-old').innerText = prevEn; const d = LEVEL_DATA.find(d => d.level === this.lordLevel); document.getElementById('en-new').innerText = d ? d.maxEnergy : 50;
        document.getElementById('modal-levelup').classList.add('open'); const banner = document.getElementById('levelup-banner'); banner.classList.remove('show'); void banner.offsetWidth; banner.classList.add('show'); setTimeout(() => banner.classList.remove('show'), 2500);
    }

    requestRender() { this.isDirty = true; }
    spawnParticles(x, y, color, count, type) { for(let i=0;i<count;i++) this.particles.push(new Particle(x,y,color,type)); this.isDirty=true; }
    regenEnergy() { 
        // Logic for Energy Fountain (Type 6)
        let regenBonus = 1;
        this.occupiedTiles.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            if (isFountainTile(FIELD_MAP_DATA[r][c])) regenBonus += 1;
        });

        if (this.energy < this.maxEnergy) { 
            this.energyRegenAcc = (this.energyRegenAcc || 0) + regenBonus; 
            if(this.energyRegenAcc >= 5) { 
                this.energy++; this.energyRegenAcc = 0; this.updateUI(); 
            } 
        } 
    }
    regenCp() {
        if (this.cp < this.maxCp) {
            this.cpRegenAcc = (this.cpRegenAcc || 0) + this.cpRegen;
            if (this.cpRegenAcc >= 5) {
                this.cp++; this.cpRegenAcc = 0; this.updateUI();
            }
        }
    }
    initObjectRegen() {
        if (!this.fieldObjectState) this.fieldObjectState = {};
        if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
        if (!this.fieldObjectState.regenTargetByCode) this.fieldObjectState.regenTargetByCode = {};
        const now = Date.now();
        FIELD_OBJECT_REGEN.forEach(entry => {
            if ((entry.max || 0) <= 0) return;
            if (this.fieldObjectState.regenByCode[entry.code] === undefined) {
                this.fieldObjectState.regenByCode[entry.code] = now;
            }
            if (this.fieldObjectState.regenTargetByCode[entry.code] === undefined) {
                const min = entry.min || 0;
                const max = entry.max || 0;
                const span = Math.max(0, max - min);
                this.fieldObjectState.regenTargetByCode[entry.code] = min + (span > 0 ? Math.floor(Math.random() * (span + 1)) : 0);
            }
        });
        if (this.objectRegenTimer) clearInterval(this.objectRegenTimer);
        this.objectRegenTimer = setInterval(() => this.runObjectRegen(), 1000);
    }
    runObjectRegen() {
        const now = Date.now();
        if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
        if (!this.fieldObjectState.regenTargetByCode) this.fieldObjectState.regenTargetByCode = {};
        const placements = applyObjectRegenCycle(this.fieldObjectState.regenByCode, this.fieldObjectState.regenTargetByCode, now);
        if (placements.length > 0) {
            if (document.getElementById('field-modal').classList.contains('open') && !this.moveTargetMode) {
                this.renderFieldMap();
            } else {
                this.requestRender();
            }
        }
        this.saveGame();
    }
    getTaxRate(type) { 
        if (isGateTile(type)) return 3; // Gate
        if (isCitadelTile(type)) return 5; // Citadel/Fortress
        if (isGoldMineTile(type)) return 20; // Gold Mine (Bonus)
        if (isShopTile(type) || isTavernTile(type)) return 5;
        return 1; 
    }
    getUpkeepCost(type) {
        if (isGateTile(type)) return this.getFieldLevel(type) * GATE_UPKEEP_PER_LEVEL;
        if (isCitadelTile(type)) return this.getFieldLevel(type) * CITADEL_UPKEEP_PER_LEVEL;
        return 0;
    }
    getTileMoveTime(type, r, c) {
        // ÌÉÄÏûÖ: Í∏∞Î≥∏ FIELD_MAP_DATA(0~6) + ÏßÄÌòï Í∏∞Î≥∏ ÏΩîÎìú(100~501)
        if (isGateTile(type) || isCitadelTile(type)) return 5;
        if (isDragonTile(type)) return 6;
        if (type === 4) return 1; // ÎèÑÎ°ú

        let evalType = type;
        if (!isTerrainCode(type) && typeof r === "number" && typeof c === "number") {
            const base = FIELD_TERRAIN_DATA?.[r]?.[c];
            if (isTerrainCode(base)) evalType = base;
        }
        if (isTerrainCode(evalType)) {
            const base = getTerrainBase(evalType);
            if (base === 100) return 3; // ÌèâÏõê
            if (base === 200) return 5; // Ïà≤
            if (base === 300) return 4; // Í≥†Ïõê
            if (base === 400) return 5; // ÏÇ∞ÏïÖ
            if (base === 500) return 6; // ÌôîÏÇ∞
            return 3;
        }
        return 3; // Í∏∞Î≥∏ ÏßÄÌòï
    }
    getTileMoveMeta(type, r, c) {
        let name = "ÏßÄÌòï";
        if (type === 4) name = "ÎèÑÎ°ú";
        else if (isGateTile(type)) name = "Í¥ÄÎ¨∏";
        else if (isCitadelTile(type)) name = "ÏÑ±Ï±Ñ";
        else if (isDragonTile(type)) name = "ÎìúÎûòÍ≥§";
        else {
            let evalType = type;
            if (!isTerrainCode(type) && typeof r === "number" && typeof c === "number") {
                const base = FIELD_TERRAIN_DATA?.[r]?.[c];
                if (isTerrainCode(base)) evalType = base;
            }
            if (isTerrainCode(evalType)) name = getTerrainBaseName(evalType);
        }
        return { name, min: this.getTileMoveTime(type, r, c) };
    }
    getPathTimeMin(path, speedFactor = 1) {
        if (!path || path.length <= 1) return 0;
        let total = 0;
        for (let i = 1; i < path.length; i++) {
            const step = path[i];
            const tileType = FIELD_MAP_DATA[step.r][step.c];
            total += this.getTileMoveTime(tileType, step.r, step.c);
        }
        return total * speedFactor;
    }
    getPathSummary(path, speedFactor = 1) {
        if (!path || path.length <= 1) return { dist: 0, baseMin: 0, finalMin: 0, breakdown: "" };
        const counts = {};
        let total = 0;
        for (let i = 1; i < path.length; i++) {
            const step = path[i];
            const tileType = FIELD_MAP_DATA[step.r][step.c];
            const meta = this.getTileMoveMeta(tileType, step.r, step.c);
            total += meta.min;
            counts[meta.name] = (counts[meta.name] || 0) + 1;
        }
        const breakdown = Object.keys(counts).map(k => `${k}${counts[k]}`).join(" ");
        return { dist: path.length - 1, baseMin: total, finalMin: total * speedFactor, breakdown };
    }
    buildStepTimes(path, speedFactor = 1) {
        if (!path || path.length <= 1) return [];
        const times = [0];
        for (let i = 1; i < path.length; i++) {
            const step = path[i];
            const tileType = FIELD_MAP_DATA[step.r][step.c];
            const mins = this.getTileMoveTime(tileType, step.r, step.c) * speedFactor;
            times[i] = Math.max(30, Math.floor(mins * MOVE_MS_PER_MIN));
        }
        return times;
    }
    collectTerritoryIncome() {
        if (this.occupiedTiles.size > 0) {
            let totalTax = 0; 
            let totalUpkeep = 0;
            this.occupiedTiles.forEach(key => { 
                const [r, c] = key.split(',').map(Number); 
                const type = FIELD_MAP_DATA[r][c];
                totalTax += this.getTaxRate(type);
                totalUpkeep += this.getUpkeepCost(type);
            });
            const net = totalTax - totalUpkeep;
            this.income = net; this.gold += net; 
            this.updateUI(); 
            if (document.getElementById('field-modal').classList.contains('open')) {
                const sign = net >= 0 ? "+" : "";
                this.showFloatingText(`${sign}${net} G (Tax)`, this.width/2, this.height/4, net >= 0 ? '#ffd700' : '#f87171');
            }
        } else {
            this.income = 0;
        }
    }
    calcLayout() {
        const gw = this.width - (CONFIG.gridPadding * 2); this.gridTileSize = Math.floor(gw / CONFIG.gridCols);
        this.gridStartX = CONFIG.gridPadding; this.gridStartY = CONFIG.gridTopY;
        const useThird = this.thirdSquadUnlocked;
        const squadSize = useThird ? CONFIG.squadCellSize3 : CONFIG.squadCellSize;
        const squadGap = useThird ? CONFIG.squadGap3 : CONFIG.squadGap;
        this.squadCellSize = squadSize;
        const sw = this.squadCellSize * 3;
        const squadCount = useThird ? 3 : 2;
        const totalSw = (sw * squadCount) + (squadGap * (squadCount - 1));
        const sx = Math.floor((this.width - totalSw) / 2);
        this.squad1Rect = { x: sx, y: CONFIG.squadTopY, w: sw, h: sw };
        this.squad2Rect = { x: sx + sw + squadGap, y: CONFIG.squadTopY, w: sw, h: sw };
        if (useThird) {
            this.squad3Rect = { x: sx + (sw + squadGap) * 2, y: CONFIG.squadTopY, w: sw, h: sw };
        } else {
            this.squad3Rect = null;
        }
    }
    initGame() {
        this.refreshLockState(); this.grid[3][3] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1, usage: 5 };
        this.grid[5][5] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnits: [] }; // Added storedUnits
        this.updateLevelStats();
    }
    refreshLockState() {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if (this.gridState[r][c] && this.gridState[r][c].type === LOCK_TYPE.OPEN) continue;
            const lvlReq = UNLOCK_LEVEL_MAP[r][c], goldReq = UNLOCK_GOLD_MAP[r][c];
            if (this.lordLevel < lvlReq) this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: lvlReq };
            else if (goldReq > 0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: goldReq };
            else this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
        }
        this.requestRender();
    }
    toggleShop() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        title.innerText = "Í±¥ÏÑ§ ÏÉÅÏ†ê"; content.innerHTML = "";
        if (modal.classList.contains('open') && modal.dataset.mode === 'shop') { this.closeModal(); return; }
        modal.dataset.mode = 'shop'; modal.classList.add('open');
        const grid = document.createElement('div'); grid.className = 'shop-grid';
        SHOP_DATA.forEach(item => {
            const div = document.createElement('div'); div.className = 'shop-item';
            div.innerHTML = `<div class="text-2xl">${item.icon}</div><div class="font-bold text-sm text-white">${item.name}</div><button class="bg-yellow-600 text-white px-3 py-1 mt-2 rounded font-bold text-xs" onclick="game.buyBuilding(${item.type}, ${item.price})">üí∞ ${item.price}</button>`;
            grid.appendChild(div);
        });
        content.appendChild(grid);
    }
    toggleField() {
        const modal = document.getElementById('field-modal');
        if (modal.classList.contains('open') && modal.dataset.mode === 'field') { this.closeModal(); return; }
        this.camera = null; this.renderFieldMap();
    }

    revealFog(r, c, radius = FOG_RADIUS) {
        for(let i = -radius; i <= radius; i++) {
            for(let j = -radius; j <= radius; j++) {
                const nr = r + i, nc = c + j;
                if(nr >= 0 && nr < MAP_SIZE && nc >= 0 && nc < MAP_SIZE) {
                    const key = `${nr},${nc}`;
                    if(!this.visibilityMap.has(key)) {
                        this.visibilityMap.add(key);
                        const cell = document.getElementById(`field-cell-${nr}-${nc}`);
                        if(cell) {
                            cell.classList.remove('field-fog');
                            if (!cell.classList.contains('field-occupied') && !cell.classList.contains('field-adjacent')) cell.style.opacity = 0.3;
                            else if (cell.classList.contains('field-adjacent')) cell.style.opacity = 0.6;
                        }
                    }
                }
            }
        }
    }

    setMovePreview(text) {
        this.movePreviewText = text || "";
        const el = document.getElementById('field-move-info');
        if (el) {
            if (this.movePreviewText) {
                el.style.display = 'flex';
                el.innerText = this.movePreviewText;
            } else {
                el.style.display = 'none';
            }
        }
        this.updateFloatingPanelPositionFromSelection();
    }

    openObjectModal(title, bodyHtml) {
        const modal = document.getElementById('modal-object');
        const t = document.getElementById('object-modal-title');
        const b = document.getElementById('object-modal-body');
        if (!modal || !t || !b) return;
        modal.querySelector('.modal-content')?.classList.add('wide');
        t.innerText = title;
        b.innerHTML = bodyHtml;
        modal.classList.add('open');
    }

    formatTimeLeft(ms) {
        if (ms <= 0) return "Í∞±Ïã†Îê®";
        const totalMin = Math.ceil(ms / 60000);
        const h = Math.floor(totalMin / 60);
        const m = totalMin % 60;
        if (h <= 0) return `${m}Î∂Ñ`;
        return `${h}ÏãúÍ∞Ñ ${m}Î∂Ñ`;
    }

    formatPercent(value) {
        return `${Math.round(value * 100)}%`;
    }

    getFieldObjectData(type) {
        if (FIELD_OBJECT_DATA[type]) return FIELD_OBJECT_DATA[type];
        if (isGateTile(type)) {
            const level = getObjectLevelFromCode(type);
            const defenders = FIELD_DEFENDERS[Math.min(4, level)] || [];
            return { name: "Í¥ÄÎ¨∏", level, defenders, abilities: [] };
        }
        if (isCitadelTile(type)) {
            const level = getObjectLevelFromCode(type);
            const defenders = FIELD_DEFENDERS[Math.min(4, level + 1)] || FIELD_DEFENDERS[2] || [];
            return { name: "ÏÑ±Ï±Ñ", level, defenders, abilities: [] };
        }
        if (isDragonTile(type)) return { name: "Ïö©", level: 1, defenders: [], abilities: [] };
        return null;
    }

    getAbilityValue(data, abilityCode) {
        if (!data || !data.abilities) return 0;
        const found = data.abilities.find(a => a.code === abilityCode);
        return found ? Number(found.value) : 0;
    }

    getFieldLevel(type) {
        const data = this.getFieldObjectData(type);
        if (data && data.level) return data.level;
        return getObjectLevelFromCode(type);
    }

    getStatueBuff(type) {
        const data = this.getFieldObjectData(type);
        if (data?.statue) return data.statue;
        const kind = getStatueKind(type);
        if (!kind) return null;
        const level = this.getFieldLevel(type);
        const value = STATUE_BUFF_FALLBACK[level] || 0;
        return value ? { kind, value } : null;
    }

    getRuinsBonus(type) {
        if (!isRuinsTile(type)) return null;
        const data = this.getFieldObjectData(type);
        if (!data) return null;
        const cpCap = this.getAbilityValue(data, ABILITY_CODES.CP_CAP);
        const cpRegen = this.getAbilityValue(data, ABILITY_CODES.CP_REGEN);
        if (!cpCap && !cpRegen) return null;
        return { level: data.level || this.getFieldLevel(type), cpCap, cpRegen };
    }

    getFieldResourceConfig(type) {
        const data = this.getFieldObjectData(type);
        if (!data) return null;
        const goldCap = this.getAbilityValue(data, ABILITY_CODES.GOLD_CAP);
        const goldRegen = this.getAbilityValue(data, ABILITY_CODES.GOLD_REGEN);
        if (goldCap || goldRegen) return { kind: "gold", cap: goldCap, regen5: goldRegen };
        const energyCap = this.getAbilityValue(data, ABILITY_CODES.ENERGY_CAP);
        const energyRegen = this.getAbilityValue(data, ABILITY_CODES.ENERGY_REGEN);
        if (energyCap || energyRegen) return { kind: "energy", cap: energyCap, regen5: energyRegen };
        return null;
    }

    getFieldResourceState(type, r, c) {
        const cfg = this.getFieldResourceConfig(type);
        if (!cfg) return null;
        const key = `${r},${c}`;
        const now = Date.now();
        const state = this.fieldResourceState[key] || { last: now, stored: 0 };
        const regenMs = cfg.regen5 / (5 * 60 * 1000);
        if (regenMs > 0) {
            const elapsed = now - state.last;
            if (elapsed > 0) {
                const gained = Math.floor(elapsed * regenMs);
                if (gained > 0) {
                    state.stored = Math.min(cfg.cap, state.stored + gained);
                    const consumedMs = gained / regenMs;
                    state.last = Math.min(now, state.last + consumedMs);
                }
            }
        }
        if (state.stored >= cfg.cap) {
            if (!state.capNotified) {
                state.capNotified = true;
                if (document.getElementById('field-modal').classList.contains('open')) {
                    const kind = cfg.kind === "gold" ? "Í∏àÍ¥ë" : "Î∂ÑÏàò";
                    this.showToast(`${kind} ÏµúÎåÄÏπò ÎèÑÎã¨`);
                }
            }
        } else {
            state.capNotified = false;
        }
        this.fieldResourceState[key] = state;
        return { key, state, cfg };
    }

    collectFieldResource(type, r, c) {
        const key = `${r},${c}`;
        if (!this.occupiedTiles.has(key)) { this.showToast("Ï†êÎ†π ÌõÑ ÏàòÎ†π Í∞ÄÎä•"); return; }
        const info = this.getFieldResourceState(type, r, c);
        if (!info || info.state.stored <= 0) { this.showToast("ÏÉùÏÇ∞ Ï§ë"); return; }
        if (info.cfg.kind === "gold") {
            this.gold += info.state.stored;
            this.showToast(`+${info.state.stored}G`);
        } else if (info.cfg.kind === "energy") {
            this.energy = Math.min(this.maxEnergy, this.energy + info.state.stored);
            this.showToast(`+${info.state.stored}‚ö°`);
        }
        info.state.stored = 0;
        info.state.capNotified = false;
        info.state.last = Date.now();
        this.fieldResourceState[key] = info.state;
        this.updateUI();
    }

    getCollectibleFieldItemInfo(type) {
        if (isTerrainCode(type)) return null;
        return getInfoFromCode(type);
    }

    createMergeItemFromInfo(info) {
        const item = { type: info.type, level: info.level, scale: 0 };
        if (item.type === ITEM_TYPE.BUILDING_CHEST) item.usage = 5;
        if (item.type === ITEM_TYPE.BUILDING_CAMP) item.storedUnits = [];
        return item;
    }

    removeObjectProbPlacement(r, c) {
        if (typeof window === 'undefined') return;
        const key = 'kov_field_object_prob_v1';
        let placements = null;
        try {
            const raw = localStorage.getItem(key);
            if (raw) placements = JSON.parse(raw);
        } catch (e) {}
        if (!Array.isArray(placements)) return;
        const next = placements.filter(p => !(p.r === r && p.c === c));
        if (next.length === placements.length) return;
        try { localStorage.setItem(key, JSON.stringify(next)); } catch (e) {}
    }

    clearFieldObjectFromMap(r, c) {
        const base = FIELD_TERRAIN_DATA?.[r]?.[c];
        if (base !== undefined && base !== null) FIELD_MAP_DATA[r][c] = base;
        else FIELD_MAP_DATA[r][c] = 100;
        this.removeObjectProbPlacement(r, c);
    }

    isFieldReachable(r, c) {
        const targetKey = `${r},${c}`;
        if (this.occupiedTiles.has(targetKey)) return true;
        if (!this.occupiedTiles.size) return false;
        const queue = [];
        const visited = new Set();
        this.occupiedTiles.forEach(key => {
            const [sr, sc] = key.split(',').map(Number);
            queue.push({ r: sr, c: sc });
            visited.add(key);
        });
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
        while (queue.length) {
            const cur = queue.shift();
            for (const d of dirs) {
                const nr = cur.r + d[0];
                const nc = cur.c + d[1];
                if (nr < 0 || nr >= MAP_SIZE || nc < 0 || nc >= MAP_SIZE) continue;
                const nkey = `${nr},${nc}`;
                if (visited.has(nkey)) continue;
                const type = FIELD_MAP_DATA[nr][nc];
                const isTarget = nkey === targetKey;
                const isOccupied = this.occupiedTiles.has(nkey);
                if (isBlockingField(type) && !isOccupied && !isTarget) continue;
                if (nkey === targetKey) return true;
                visited.add(nkey);
                queue.push({ r: nr, c: nc });
            }
        }
        return false;
    }

    canCollectFieldObject(r, c) {
        return this.isFieldReachable(r, c);
    }

    collectFieldObjectToMerge(type, r, c) {
        if (!this.canCollectFieldObject(r, c)) { this.showToast("ÏßÑÏûÖ ÌõÑ ÌöçÎìù Í∞ÄÎä•"); return; }
        const info = this.getCollectibleFieldItemInfo(type);
        if (!info) { this.showToast("ÌöçÎìù Î∂àÍ∞Ä"); return; }
        const item = this.createMergeItemFromInfo(info);
        if (!this.spawnItem(item)) { this.showToast("Î®∏ÏßÄ Ïä¨Î°Ø Í≥µÍ∞Ñ Î∂ÄÏ°±"); return; }

        this.clearFieldObjectFromMap(r, c);
        if (this.fieldObjectState) {
            if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
            this.fieldObjectState.regenByCode[type] = Date.now();
        }
        this.sound.playCollect();
        this.requestRender();
        this.updateUI();

        if (document.getElementById('field-modal').classList.contains('open')) {
            this.renderFieldMap();
            this.setFieldInfo(FIELD_MAP_DATA[r][c], r, c);
        }
        this.showToast("ÌöçÎìù ÏôÑÎ£å");
    }


    applyCpBonuses() {
        const baseMax = this.baseMaxCp ?? this.maxCp ?? 20;
        const baseRegen = this.baseCpRegen ?? this.cpRegen ?? 1;
        this.maxCp = baseMax + (this.cpBonus || 0);
        this.cpRegen = Math.max(0.2, baseRegen + (this.cpRegenBonus || 0));
        if (this.cp > this.maxCp) this.cp = this.maxCp;
    }

    recalcFieldBonuses() {
        const buffs = { atk: 0, def: 0, hp: 0, spd: 0 };
        let cpCapBonus = 0;
        let cpRegenBonus = 0;
        let citadelCount = 0;

        this.occupiedTiles.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            const type = FIELD_MAP_DATA[r][c];
            if (isStatueTile(type)) {
                const buff = this.getStatueBuff(type);
                if (buff && buff.value) buffs[buff.kind] += buff.value;
            }
            if (isRuinsTile(type)) {
                const bonus = this.getRuinsBonus(type);
                if (bonus) {
                    cpCapBonus += bonus.cpCap;
                    cpRegenBonus += bonus.cpRegen;
                }
            }
            if (isCitadelTile(type)) citadelCount += 1;
        });

        this.fieldBuffs = buffs;
        this.citadelCount = citadelCount;
        this.cpBonus = cpCapBonus + (citadelCount * CITADEL_CP_BONUS);
        this.cpRegenBonus = cpRegenBonus;
        const prevThird = this.thirdSquadUnlocked;
        this.thirdSquadUnlocked = citadelCount > 0;
        if (!this.thirdSquadUnlocked) {
            if (this.selectedArmyId === 2) this.selectedArmyId = null;
            if (this.lastSelectedArmyId === 2) this.lastSelectedArmyId = null;
        }
        if (prevThird !== this.thirdSquadUnlocked) {
            this.calcLayout();
            this.requestRender();
        }
        this.applyCpBonuses();
    }

    calcItemPrice(type, level) {
        const base = ITEM_VALUES[level] || 1;
        if (type === ITEM_TYPE.ITEM_GOLD) return base * 40;
        if (type === ITEM_TYPE.ITEM_ENERGY) return base * 50;
        if (type === ITEM_TYPE.ITEM_CRYSTAL) return base * 80;
        return base * 50;
    }

    getItemIcon(type) {
        if (type === ITEM_TYPE.ITEM_GOLD) return "üí∞";
        if (type === ITEM_TYPE.ITEM_ENERGY) return "‚ö°";
        if (type === ITEM_TYPE.ITEM_CRYSTAL) return "üíé";
        return "üì¶";
    }

    getAssetSrc(type, level) {
        const img = this.assets.getImage(type, level);
        return img && img.src ? img.src : "";
    }

    placeUnitInSquad(item, squad) {
        for (let i = 0; i < squad.length; i++) {
            if (!squad[i]) { item.scale = 1.3; squad[i] = item; return i; }
        }
        return -1;
    }

    placeUnitPreferred(item) {
        let idx = this.placeUnitInSquad(item, this.squad1);
        if (idx !== -1) return { placed: true, zone: ZONES.SQUAD1, idx };
        idx = this.placeUnitInSquad(item, this.squad2);
        if (idx !== -1) return { placed: true, zone: ZONES.SQUAD2, idx };
        if (this.thirdSquadUnlocked) {
            idx = this.placeUnitInSquad(item, this.squad3);
            if (idx !== -1) return { placed: true, zone: ZONES.SQUAD3, idx };
        }
        if (this.spawnItem(item)) return { placed: true, zone: ZONES.GRID, idx: null };
        return { placed: false };
    }

    calcMercPrice(code) {
        const info = getInfoFromCode(code);
        const stats = UNIT_STATS[code];
        const lv = info.level || 1;
        if (!stats) return lv * 120;
        return Math.max(80, (stats.sell + 1) * 100);
    }

    buildShopCatalog(type) {
        const level = this.getFieldLevel(type);
        if (isShopTile(type)) {
            const codes = Object.keys(ITEM_TABLE).map(n => parseInt(n, 10));
            codes.sort(() => Math.random() - 0.5);
            return codes.slice(0, 3).map(code => {
                const info = getInfoFromCode(code);
                const data = ITEM_TABLE[code];
                return {
                    kind: "item",
                    code,
                    name: data.name_kr || data.name,
                    icon: this.getItemIcon(info.type),
                    type: info.type,
                    level: info.level,
                    earn: data.earn,
                    price: this.calcItemPrice(info.type, info.level)
                };
            });
        }
        if (isTavernTile(type)) {
            const pool = Object.keys(UNIT_STATS).map(n => parseInt(n, 10))
                .filter(code => {
                    const info = getInfoFromCode(code);
                    return info.type >= 10 && info.level <= 5;
                });
            pool.sort(() => Math.random() - 0.5);
            return pool.slice(0, 3).map(code => {
                const info = getInfoFromCode(code);
                const stat = UNIT_STATS[code];
                return {
                    kind: "unit",
                    code,
                    name: stat ? stat.name : `Ïö©Î≥ë Lv.${info.level}`,
                    level: info.level,
                    price: this.calcMercPrice(code)
                };
            });
        }
        return [];
    }

    buyFieldItem(item) {
        if (item.sold) { this.showToast("ÌíàÏ†à"); return; }
        if (this.gold < item.price) { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); return; }
        if (!this.spawnItem({ type: item.type, level: item.level, scale: 0 })) { this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±"); return; }
        this.gold -= item.price;
        this.sound.playCollect();
        this.updateUI();
        this.showToast("Íµ¨Îß§ ÏôÑÎ£å");
        item.sold = true;
        this.refreshShopModal();
    }

    hireMercenary(item) {
        if (item.sold) { this.showToast("ÌíàÏ†à"); return; }
        if (this.gold < item.price) { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); return; }
        const info = getInfoFromCode(item.code);
        const placed = this.placeUnitPreferred({ type: info.type, level: info.level, scale: 0 });
        if (!placed.placed) { this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±"); return; }
        this.gold -= item.price;
        this.sound.playSpawn();
        this.updateUI();
        if (placed.zone === ZONES.SQUAD1 || placed.zone === ZONES.SQUAD2) {
            this.playSquadJoinFx(placed.zone, placed.idx);
        }
        this.showToast("Í≥†Ïö© ÏôÑÎ£å");
        item.sold = true;
        this.refreshShopModal();
    }

    refreshShopModal() {
        if (!this.currentShopContext) return;
        const { type, r, c } = this.currentShopContext;
        const key = `${r},${c}`;
        const state = this.fieldShopState[key];
        if (!state) return;
        if (!document.getElementById('modal-object')?.classList.contains('open')) return;
        const now = Date.now();
        const interval = 3 * 60 * 60 * 1000;
        if (now - state.lastRefresh >= interval) {
            state.lastRefresh = now;
            state.items = this.buildShopCatalog(type);
            state.justRefreshed = true;
            this.fieldShopState[key] = state;
        }
        this.renderShopModal(type, r, c, state);
    }

    openShopOrTavern(type, r, c) {
        const key = `${r},${c}`;
        if (!this.occupiedTiles.has(key)) { this.showToast("Ï†êÎ†π ÌõÑ Ïù¥Ïö© Í∞ÄÎä•"); return; }
        const state = this.fieldShopState[key] || { lastRefresh: Date.now(), items: [] };
        const interval = 3 * 60 * 60 * 1000;
        const now = Date.now();
        if (now - state.lastRefresh >= interval || !state.items || state.items.length === 0) {
            state.lastRefresh = now;
            state.items = this.buildShopCatalog(type);
        }
        this.fieldShopState[key] = state;
        this.currentShopContext = { type, r, c };
        this.renderShopModal(type, r, c, state);
    }

    renderShopModal(type, r, c, state) {
        const interval = 3 * 60 * 60 * 1000;
        const now = Date.now();
        const next = state.lastRefresh + interval;
        const remain = this.formatTimeLeft(next - now);
        const name = isShopTile(type) ? "ÏÉÅÏ†ê" : "Ï£ºÏ†ê";
        const level = this.getFieldLevel(type);

        const modal = document.getElementById('modal-object');
        const t = document.getElementById('object-modal-title');
        const b = document.getElementById('object-modal-body');
        if (!modal || !t || !b) return;
        t.innerText = name;
        b.innerHTML = "";
        modal.querySelector('.modal-content')?.classList.add('wide');

        const header = document.createElement('div');
        header.innerHTML = `<div>${name} Lv.${level}</div><div class="text-gray-400 text-xs">Í∞±Ïã†ÍπåÏßÄ: <span id="shop-refresh-timer">${remain}</span></div>`;
        b.appendChild(header);

        const list = document.createElement('div');
        list.className = "shop-list";

        state.items.forEach(item => {
            const row = document.createElement('div');
            row.className = "shop-card";
            if (state.justRefreshed) row.classList.add('restock');

            if (item.kind === "item") {
                const imgSrc = this.getAssetSrc(item.type, item.level);
                const iconHtml = imgSrc
                    ? `<div class="shop-icon"><img class="shop-icon-img" src="${imgSrc}" alt=""></div>`
                    : `<div class="shop-icon">${item.icon || this.getItemIcon(item.type)}</div>`;
                row.innerHTML = `
                    <div class="shop-row">${iconHtml}<div><div class="name">${item.name} Lv.${item.level}</div><div class="meta">ÌöçÎìùÎüâ +${item.earn}</div></div></div>
                    <button class="price-btn">${item.sold ? "SOLD OUT" : `üí∞ ${item.price}`}</button>
                `;
                const btn = row.querySelector('.price-btn');
                const affordable = this.gold >= item.price;
                if (item.sold || !affordable) row.classList.add('disabled');
                btn.onclick = () => {
                    if (item.sold) { this.showToast("ÌíàÏ†à"); return; }
                    if (!affordable) { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); return; }
                    this.buyFieldItem(item);
                };
            } else {
                const info = getInfoFromCode(item.code);
                const imgSrc = this.getAssetSrc(info.type, info.level);
                const iconHtml = imgSrc
                    ? `<div class="shop-icon"><img class="shop-icon-img" src="${imgSrc}" alt=""></div>`
                    : `<div class="shop-icon">‚öî</div>`;
                row.innerHTML = `
                    <div class="shop-row">${iconHtml}<div><div class="name">${item.name} Lv.${item.level}</div><div class="meta">Ïö©Î≥ë Í≥†Ïö©</div></div></div>
                    <button class="price-btn">${item.sold ? "SOLD OUT" : `üí∞ ${item.price}`}</button>
                `;
                const btn = row.querySelector('.price-btn');
                const affordable = this.gold >= item.price;
                if (item.sold || !affordable) row.classList.add('disabled');
                btn.onclick = () => {
                    if (item.sold) { this.showToast("ÌíàÏ†à"); return; }
                    if (!affordable) { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); return; }
                    this.hireMercenary(item);
                };
            }
            list.appendChild(row);
        });

        state.justRefreshed = false;
        b.appendChild(list);
        modal.classList.add('open');

        if (this.shopTimer) clearInterval(this.shopTimer);
        this.shopTimer = setInterval(() => {
            if (!modal.classList.contains('open')) { clearInterval(this.shopTimer); this.shopTimer = null; return; }
            const el = document.getElementById('shop-refresh-timer');
            if (el) el.innerText = this.formatTimeLeft(next - Date.now());
            this.refreshShopModal();
        }, 1000);
    }

    playSquadJoinFx(zone, idx) {
        if (idx === null || idx === undefined) return;
        const rect = zone === ZONES.SQUAD1 ? this.squad1Rect : (zone === ZONES.SQUAD2 ? this.squad2Rect : this.squad3Rect);
        const size = this.squadCellSize;
        const x = rect.x + (idx % 3) * size + size / 2;
        const y = rect.y + Math.floor(idx / 3) * size + size / 2;
        this.spawnParticles(x, y, "#4ade80", 16, "spark");
        const name = zone === ZONES.SQUAD1 ? "Ï†ú1Î∂ÄÎåÄ Ìï©Î•ò" : (zone === ZONES.SQUAD2 ? "Ï†ú2Î∂ÄÎåÄ Ìï©Î•ò" : "Ï†ú3Î∂ÄÎåÄ Ìï©Î•ò");
        this.showJoinNotice(name);
        this.requestRender();
    }

    getSquadByArmyId(armyId) {
        if (armyId === 0) return this.squad1;
        if (armyId === 1) return this.squad2;
        return this.squad3;
    }

    getAvailableArmies() {
        return this.thirdSquadUnlocked ? this.armies : this.armies.filter(a => a.id !== 2);
    }

    enterMoveTargetMode(armyId, opts = {}) {
        const army = this.armies[armyId];
        if (!army) return;
        if (!this.getAvailableArmies().some(a => a.id === armyId)) { this.showToast("ÏÑ±Ï±Ñ Ï†êÎ†π ÌïÑÏöî"); return; }
        if (army.state !== 'IDLE') { this.showToast("Î∂ÄÎåÄÍ∞Ä Ïù¥Îèô Ï§ëÏûÖÎãàÎã§."); return; }

        const squadData = this.getSquadByArmyId(army.id);
        const stats = this.getSquadStats(squadData);
        if (stats.power < 10) { this.showToast("Î≥ëÎ†•Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); return; }

        const { center = false } = opts;
        this.exitMoveTargetMode();
        this.selectedArmyId = army.id;
        this.lastSelectedArmyId = army.id;
        const times = this.buildMoveTimeMap(army, stats);
        this.moveTargetMode = { armyId: army.id, stats, times };
        this.setMovePreview("ETA ÌëúÏãú Ï§ë (Ï∑®ÏÜå: ÏÉÅÎã® Î©îÏãúÏßÄ ÌÉ≠)");
        if (center) this.centerCameraOnArmy(army.id);
        this.renderMoveTimeOverlay();
    }

    exitMoveTargetMode() {
        if (!this.moveTargetMode) return;
        this.moveTargetMode = null;
        this.clearMoveTimeOverlay();
        this.setMovePreview("");
    }

    buildMoveTimeMap(army, stats) {
        const times = new Map();
        const origin = { r: army.r, c: army.c };
        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const key = `${r},${c}`;
                if (!this.visibilityMap.has(key)) continue;
                if (r === origin.r && c === origin.c) continue;
                const path = AStar.findPath(origin, { r, c }, FIELD_MAP_DATA, this.occupiedTiles);
                if (!path) continue;
                const dist = path.length - 1;
                if (dist <= 0 || dist > stats.range) continue;
                const summary = this.getPathSummary(path, stats.speedFactor);
                times.set(key, { timeMin: summary.finalMin, dist, cpCost: dist * CP_COST_PER_TILE });
            }
        }
        return times;
    }

    clearMoveTimeOverlay() {
        document.querySelectorAll('.field-time').forEach(el => el.remove());
        document.querySelectorAll('.field-move-eligible').forEach(el => el.classList.remove('field-move-eligible'));
        document.querySelectorAll('.field-move-source').forEach(el => el.classList.remove('field-move-source'));
    }

    renderMoveTimeOverlay() {
        this.clearMoveTimeOverlay();
        if (!this.moveTargetMode) return;
        const { times, armyId } = this.moveTargetMode;
        times.forEach((info, key) => {
            const [r, c] = key.split(',').map(Number);
            const cell = document.getElementById(`field-cell-${r}-${c}`);
            if (!cell || cell.classList.contains('field-fog')) return;
            if (info.cpCost > this.cp) return;
            const label = document.createElement('div');
            label.className = 'field-time';
            const tileType = FIELD_MAP_DATA[r][c];
            const isBorderTile = this.occupiedTiles.has(key) || isGateTile(tileType);
            if (isBorderTile) label.classList.add('lower');
            const display = Math.max(1, Math.round(info.timeMin));
            label.innerText = `${display}m`;
            cell.appendChild(label);
            cell.classList.add('field-move-eligible');
        });
        const army = this.armies[armyId];
        if (army) {
            const startCell = document.getElementById(`field-cell-${army.r}-${army.c}`);
            if (startCell) startCell.classList.add('field-move-source');
        }
    }

    handleMoveTargetClick(r, c, type) {
        if (!this.moveTargetMode) return;
        const { armyId, stats, times } = this.moveTargetMode;
        const info = times.get(`${r},${c}`);
        if (!info) { this.showToast("Ïù¥Îèô Î∂àÍ∞Ä"); this.sound.playError(); return; }

        const army = this.armies[armyId];
        if (!army || army.state !== 'IDLE') { this.showToast("Î∂ÄÎåÄÍ∞Ä Ïù¥Îèô Ï§ëÏûÖÎãàÎã§."); return; }

        const path = AStar.findPath({ r: army.r, c: army.c }, { r, c }, FIELD_MAP_DATA, this.occupiedTiles);
        if (!path) { this.showToast("Í∞à Ïàò ÏóÜÏùå"); this.sound.playError(); return; }
        const dist = path.length - 1;
        if (dist > stats.range) { this.showToast(`Í±∞Î¶¨ Ï¥àÍ≥º (${dist}/${stats.range})`); this.sound.playError(); return; }

        let energyCost = 1; let goldCost = 0;
        if (isGateTile(type)) { energyCost = 5; goldCost = 100; }
        const cpCost = dist * CP_COST_PER_TILE;

        if (this.energy < energyCost) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${energyCost})`); return; }
        if (this.gold < goldCost) { this.showToast(`Í≥®Îìú Î∂ÄÏ°± (${goldCost})`); return; }
        if (this.cp < cpCost) { this.showToast(`ÏßÄÌúòÎ†• Î∂ÄÏ°± (${cpCost})`); return; }

        this.exitMoveTargetMode();
        this.selectedArmyId = armyId;
        this.startMarch(armyId, r, c, type, energyCost, goldCost, cpCost, path, stats.speedFactor);
    }

    clearPathPreview() {
        if (!this.previewPath) return;
        this.previewPath.forEach(p => {
            const cell = document.getElementById(`field-cell-${p.r}-${p.c}`);
            if (cell) cell.classList.remove('field-path');
        });
        this.previewPath = null;
        const overlay = this.pathOverlay || document.getElementById('path-overlay');
        if (overlay) overlay.innerHTML = "";
    }

    applyPathPreview(path) {
        this.clearPathPreview();
        if (!path || path.length === 0) return;
        this.previewPath = path;
        path.forEach(p => {
            const cell = document.getElementById(`field-cell-${p.r}-${p.c}`);
            if (cell) cell.classList.add('field-path');
        });
        const overlay = this.pathOverlay || document.getElementById('path-overlay');
        if (!overlay) return;
        const points = path.map(p => `${50 + (p.c * 13) + 6.5},${50 + (p.r * 13) + 6.5}`).join(' ');
        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        bg.setAttribute('points', points);
        bg.setAttribute('class', 'path-line-bg');
        overlay.appendChild(bg);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        line.setAttribute('points', points);
        line.setAttribute('class', 'path-line');
        overlay.appendChild(line);
    }

    getFieldObjectInfo(type, r, c) {
        if (isTerrainCode(type)) {
            return { name: getTerrainName(type), level: "-", owner: "-", defenders: [] };
        }
        let name = "Ïïå Ïàò ÏóÜÏùå";
        let level = 1;
        let defenders = [];
        const data = this.getFieldObjectData(type);
        const overlay = data ? null : getInfoFromCode(type);
        if (data) {
            name = data.name || name;
            level = data.level || level;
            defenders = data.defenders || [];
        } else if (overlay) {
            const base = getData(overlay.type, overlay.level);
            if (base && base.name) {
                name = base.name;
                level = overlay.level ?? level;
            }
        } else if (isCastleTile(type)) { name = "ÏÑ±"; level = 1; }
        else if (isGateTile(type)) { name = "Í¥ÄÎ¨∏"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isCitadelTile(type)) { name = "ÏÑ±Ï±Ñ"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level + 1)] || FIELD_DEFENDERS[2]; }
        else if (isDragonTile(type)) { name = "Ïö©"; level = 1; }
        else if (isGoldMineTile(type)) { name = "Í∏àÍ¥ë"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isFountainTile(type)) { name = "ÏóêÎÑàÏßÄ Î∂ÑÏàò"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isShopTile(type)) { name = "ÏÉÅÏ†ê"; level = 1; defenders = FIELD_DEFENDERS[1]; }
        else if (isTavernTile(type)) { name = "Ï£ºÏ†ê"; level = 1; defenders = FIELD_DEFENDERS[1]; }
        else if (isRuinsTile(type)) { name = "Ïú†Ï†Å"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isStatueTile(type)) { name = "ÏÑùÏÉÅ"; level = getObjectLevelFromCode(type); }
        else if (type === 4) { name = "Í∏∏"; level = "-"; }

        const owner = this.occupiedTiles.has(`${r},${c}`) ? "Ï†êÎ†π" : "-";
        return { name, level, owner, defenders };
    }



    formatDefenders(defenders) {
        if (!defenders || defenders.length === 0) return "-";
        return defenders.map(d => {
            const stat = UNIT_STATS[d.code];
            const nm = stat ? stat.name : d.code;
            return `${nm} x${d.count}`;
        }).join(" / ");
    }

    getCaptureEffectToast(type) {
        if (isGateTile(type)) return "Í¥ÄÎ¨∏ ÎèåÌåå: Ïù¥ÎèôÎ°ú Í∞úÎ∞©";
        if (isCitadelTile(type)) return "ÏÑ±Ï±Ñ Ìö®Í≥º: Ï∂îÍ∞Ä Ïä§ÏøºÎìú +1";
        if (isRuinsTile(type)) {
            const bonus = this.getRuinsBonus(type);
            if (bonus) return `Ïú†Ï†Å Ìö®Í≥º: ÏßÄÌúòÎ†• +${bonus.cpCap}, Î¶¨Ï†† +${bonus.cpRegen}/5Î∂Ñ`;
        }
        if (isStatueTile(type)) {
            const buff = this.getStatueBuff(type);
            if (buff) {
                const label = buff.kind === "atk" ? "Í≥µÍ≤©" : (buff.kind === "def" ? "Î∞©Ïñ¥" : (buff.kind === "hp" ? "Ï≤¥Î†•" : "ÏÜçÎèÑ"));
                return `${label} ÏÑùÏÉÅ Ìö®Í≥º: +${this.formatPercent(buff.value)}`;
            }
        }
        return "";
    }

    setFieldInfo(type, r, c) {
        const panel = document.getElementById('field-info-panel');
        if (!panel) return;
        if (type === null || type === undefined) {
            panel.classList.remove('open');
            panel.innerHTML = `<div class="field-info-title">ÏÑ†ÌÉù ÏóÜÏùå</div><div class="field-info-small">ÌïÑÎìú Ïò§Î∏åÏ†ùÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>`;
            const wrap = document.getElementById('field-floating-wrap');
            if (wrap) wrap.style.display = 'none';
            const prev = document.querySelector('.field-selected');
            if (prev) prev.classList.remove('field-selected');
            this.currentFieldTargetKey = null;
            this.currentFieldTargetType = null;
            return;
        }
        panel.classList.add('open');
        const targetKey = `${r},${c}`;
        const isNewTarget = this.currentFieldTargetKey !== targetKey || this.currentFieldTargetType !== type;
        this.currentFieldTargetKey = targetKey;
        this.currentFieldTargetType = type;
        if (isNewTarget) {
            const prev = document.querySelector('.field-selected');
            if (prev) prev.classList.remove('field-selected');
            const cell = document.getElementById(`field-cell-${r}-${c}`);
            if (cell) cell.classList.add('field-selected');
        }
        const info = this.getFieldObjectInfo(type, r, c);
        let extraRows = "";
        if (isGoldMineTile(type) || isFountainTile(type)) {
            const res = this.getFieldResourceState(type, r, c);
            if (res) {
                const kind = isGoldMineTile(type) ? "Í≥®Îìú" : "ÏóêÎÑàÏßÄ";
                extraRows += `<div class="field-info-row"><span>ÎàÑÏ†Å ${kind}</span><span>${res.state.stored}/${res.cfg.cap}</span></div>`;
                extraRows += `<div class="field-info-row"><span>Î¶¨Ï††</span><span>5Î∂ÑÎãπ ${res.cfg.regen5}</span></div>`;
                const ratio = res.cfg.cap > 0 ? Math.min(100, Math.round((res.state.stored / res.cfg.cap) * 100)) : 0;
                const barColor = isGoldMineTile(type) ? "#fbbf24" : "#38bdf8";
                extraRows += `<div class="field-info-bar"><div class="field-info-bar-fill" style="width:${ratio}%;background:${barColor};"></div></div>`;
            }
        }
        let effectRows = "";
        if (isGateTile(type)) {
            effectRows += `<div class="field-info-row"><span>Ìö®Í≥º</span><span>ÌÜµÎ°ú Í∞úÎ∞©</span></div>`;
        }
        if (isCitadelTile(type)) {
            effectRows += `<div class="field-info-row"><span>Ìö®Í≥º</span><span>Ï∂îÍ∞Ä Ïä§ÏøºÎìú +1</span></div>`;
        }
        if (isRuinsTile(type)) {
            const bonus = this.getRuinsBonus(type);
            if (bonus) {
                effectRows += `<div class="field-info-row"><span>ÏßÄÌúòÎ†• ÏµúÎåÄ</span><span>+${bonus.cpCap}</span></div>`;
                effectRows += `<div class="field-info-row"><span>ÏßÄÌúòÎ†• Î¶¨Ï††</span><span>5Î∂ÑÎãπ +${bonus.cpRegen}</span></div>`;
            }
        }
        if (isStatueTile(type)) {
            const buff = this.getStatueBuff(type);
            if (buff) {
                const label = buff.kind === "atk" ? "Í≥µÍ≤©" : (buff.kind === "def" ? "Î∞©Ïñ¥" : (buff.kind === "hp" ? "Ï≤¥Î†•" : "ÏÜçÎèÑ"));
                effectRows += `<div class="field-info-row"><span>${label} Î≤ÑÌîÑ</span><span>+${this.formatPercent(buff.value)}</span></div>`;
            }
        }
        const upkeep = this.getUpkeepCost(type);
        if (upkeep > 0) {
            effectRows += `<div class="field-info-row"><span>Ïú†ÏßÄÎπÑ</span><span>-${upkeep}/3Ï¥à</span></div>`;
        }
        panel.innerHTML = `
            <div class="field-info-title">${info.name}${info.level !== "-" ? ` Lv.${info.level}` : ""}</div>
            <div class="field-info-row"><span>ÏÜåÏú†Ïûê</span><span>${info.owner}</span></div>
            <div class="field-info-row"><span>ÏàòÎπÑÎ≥ë</span><span>${this.formatDefenders(info.defenders)}</span></div>
            ${extraRows}
            ${effectRows}
            <div class="field-info-small">Ï¢åÌëú: ${r},${c}</div>
            <div id="field-move-options" class="field-move-options"></div>
        `;
        this.renderFieldMoveOptions(panel, r, c, type, isNewTarget);
        this.updateFloatingPanelPosition(r, c);
    }

    updateFloatingPanelPosition(r, c) {
        const wrap = document.getElementById('field-floating-wrap');
        if (!wrap) return;
        if (typeof r !== "number" || typeof c !== "number") {
            wrap.style.display = 'none';
            return;
        }
        wrap.style.display = 'flex';
    }

    updateFloatingPanelPositionFromSelection() {
        if (!this.currentFieldTargetKey) {
            this.updateFloatingPanelPosition();
            return;
        }
        const parts = this.currentFieldTargetKey.split(',');
        if (parts.length < 2) return;
        const r = Number(parts[0]);
        const c = Number(parts[1]);
        if (Number.isNaN(r) || Number.isNaN(c)) return;
        this.updateFloatingPanelPosition(r, c);
    }

    getArmyMoveInfo(army, targetR, targetC) {
        const squadData = this.getSquadByArmyId(army.id);
        const stats = this.getSquadStats(squadData);
        if (stats.power < 10) return { armyId: army.id, canMove: false, reason: "Î≥ëÎ†• Î∂ÄÏ°±", stats };
        if (army.state !== 'IDLE') return { armyId: army.id, canMove: false, reason: "Ïù¥ÎèôÏ§ë", stats };

        const path = AStar.findPath({ r: army.r, c: army.c }, { r: targetR, c: targetC }, FIELD_MAP_DATA, this.occupiedTiles);
        if (!path) return { armyId: army.id, canMove: false, reason: "Í∞à Ïàò ÏóÜÏùå", stats };

        const dist = path.length - 1;
        const cpCost = dist * CP_COST_PER_TILE;
        const summary = this.getPathSummary(path, stats.speedFactor);
        const timeMin = summary ? summary.finalMin : 0;

        if (dist > stats.range) return { armyId: army.id, canMove: false, reason: `Í±∞Î¶¨ ${dist}/${stats.range}`, dist, cpCost, timeMin, stats };
        if (this.cp < cpCost) return { armyId: army.id, canMove: false, reason: `CP ${cpCost}`, dist, cpCost, timeMin, stats };

        return { armyId: army.id, canMove: true, dist, cpCost, timeMin, stats };
    }

    renderFieldMoveOptions(panel, r, c, type, isNewTarget) {
        const wrap = panel.querySelector('#field-move-options');
        if (!wrap) return;
        wrap.innerHTML = "";

        const title = document.createElement('div');
        title.className = 'field-info-small';
        title.innerText = "Î∂ÄÎåÄ Ïù¥Îèô ETA";
        wrap.appendChild(title);

        const infos = this.getAvailableArmies().map(army => this.getArmyMoveInfo(army, r, c, type));

        if (isNewTarget) {
            let preferred = this.lastSelectedArmyId;
            const preferredInfo = infos.find(i => i.armyId === preferred);
            if (!preferredInfo || !preferredInfo.canMove) preferred = null;
            if (preferred === null || preferred === undefined) {
                const viable = infos.filter(i => i.canMove);
                if (viable.length > 0) {
                    viable.sort((a, b) => a.timeMin - b.timeMin || a.cpCost - b.cpCost);
                    preferred = viable[0].armyId;
                }
            }
            if (preferred !== null && preferred !== undefined) {
                this.selectedArmyId = preferred;
                this.lastSelectedArmyId = preferred;
                this.enterMoveTargetMode(preferred, { center: false });
            }
        }

        let summaryInfo = null;
        const summaryId = (this.selectedArmyId !== null && this.selectedArmyId !== undefined)
            ? this.selectedArmyId
            : this.lastSelectedArmyId;
        if (summaryId !== null && summaryId !== undefined) {
            summaryInfo = infos.find(i => i.armyId === summaryId && i.canMove);
        }
        if (!summaryInfo) summaryInfo = infos.find(i => i.canMove);
        const summaryRow = document.createElement('div');
        summaryRow.className = 'field-info-row';
        if (summaryInfo) {
            const etaMin = Math.max(1, Math.round(summaryInfo.timeMin));
            summaryRow.innerHTML = `<span>ETA</span><span>S${summaryInfo.armyId + 1} ${etaMin}m / CP ${summaryInfo.cpCost}</span>`;
        } else {
            summaryRow.innerHTML = `<span>ETA</span><span>-</span>`;
        }
        wrap.appendChild(summaryRow);

        infos.forEach(info => {
            const btn = document.createElement('button');
            btn.className = 'field-eta-btn';
            if (info.armyId === this.selectedArmyId) btn.classList.add('active');
            if (!info.canMove) btn.classList.add('disabled');

            const etaText = info.canMove
                ? `${Math.max(1, Math.round(info.timeMin))}m / CP ${info.cpCost}`
                : `Î∂àÍ∞Ä ¬∑ ${info.reason}`;
            btn.innerText = `S${info.armyId + 1} ${etaText}`;

            btn.onclick = (e) => {
                e.stopPropagation();
                if (!info.canMove) { this.showToast(info.reason); return; }
                this.selectedArmyId = info.armyId;
                this.lastSelectedArmyId = info.armyId;
                this.enterMoveTargetMode(info.armyId, { center: false });
                wrap.querySelectorAll('.field-eta-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };

            wrap.appendChild(btn);
        });
    }

    applyFieldBuffsToStats(stats) {
        if (!stats) return stats;
        const buffs = this.fieldBuffs || { atk: 0, def: 0, hp: 0, spd: 0 };
        return {
            ...stats,
            hp: stats.hp ? Math.round(stats.hp * (1 + buffs.hp)) : stats.hp,
            atk: stats.atk ? Math.round(stats.atk * (1 + buffs.atk)) : stats.atk,
            def: stats.def ? Math.round(stats.def * (1 + buffs.def)) : stats.def,
            spd: stats.spd ? Math.round(stats.spd * (1 + buffs.spd)) : stats.spd
        };
    }

    getSquadInfo(squadData) {
        let count = 0, totalLevel = 0, power = 0;
        let totalHp = 0, totalAtk = 0, totalDef = 0;
        let totalSpd = 0, totalRng = 0;
        let minMov = 99, maxMov = 0;
        const units = [];
        squadData.forEach(u => {
            if (!u) return;
            count++;
            totalLevel += u.level;
            const base = getData(u.type, u.level);
            const data = this.applyFieldBuffsToStats(base);
            if (data && data.hp) {
                power += data.hp + data.atk + data.def;
                totalHp += data.hp; totalAtk += data.atk; totalDef += data.def;
            }
            if (data && data.spd) totalSpd += data.spd;
            if (data && data.rng) totalRng += data.rng;
            if (base && base.mov) { minMov = Math.min(minMov, base.mov); maxMov = Math.max(maxMov, base.mov); }
            units.push({
                name: base.name, level: u.level,
                hp: data?.hp || 0, atk: data?.atk || 0, def: data?.def || 0,
                spd: data?.spd || 0, rng: data?.rng || 0, mov: base?.mov || 0
            });
        });
        if (minMov === 99) minMov = 0;
        const avgSpd = count ? (totalSpd / count) : 0;
        const avgRng = count ? (totalRng / count) : 0;
        return { count, totalLevel, power, totalHp, totalAtk, totalDef, avgSpd, avgRng, minMov, maxMov, units };
    }

    setSquadInfoPanel(army) {
        const panel = document.getElementById('field-info-panel');
        if (!panel) return;
        const squadData = this.getSquadByArmyId(army.id);
        const info = this.getSquadInfo(squadData);
        const stats = this.getSquadStats(squadData);
        const moveText = info.minMov ? `${info.minMov}~${info.maxMov}` : "-";
        const avgSpd = info.avgSpd ? info.avgSpd.toFixed(1) : "0.0";
        const avgRng = info.avgRng ? info.avgRng.toFixed(1) : "0.0";
        const speedFactorText = `x${stats.speedFactor.toFixed(2)}`;
        const buffParts = [];
        if (this.fieldBuffs?.atk) buffParts.push(`ATK +${this.formatPercent(this.fieldBuffs.atk)}`);
        if (this.fieldBuffs?.def) buffParts.push(`DEF +${this.formatPercent(this.fieldBuffs.def)}`);
        if (this.fieldBuffs?.hp) buffParts.push(`HP +${this.formatPercent(this.fieldBuffs.hp)}`);
        if (this.fieldBuffs?.spd) buffParts.push(`SPD +${this.formatPercent(this.fieldBuffs.spd)}`);
        const buffText = buffParts.length ? buffParts.join(" / ") : "-";
        const unitHtml = info.units.length
            ? info.units.map(u => `<div>${u.name} Lv.${u.level} ¬∑ HP ${u.hp} ATK ${u.atk} DEF ${u.def} SPD ${u.spd} RNG ${u.rng} MOV ${u.mov}</div>`).join("")
            : "<div>ÏóÜÏùå</div>";
        panel.innerHTML = `
            <div class="field-info-title">${army.name} Ï†ïÎ≥¥</div>
            <div class="field-info-row"><span>Î©§Î≤Ñ</span><span>${info.count}/9</span></div>
            <div class="field-info-row"><span>Ï¥ù Î†àÎ≤®</span><span>${info.totalLevel}</span></div>
            <div class="field-info-row"><span>Ï†ÑÌà¨Î†•</span><span>${info.power}</span></div>
            <div class="field-info-row"><span>Ï¥ù HP/ATK/DEF</span><span>${info.totalHp}/${info.totalAtk}/${info.totalDef}</span></div>
            <div class="field-info-row"><span>ÌèâÍ∑† ÏÜçÎèÑ/ÏÇ¨Í±∞Î¶¨</span><span>${avgSpd}/${avgRng}</span></div>
            <div class="field-info-row"><span>Ïù¥ÎèôÎ†•(ÏµúÏÜå~ÏµúÎåÄ)</span><span>${moveText}</span></div>
            <div class="field-info-row"><span>Ïù¥Îèô Î≤îÏúÑ</span><span>${stats.range}</span></div>
            <div class="field-info-row"><span>ÏÜçÎèÑ Î≥¥Ï†ï</span><span>${speedFactorText}</span></div>
            <div class="field-info-row"><span>ÌïÑÎìú Î≤ÑÌîÑ</span><span>${buffText}</span></div>
            <div class="field-info-small">${unitHtml}</div>
        `;
    }

    hideFieldActionMenu() {
        const menu = document.getElementById('field-action-menu');
        if (menu) menu.remove();
    }

    showFieldActionMenu(r, c, type, clientX, clientY) {
        this.hideFieldActionMenu();
        const viewport = document.getElementById('map-viewport');
        if (!viewport) return;

        const menu = document.createElement('div');
        menu.id = 'field-action-menu';
        menu.className = 'field-action-menu';

        const moveBtn = document.createElement('button');
        moveBtn.className = 'field-action-btn';
        moveBtn.innerText = 'Î∂ÄÎåÄ Ïù¥Îèô';
        moveBtn.onclick = (e) => {
            e.stopPropagation();
            this.hideFieldActionMenu();
            if (this.selectedArmyId !== null) {
                this.exitMoveTargetMode();
                this.commandArmy(this.selectedArmyId, r, c, type);
            } else {
                this.openSquadSelector(r, c, type, false);
            }
        };

        const infoBtn = document.createElement('button');
        infoBtn.className = 'field-action-btn';
        infoBtn.innerText = 'Î∂ÄÎåÄ Ï†ïÎ≥¥';
        infoBtn.onclick = (e) => {
            e.stopPropagation();
            this.hideFieldActionMenu();
            this.openSquadSelector(r, c, type, true);
        };

        menu.appendChild(moveBtn);
        menu.appendChild(infoBtn);

        const key = `${r},${c}`;
        if (isGoldMineTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = 'Í≥®Îìú ÏàòÎ†π';
            btn.onclick = (e) => { e.stopPropagation(); this.collectFieldResource(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        if (isFountainTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = 'ÏóêÎÑàÏßÄ ÏàòÎ†π';
            btn.onclick = (e) => { e.stopPropagation(); this.collectFieldResource(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        if (isShopTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = 'ÏÉÅÏ†ê Ïù¥Ïö©';
            btn.onclick = (e) => { e.stopPropagation(); this.openShopOrTavern(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        if (isTavernTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = 'Ï£ºÏ†ê Ïù¥Ïö©';
            btn.onclick = (e) => { e.stopPropagation(); this.openShopOrTavern(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        viewport.appendChild(menu);

        const rect = viewport.getBoundingClientRect();
        let x = clientX - rect.left;
        let y = clientY - rect.top;
        const menuW = 110, menuH = 80;
        const clampPos = (pos) => ({
            x: Math.min(rect.width - menuW - 8, Math.max(8, pos.x)),
            y: Math.min(rect.height - menuH - 8, Math.max(8, pos.y))
        });

        const candidates = [
            { x: x + 8, y: y - 8 },
            { x: x - menuW - 8, y: y - 8 },
            { x: x - menuW / 2, y: y + 10 },
            { x: x - menuW / 2, y: y - menuH - 10 }
        ];

        let finalPos = clampPos(candidates[0]);
        const wrap = document.getElementById('field-floating-wrap');
        if (wrap && wrap.style.display !== 'none') {
            const wrapRect = wrap.getBoundingClientRect();
            const wr = {
                left: wrapRect.left - rect.left,
                top: wrapRect.top - rect.top,
                right: wrapRect.right - rect.left,
                bottom: wrapRect.bottom - rect.top
            };
            const intersects = (a, b) => a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
            for (const cand of candidates) {
                const pos = clampPos(cand);
                const mr = { left: pos.x, top: pos.y, right: pos.x + menuW, bottom: pos.y + menuH };
                if (!intersects(mr, wr)) { finalPos = pos; break; }
            }
        }

        menu.style.left = `${finalPos.x}px`;
        menu.style.top = `${finalPos.y}px`;
    }

    renderFieldMap() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        modal.dataset.mode = 'field'; modal.classList.add('open'); title.innerText = "ÏõîÎìú Îßµ (Field)"; content.innerHTML = ""; content.style.overflow = "hidden";
        content.style.position = "relative";
        content.style.display = "block";
        content.style.height = "100%";
        
        if (this.selectedArmyId !== null) {
            const existingHud = document.querySelector('.selected-army-hud');
            if (existingHud) existingHud.remove();
            
            const armyName = this.armies[this.selectedArmyId].name;
            const hud = document.createElement('div');
            hud.className = 'selected-army-hud';
            hud.innerHTML = `<span class="hud-name">${armyName} ÏÑ†ÌÉùÎê®</span><button class="hud-btn" onclick="game.deselectArmy()">ÏÑ†ÌÉù Ìï¥Ï†ú</button>`;
            content.appendChild(hud);
        }

        const viewport = document.createElement('div'); viewport.id = 'map-viewport'; viewport.style.position = 'absolute'; viewport.style.inset = '0'; viewport.style.width = '100%'; viewport.style.height = '100%'; viewport.style.overflow = 'hidden';
        viewport.style.backgroundColor = '#2e3b23';
        viewport.style.touchAction = 'none';
        viewport.onclick = (e) => { if (e.target === viewport) this.hideFieldActionMenu(); };
        content.appendChild(viewport);

        const overlay = document.createElement('div');
        overlay.className = 'field-overlay';

        const headerDiv = document.createElement('div'); headerDiv.className = "flex justify-between items-center bg-gray-700 px-2 py-1 rounded text-[11px] shadow-md";
        const incomeSign = this.income >= 0 ? "+" : "";
        headerDiv.innerHTML = `<div>Ï†êÎ†π: <span class="text-white font-bold">${this.occupiedTiles.size}</span></div><div>ÏÑ∏Í∏à: <span class="text-yellow-400 font-bold">${incomeSign}${this.income}/3sec</span></div><div>CP: <span id="field-cp-display" class="text-white font-bold">${this.cp}/${this.maxCp}</span></div>`;
        overlay.appendChild(headerDiv);

        const floatingWrap = document.createElement('div');
        floatingWrap.id = 'field-floating-wrap';
        floatingWrap.className = 'field-floating-wrap';

        const moveInfo = document.createElement('div'); moveInfo.id = 'field-move-info'; moveInfo.className = 'field-move-info';
        moveInfo.style.display = 'none';
        moveInfo.onclick = () => { if (this.moveTargetMode) this.exitMoveTargetMode(); };
        floatingWrap.appendChild(moveInfo);

        const infoPanel = document.createElement('div'); infoPanel.id = 'field-info-panel'; infoPanel.className = 'field-info-panel';
        floatingWrap.appendChild(infoPanel);

        overlay.appendChild(floatingWrap);
        content.appendChild(overlay);

        const mapLayer = document.createElement('div'); mapLayer.id = 'map-layer'; mapLayer.style.position = 'absolute'; mapLayer.style.transformOrigin = '0 0'; mapLayer.style.display = 'grid'; mapLayer.style.gridTemplateColumns = `repeat(${MAP_SIZE}, 12px)`; mapLayer.style.gap = '1px'; mapLayer.style.padding = '50px';
        const mapSizePx = (MAP_SIZE * 13 - 1) + 100;
        const pathOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        pathOverlay.setAttribute('id', 'path-overlay');
        pathOverlay.setAttribute('width', mapSizePx);
        pathOverlay.setAttribute('height', mapSizePx);
        pathOverlay.setAttribute('viewBox', `0 0 ${mapSizePx} ${mapSizePx}`);
        mapLayer.appendChild(pathOverlay);
        this.pathOverlay = pathOverlay;
        
        const bgImg = this.assets.getImage('field_bg');
        if(bgImg && bgImg.src) {
             mapLayer.style.backgroundImage = `url(${bgImg.src})`;
        } else {
             mapLayer.style.backgroundImage = `url(${this.grassTexture})`;
        }
        mapLayer.style.backgroundRepeat = 'repeat';

        const armyLayer = document.createElement('div'); armyLayer.id = 'army-layer'; armyLayer.style.position = 'absolute'; armyLayer.style.top = '0'; armyLayer.style.left = '0'; armyLayer.style.width = '100%'; armyLayer.style.height = '100%'; armyLayer.style.pointerEvents = 'none'; armyLayer.style.zIndex = '50'; mapLayer.appendChild(armyLayer);

        this.getAvailableArmies().forEach(army => {
            const marker = document.createElement('div'); 
            marker.className = 'army-marker'; 
            if (this.selectedArmyId === army.id) marker.classList.add('selected');
            marker.id = `army-marker-${army.id}`; 
            
            const squadData = this.getSquadByArmyId(army.id);
            let maxLevel = -1;
            let bestUnit = null;
            
            squadData.forEach(u => {
                if (u && u.level > maxLevel) {
                    maxLevel = u.level;
                    bestUnit = u;
                }
            });
            
            if (bestUnit) {
                const img = this.assets.getImage(bestUnit.type, bestUnit.level);
                if (img && img.src) {
                    marker.style.backgroundImage = `url(${img.src})`;
                    marker.innerText = "";
                } else {
                     marker.style.backgroundColor = army.color; 
                     marker.innerText = army.id + 1;
                }
            } else {
                 marker.style.backgroundColor = army.color; 
                 marker.innerText = army.id + 1;
            }

            const TILE_SIZE = 13, x = 50 + (army.c * TILE_SIZE), y = 50 + (army.r * TILE_SIZE); marker.style.transform = `translate(${x}px, ${y}px)`; armyLayer.appendChild(marker);
        });

        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const cell = document.createElement('div'); cell.className = 'field-cell'; cell.id = `field-cell-${r}-${c}`;
                const type = FIELD_MAP_DATA[r][c], key = `${r},${c}`, isOccupied = this.occupiedTiles.has(key), isVisible = this.visibilityMap.has(key);
                let isAdjacent = false; const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                if (!isOccupied) { for (let d of dirs) { const nr = r + d[0], nc = c + d[1]; if (this.occupiedTiles.has(`${nr},${nc}`)) { isAdjacent = true; break; } } }
                
                if (!isVisible) { 
                    cell.classList.add('field-fog'); 
                    mapLayer.appendChild(cell);
                    continue;
                }

                let color = 'rgba(0, 0, 0, 0)';
                if (isCastleTile(type)) { color = '#4285f4'; cell.classList.add('field-castle'); }
                else if (isGateTile(type)) { color = '#ea4335'; cell.classList.add('field-gate'); if(isOccupied) cell.classList.add('unlocked'); else cell.classList.add('locked'); }
                else if (isCitadelTile(type)) { color = '#fbbc05'; cell.classList.add('field-citadel'); }
                else if (isDragonTile(type)) { color = '#b71c1c'; cell.classList.add('field-dragon'); }
                else if (isGoldMineTile(type)) { color = '#6d4c41'; cell.classList.add('field-goldmine'); }
                else if (isFountainTile(type)) { color = '#0ea5e9'; cell.classList.add('field-fountain'); }
                else if (isShopTile(type)) { color = '#2563eb'; cell.classList.add('field-shop'); }
                else if (isTavernTile(type)) { color = '#7c3aed'; cell.classList.add('field-tavern'); }
                else if (isRuinsTile(type)) { color = '#9ca3af'; cell.classList.add('field-ruins'); }
                else if (isStatueTile(type)) { color = '#94a3b8'; cell.classList.add('field-statue'); }
                else if (isTerrainCode(type)) {
                    const base = getTerrainBase(type);
                    const isBorder = type % 100 === 1;
                    color = (isBorder ? TERRAIN_COLORS_BORDER[base] : TERRAIN_COLORS[base]) || '#2e3b23';
                } else if (type === 4) { color = 'rgba(139, 69, 19, 0.4)'; }
                else {
                    const base = FIELD_TERRAIN_DATA?.[r]?.[c];
                    if (isTerrainCode(base)) {
                        const baseType = getTerrainBase(base);
                        const isBorder = base % 100 === 1;
                        color = (isBorder ? TERRAIN_COLORS_BORDER[baseType] : TERRAIN_COLORS[baseType]) || '#2e3b23';
                    } else {
                        color = 'transparent';
                    }
                }
                
                cell.style.backgroundColor = color;

                const isKnownObject = isCastleTile(type) || isGateTile(type) || isCitadelTile(type) || isDragonTile(type)
                    || isGoldMineTile(type) || isFountainTile(type) || isShopTile(type) || isTavernTile(type)
                    || isRuinsTile(type) || isStatueTile(type);
                if (!isTerrainCode(type) && !isKnownObject) {
                    const icon = this.assets.getImage(String(type));
                    if (icon && icon.src) {
                        cell.style.backgroundImage = `url(${icon.src})`;
                        cell.style.backgroundSize = 'contain';
                        cell.style.backgroundRepeat = 'no-repeat';
                        cell.style.backgroundPosition = 'center';
                    }
                }

                if (isOccupied) {
                    cell.classList.add('field-occupied');
                    cell.style.opacity = 1.0;
                } else if (isAdjacent) { 
                    cell.classList.add('field-adjacent'); 
                    cell.style.opacity = 0.6;
                } else {
                    cell.style.opacity = 1.0;
                }

                if (this.currentFieldTargetKey === key) cell.classList.add('field-selected');

                // Additional marker classes handled above

                cell.onclick = (e) => {
                    e.stopPropagation();
                    if(!this.isDraggingMap) {
                        this.setFieldInfo(type, r, c);
                        this.showFieldActionMenu(r, c, type, e.clientX, e.clientY);
                    }
                };

                mapLayer.appendChild(cell);
            }
        }
        viewport.appendChild(mapLayer);
        this.setMovePreview(this.movePreviewText);
        if (this.currentFieldTargetKey) {
            const [tr, tc] = this.currentFieldTargetKey.split(',').map(Number);
            if (!Number.isNaN(tr) && !Number.isNaN(tc) && FIELD_MAP_DATA?.[tr]?.[tc] !== undefined) {
                this.setFieldInfo(FIELD_MAP_DATA[tr][tc], tr, tc);
            } else {
                this.setFieldInfo(null);
            }
        } else {
            this.setFieldInfo(null);
        }
        if (this.previewPath) this.applyPathPreview(this.previewPath);
        if (this.moveTargetMode) this.renderMoveTimeOverlay();
        this.initFieldCamera(viewport, mapLayer);
    }
    
    deselectArmy() {
        this.selectedArmyId = null;
        this.exitMoveTargetMode();
        this.renderFieldMap();
    }

    commandArmy(armyId, targetR, targetC, tileType) {
        const army = this.armies[armyId];
        if (army.state !== 'IDLE') { this.showToast("Î∂ÄÎåÄÍ∞Ä Ïù¥Îèô Ï§ëÏûÖÎãàÎã§."); return; }
        this.lastSelectedArmyId = armyId;
        
        let energyCost = 1; let goldCost = 0;
        if (isGateTile(tileType)) { energyCost = 5; goldCost = 100; }
        
        const squadData = this.getSquadByArmyId(army.id);
        const stats = this.getSquadStats(squadData);
        
        if (stats.power < 10) { this.showToast("Î≥ëÎ†•Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); return; }

        const path = AStar.findPath({r: army.r, c: army.c}, {r: targetR, c: targetC}, FIELD_MAP_DATA, this.occupiedTiles);
        
        if (!path) { this.showToast("Í∞à Ïàò ÏóÜÎäî ÏßÄÏó≠ÏûÖÎãàÎã§."); return; }
        const dist = path.length - 1;
        if (dist > stats.range) { this.showToast(`Í±∞Î¶¨ Ï¥àÍ≥º (${dist}/${stats.range})`); return; }
        const cpCost = dist * CP_COST_PER_TILE;
        if (this.cp < cpCost) { this.showToast(`ÏßÄÌúòÎ†• Î∂ÄÏ°± (${cpCost})`); return; }

        this.startMarch(armyId, targetR, targetC, tileType, energyCost, goldCost, cpCost, path, stats.speedFactor);
    }

    getSquadStats(squadData) {
        let count = 0, totalMov = 0, minMov = 99;
        squadData.forEach(u => {
            if(u) {
                count++;
                const stats = getData(u.type, u.level);
                if(stats.mov) {
                    totalMov += stats.mov;
                    minMov = Math.min(minMov, stats.mov);
                }
            }
        });
        if(count === 0) return { power: 0, range: 0, speedFactor: 1 };
        
        const baseRange = 4;
        const range = baseRange + (minMov * 2);
        const baseSpeedFactor = Math.max(0.5, 1 - (minMov - 1) * 0.2);
        const spdBuff = this.fieldBuffs?.spd || 0;
        const speedFactor = Math.max(0.3, baseSpeedFactor * (1 - spdBuff));
        
        return { power: this.getSquadPower(squadData), range, speedFactor };
    }

    getHighestBuildingLevel(unitType) {
        let buildingType = -1;
        if (unitType === ITEM_TYPE.UNIT_INFANTRY) buildingType = ITEM_TYPE.BUILDING_BARRACKS;
        else if (unitType === ITEM_TYPE.UNIT_ARCHER) buildingType = ITEM_TYPE.BUILDING_RANGE;
        else if (unitType === ITEM_TYPE.UNIT_CAVALRY) buildingType = ITEM_TYPE.BUILDING_STABLE;

        if (buildingType === -1) return 10;

        let maxLvl = 0;
        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                const item = this.grid[r][c];
                if (item && item.type === buildingType) {
                    maxLvl = Math.max(maxLvl, item.level);
                }
            }
        }
        return maxLvl || 1;
    }

    openMoveSquadSelector() {
        const existing = document.querySelector('.squad-selector'); if(existing) existing.remove();
        this.hideFieldActionMenu();
        this.exitMoveTargetMode();
        const viewport = document.getElementById('map-viewport');
        if (!viewport) return;
        const selector = document.createElement('div'); selector.className = 'squad-selector';
        this.setMovePreview("Ïù¥ÎèôÌï† Î∂ÄÎåÄÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.");

        this.getAvailableArmies().forEach(army => {
            const card = document.createElement('div'); card.className = 'squad-card';
            const isIdle = army.state === 'IDLE';
            const squadData = this.getSquadByArmyId(army.id);
            const stats = this.getSquadStats(squadData);

            let statusHtml = "";
            if (!isIdle) statusHtml = `<div class="squad-status">Ïù¥ÎèôÏ§ë...</div>`;
            else if (stats.power < 10) statusHtml = `<div class="squad-status text-red-400">Î≥ëÎ†• Î∂ÄÏ°±</div>`;
            else statusHtml = `<div class="squad-status text-green-400">Ïù¥Îèô Î≤îÏúÑ ${stats.range}</div>`;

            if (!isIdle || stats.power < 10) card.classList.add('disabled');
            card.innerHTML = `<div class="font-bold text-white">${army.name}</div>${statusHtml}`;

            if (!card.classList.contains('disabled')) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    this.selectedArmyId = army.id;
                    selector.remove();
                    this.enterMoveTargetMode(army.id, { center: false });
                };
            }
            selector.appendChild(card);
        });

        const closeBtn = document.createElement('div'); closeBtn.className = 'squad-card bg-red-900 border-red-700'; closeBtn.innerHTML = '<div class="font-bold text-red-200">Ï∑®ÏÜå</div>';
        closeBtn.onclick = (e) => { e.stopPropagation(); selector.remove(); this.setMovePreview(""); }; selector.appendChild(closeBtn);
        viewport.appendChild(selector);
    }

    openSquadSelector(targetR, targetC, tileType, infoOnly = false) {
        const existing = document.querySelector('.squad-selector'); if(existing) existing.remove();
        this.hideFieldActionMenu();
        const prevTarget = document.querySelector('.field-target'); if (prevTarget) prevTarget.classList.remove('field-target');
        const targetCell = document.getElementById(`field-cell-${targetR}-${targetC}`); if (targetCell) targetCell.classList.add('field-target');
        const viewport = document.getElementById('map-viewport'); const selector = document.createElement('div'); selector.className = 'squad-selector';
        let previewPath = null; let previewText = "";
        let defaultInfoSet = false;

        this.getAvailableArmies().forEach(army => {
            const card = document.createElement('div'); card.className = 'squad-card';
            const isIdle = army.state === 'IDLE';
            const squadData = this.getSquadByArmyId(army.id);
            const stats = this.getSquadStats(squadData);
            const squadInfo = this.getSquadInfo(squadData);

            const path = AStar.findPath({r: army.r, c: army.c}, {r: targetR, c: targetC}, FIELD_MAP_DATA, this.occupiedTiles);
            const dist = path ? path.length - 1 : 999;
            const reachable = path && dist <= stats.range;
            const cpCost = path ? dist * CP_COST_PER_TILE : 0;
            const summary = path ? this.getPathSummary(path, stats.speedFactor) : null;
            const timeMin = summary ? summary.finalMin : 0;
            const breakdown = summary ? summary.breakdown : "";
            const cpEnough = this.cp >= cpCost;

            if (!infoOnly && !previewPath && path && isIdle && stats.power >= 10 && reachable && cpEnough) {
                previewPath = path;
                const terrainText = breakdown ? ` ¬∑ ÏßÄÌòï ${breakdown}` : "";
                previewText = `ETA ${timeMin.toFixed(1)}Î∂Ñ ¬∑ Í±∞Î¶¨ ${dist}Ïπ∏ ¬∑ ÏßÄÌúòÎ†• ${cpCost}${terrainText}`;
            }

            let statusHtml = "";
            if (infoOnly) {
                statusHtml = `<div class="squad-status">Î©§Î≤Ñ: ${squadInfo.count}/9 ¬∑ Ï¥ùLv: ${squadInfo.totalLevel}</div>` +
                             `<div class="squad-status text-[9px] text-gray-300">Ï†ÑÌà¨Î†• ${squadInfo.power} ¬∑ Ïù¥ÎèôÎ≤îÏúÑ ${stats.range}</div>`;
            } else {
                if (!isIdle) statusHtml = `<div class="squad-status">Ïù¥ÎèôÏ§ë...</div>`;
                else if (stats.power < 10) statusHtml = `<div class="squad-status text-red-400">Î≥ëÎ†• Î∂ÄÏ°±</div>`;
                else if (!path) statusHtml = `<div class="squad-status text-red-400">Í∞à Ïàò ÏóÜÏùå</div>`;
                else if (!reachable) statusHtml = `<div class="squad-status text-orange-400">Í±∞Î¶¨ Ï¥àÍ≥º (${dist}/${stats.range})</div>`;
                else if (!cpEnough) statusHtml = `<div class="squad-status text-red-400">ÏßÄÌúòÎ†• Î∂ÄÏ°± (ÌïÑÏöî ${cpCost})</div>`;
                else statusHtml = `<div class="squad-status text-green-400">Í±∞Î¶¨: ${dist} / ETA ${timeMin.toFixed(1)}Î∂Ñ / ÏßÄÌúòÎ†• ${cpCost}</div>` +
                    (breakdown ? `<div class="squad-status text-[9px] text-gray-300">ÏßÄÌòï: ${breakdown}</div>` : "");
            }

            if (!infoOnly && (!isIdle || stats.power < 10 || !reachable || !path || !cpEnough)) card.classList.add('disabled');
            card.innerHTML = `<div class="font-bold text-white">${army.name}</div>${statusHtml}`;

            if (infoOnly) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    this.setSquadInfoPanel(army);
                    this.centerCameraOnArmy(army.id);
                    this.lastSelectedArmyId = army.id;
                };
                if (!defaultInfoSet) { this.setSquadInfoPanel(army); this.centerCameraOnArmy(army.id); defaultInfoSet = true; }
            } else if (!card.classList.contains('disabled')) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    let energyCost = 1; let goldCost = 0;
                    if (isGateTile(tileType)) { energyCost = 5; goldCost = 100; }

                    this.selectedArmyId = army.id;
                    this.lastSelectedArmyId = army.id;
                    this.startMarch(army.id, targetR, targetC, tileType, energyCost, goldCost, cpCost, path, stats.speedFactor);
                    selector.remove();
                    if (targetCell) targetCell.classList.remove('field-target');
                    this.clearPathPreview();
                    this.renderFieldMap();
                };
            }
            selector.appendChild(card);
        });

        const closeBtn = document.createElement('div'); closeBtn.className = 'squad-card bg-red-900 border-red-700'; closeBtn.innerHTML = '<div class="font-bold text-red-200">Ï∑®ÏÜå</div>';
        closeBtn.onclick = (e) => { e.stopPropagation(); selector.remove(); if (targetCell) targetCell.classList.remove('field-target'); this.clearPathPreview(); this.setMovePreview(""); }; selector.appendChild(closeBtn);
        viewport.appendChild(selector);

        const TILE_SIZE = 13; const tx = 50 + (targetC * TILE_SIZE) + 6.5; const ty = 50 + (targetR * TILE_SIZE) + 6.5;
        this.moveCameraTo(tx, ty, viewport, document.getElementById('map-layer'));
        if (infoOnly) {
            this.setMovePreview("Î∂ÄÎåÄ Ï†ïÎ≥¥Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.");
        } else if (previewPath) {
            this.applyPathPreview(previewPath); this.setMovePreview(previewText);
        } else {
            this.setMovePreview("Ïù¥Îèô Î∂àÍ∞Ä ÎòêÎäî ÏßÄÌúòÎ†• Î∂ÄÏ°±");
        }
    }

    startMarch(armyId, r, c, type, energyCost, goldCost, cpCost, path, speedFactor) {
        if(this.energy < energyCost) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${energyCost})`); return; }
        if(this.gold < goldCost) { this.showToast(`Í≥®Îìú Î∂ÄÏ°± (${goldCost})`); return; }
        if(this.cp < cpCost) { this.showToast(`ÏßÄÌúòÎ†• Î∂ÄÏ°± (${cpCost})`); return; }

        this.energy -= energyCost; this.gold -= goldCost; this.cp -= cpCost; this.updateUI();
        this.clearPathPreview();
        this.setMovePreview("");

        const army = this.armies[armyId];
        army.state = 'MOVING_TO';
        army.path = path;
        army.stepTimes = this.buildStepTimes(path, speedFactor);
        army.nextStepIndex = 1; // Start from 1 (0 is current pos)
        army.moveInterval = Math.max(30, Math.floor(3 * MOVE_MS_PER_MIN));
        army.lastMoveTime = Date.now();
        army.target = { r, c, type };
        
        this.showToast(`${army.name} ÌñâÍµ∞ ÏãúÏûë!`);
        this.sound.playSpawn(); 
    }

    updateArmies() {
        const now = Date.now();
        const TILE_SIZE = 13;
        
        this.armies.forEach(army => {
            const el = document.getElementById(`army-marker-${army.id}`);
            if (el) {
                 const x = 50 + (army.c * TILE_SIZE);
                 const y = 50 + (army.r * TILE_SIZE);
                 el.style.transform = `translate(${x}px, ${y}px)`;
            }

            if (army.state === 'IDLE') return;

            if (army.state === 'MOVING_TO') {
                const stepTime = (army.stepTimes && army.stepTimes[army.nextStepIndex]) ? army.stepTimes[army.nextStepIndex] : army.moveInterval;
                if (now - army.lastMoveTime >= stepTime) {
                    army.lastMoveTime = now;
                    if (army.nextStepIndex < army.path.length) {
                        const nextPos = army.path[army.nextStepIndex];
                        army.r = nextPos.r;
                        army.c = nextPos.c;
                        army.nextStepIndex++;
                        this.revealFog(army.r, army.c, FOG_RADIUS);
                    } else {
                        this.handleArrival(army);
                    }
                }
            }
        });
    }

    handleArrival(army) {
        const { r, c, type } = army.target;
        let mapChanged = false;
        if (!this.occupiedTiles.has(`${r},${c}`)) {
            this.occupiedTiles.add(`${r},${c}`);
            mapChanged = true;
            if (isGateTile(type)) {
                this.showToast(`‚öîÔ∏è ${army.name} Í¥ÄÎ¨∏ ÎèåÌåå!`);
                this.sound.playUnlock();
                this.spawnParticles(this.width/2, this.height/2, "#FF0000", 50, "confetti");
            } else if (isDragonTile(type)) {
                this.showToast(`üî• ${army.name} ÎìúÎûòÍ≥§ Ï≤òÏπò!`);
                this.sound.playUnlock();
                this.spawnParticles(this.width/2, this.height/2, "#ff6b6b", 50, "confetti");
            } else {
                this.showToast(`üö© ${army.name} Ï†êÎ†π ÏÑ±Í≥µ!`);
                this.sound.playCollect();
            }
        } else {
            this.showToast(`${army.name} ÎèÑÏ∞© ÏôÑÎ£å`);
        }

        const collectibleInfo = this.getCollectibleFieldItemInfo(type);
        if (collectibleInfo && this.canCollectFieldObject(r, c)) {
            const item = this.createMergeItemFromInfo(collectibleInfo);
            if (this.spawnItem(item)) {
                this.clearFieldObjectFromMap(r, c);
                if (this.fieldObjectState) {
                    if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
                    this.fieldObjectState.regenByCode[type] = Date.now();
                }
                mapChanged = true;
                this.sound.playCollect();
                this.showToast("ÌöçÎìù ÏôÑÎ£å!");
            } else {
                this.showToast("Î®∏ÏßÄ Ïä¨Î°Ø Í≥µÍ∞Ñ Î∂ÄÏ°±");
                this.setMovePreview("Î®∏ÏßÄ Ïä¨Î°ØÏù¥ Í∞ÄÎìù Ï∞®ÏÑú ÌöçÎìù Ïã§Ìå®");
                setTimeout(() => {
                    if (!this.moveTargetMode) this.setMovePreview("");
                }, 1500);
            }
        }

        if (mapChanged && document.getElementById('field-modal').classList.contains('open')) {
            this.renderFieldMap();
        }
        army.state = 'IDLE';
        this.updateUI(); this.saveGame();
    }


    moveCameraTo(targetX, targetY, viewport, mapLayer) {
        const viewportWidth = viewport.clientWidth; const viewportHeight = viewport.clientHeight;
        const newX = (viewportWidth / 2) - (targetX * this.camera.scale); const newY = (viewportHeight / 2) - (targetY * this.camera.scale);
        mapLayer.style.transition = 'transform 0.3s ease-out';
        this.camera.x = newX; this.camera.y = newY;
        mapLayer.style.transform = `translate(${this.camera.x}px, ${this.camera.y}px) scale(${this.camera.scale})`;
        mapLayer.style.setProperty('--label-scale', (1 / this.camera.scale).toFixed(3));
        this.updateFloatingPanelPositionFromSelection();
        setTimeout(() => { mapLayer.style.transition = 'none'; }, 300);
    }

    centerCameraOnArmy(armyId) {
        const army = this.armies[armyId];
        const viewport = document.getElementById('map-viewport');
        const mapLayer = document.getElementById('map-layer');
        if (!army || !viewport || !mapLayer || !this.camera) return;
        const TILE_SIZE = 13;
        const tx = 50 + (army.c * TILE_SIZE) + (TILE_SIZE / 2);
        const ty = 50 + (army.r * TILE_SIZE) + (TILE_SIZE / 2);
        this.moveCameraTo(tx, ty, viewport, mapLayer);
    }

    initFieldCamera(viewport, mapLayer) {
        const TILE_SIZE = 13; const VIEW_TILES = 9;
        const vw = viewport.clientWidth || 300; const vh = viewport.clientHeight || 300;
        let scale; if (this.camera && this.camera.scale) scale = this.camera.scale; else scale = vw / (TILE_SIZE * VIEW_TILES);
        let targetR, targetC; let shouldRecenter = false;
        if (!this.camera) {
            const army0 = this.armies && this.armies[0];
            targetR = army0 ? army0.r : PLAYER_START.r;
            targetC = army0 ? army0.c : PLAYER_START.c;
            shouldRecenter = true;
        }
        if (shouldRecenter) {
            const targetX = 50 + (targetC * TILE_SIZE) + (TILE_SIZE / 2); const targetY = 50 + (targetR * TILE_SIZE) + (TILE_SIZE / 2);
            const x = (vw / 2) - (targetX * scale); const y = (vh / 2) - (targetY * scale);
            this.camera = { x, y, scale };
        }
        const updateTransform = () => { 
            mapLayer.style.transform = `translate(${this.camera.x}px, ${this.camera.y}px) scale(${this.camera.scale})`; 
            mapLayer.style.setProperty('--label-scale', (1 / this.camera.scale).toFixed(3));
            this.updateFloatingPanelPositionFromSelection();
        };
        setTimeout(updateTransform, 0);

        let isDragging = false, lastX = 0, lastY = 0, initialPinchDist = 0, initialPinchScale = 1;

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault(); const zoomSpeed = 0.1; const newScale = this.camera.scale + (e.deltaY > 0 ? -zoomSpeed : zoomSpeed) * this.camera.scale;
            if (newScale > 0.2 && newScale < 5) { 
                const centerX = viewport.clientWidth / 2; const centerY = viewport.clientHeight / 2;
                const scaleRatio = newScale / this.camera.scale;
                this.camera.x = centerX - (centerX - this.camera.x) * scaleRatio; this.camera.y = centerY - (centerY - this.camera.y) * scaleRatio;
                this.camera.scale = newScale; updateTransform();
            }
        });
        viewport.addEventListener('mousedown', (e) => { isDragging = true; this.isDraggingMap = false; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            if (Math.abs(e.clientX - lastX) > 5 || Math.abs(e.clientY - lastY) > 5) this.isDraggingMap = true;
            this.camera.x += e.clientX - lastX; this.camera.y += e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; updateTransform();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { isDragging = true; this.isDraggingMap = false; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }
            else if (e.touches.length === 2) { isDragging = false; initialPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); initialPinchScale = this.camera.scale; }
        }, { passive: false });
        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                if (Math.abs(e.touches[0].clientX - lastX) > 5 || Math.abs(e.touches[0].clientY - lastY) > 5) this.isDraggingMap = true;
                this.camera.x += e.touches[0].clientX - lastX; this.camera.y += e.touches[0].clientY - lastY; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; updateTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const newScale = initialPinchScale * (dist / initialPinchDist);
                if (newScale > 0.2 && newScale < 5) {
                    const centerX = viewport.clientWidth / 2; const centerY = viewport.clientHeight / 2;
                    const scaleRatio = newScale / this.camera.scale;
                    this.camera.x = centerX - (centerX - this.camera.x) * scaleRatio; this.camera.y = centerY - (centerY - this.camera.y) * scaleRatio;
                    this.camera.scale = newScale; updateTransform();
                }
            }
        }, { passive: false });
        viewport.addEventListener('touchend', () => { isDragging = false; });
    }

    closeModal() { 
        this.exitMoveTargetMode(); 
        document.getElementById('field-modal').classList.remove('open'); 
        document.getElementById('modal-refill').classList.remove('open'); 
        document.getElementById('modal-settings').classList.remove('open'); 
        document.getElementById('modal-object').classList.remove('open'); 
        if (this.shopTimer) { clearInterval(this.shopTimer); this.shopTimer = null; }
        this.currentShopContext = null;
        document.querySelector('#modal-object .modal-content')?.classList.remove('wide');
        this.clearPathPreview(); 
        this.setMovePreview(""); 
    }
    buyBuilding(type, price) {
        if (this.gold < price) { this.showToast("Í≥®Îìú Î∂ÄÏ°±!"); return; }
        const limit = BUILDING_LIMITS[type] || 999; const current = this.getBuildingCount(type);
        if (current >= limit) { this.showToast(`ÏµúÎåÄ Í∞úÏàò ÎèÑÎã¨! (${limit})`); return; }
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.gold -= price; const newItem = { type: type, level: 1, scale: 0 };
                if (type === ITEM_TYPE.BUILDING_CHEST) newItem.usage = 5; if (type === ITEM_TYPE.BUILDING_CAMP) newItem.storedUnits = []; 
                this.grid[r][c] = newItem; this.updateUI(); this.requestRender(); this.showToast("Í±¥ÏÑ§ ÏôÑÎ£å!"); this.closeModal();
                const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;
                this.spawnParticles(cx, cy, "#FFD700", 20, "confetti"); this.sound.playSpawn(); return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }
    getBuildingCount(type) { let count = 0; for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) { if (this.grid[r][c] && this.grid[r][c].type === type) count++; } return count; }
    getHighestBuildingLevel(unitType) {
        let bType = -1; if (unitType === ITEM_TYPE.UNIT_INFANTRY) bType = ITEM_TYPE.BUILDING_BARRACKS; else if (unitType === ITEM_TYPE.UNIT_ARCHER) bType = ITEM_TYPE.BUILDING_RANGE; else if (unitType === ITEM_TYPE.UNIT_CAVALRY) bType = ITEM_TYPE.BUILDING_STABLE;
        if (bType === -1) return 10; let maxLvl = 0; for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) if (this.grid[r][c] && this.grid[r][c].type === bType) maxLvl = Math.max(maxLvl, this.grid[r][c].level); return maxLvl;
    }
    resize() {
        const wrap = document.getElementById('canvas-wrapper'); this.canvas.width = Math.floor(wrap.clientWidth * this.dpr); this.canvas.height = Math.floor(wrap.clientHeight * this.dpr);
        this.canvas.style.width = `${wrap.clientWidth}px`; this.canvas.style.height = `${wrap.clientHeight}px`; this.ctx.resetTransform(); this.ctx.scale(this.canvas.width / this.width, this.canvas.width / this.width); this.ctx.imageSmoothingEnabled = false; this.requestRender();
    }
    addXp(amount) { this.currentXp += amount; if (this.currentXp >= this.requiredXp) this.levelUp(); this.updateUI(); }
    levelUp() {
        if (this.lordLevel >= 15) return; 
        const nextReq = this.requiredXp;
        if(this.currentXp >= nextReq) {
            const prevLv = this.lordLevel;
            const prevEn = this.maxEnergy;
            this.currentXp -= nextReq; this.lordLevel++; this.updateLevelStats(); this.energy = this.maxEnergy; this.refreshLockState();
            this.cp = this.maxCp;
            this.showLevelUpModal(prevLv, prevEn);
            this.sound.playLevelUp();
            if (this.currentXp >= this.requiredXp) this.levelUp();
        }
    }
    updateLevelStats() {
        const d = LEVEL_DATA.find(d => d.level === this.lordLevel);
        const nextD = LEVEL_DATA.find(d => d.level === this.lordLevel + 1);
        this.maxEnergy = d ? d.maxEnergy : 50;
        this.requiredXp = nextD ? (nextD.xp - d.xp) : 999999;
        this.baseMaxCp = this.lordLevel >= 10 ? 22 : 20;
        this.baseCpRegen = 1;
        this.applyCpBonuses();
    }
    selectItem(item, location) { if (this.selectedItem?.item !== item) this.sound.playClick(); this.selectedItem = item ? { item, location } : null; this.updateInfoPanel(); this.requestRender(); }
    updateInfoPanel() {
        const els = { name: document.getElementById('info-name'), desc: document.getElementById('info-desc'), cls: document.getElementById('info-class'), stats: document.getElementById('unit-stats-grid'), btn: document.getElementById('btn-action'), lbl: document.getElementById('action-label'), icon: document.getElementById('action-icon') };
        els.stats.classList.add('hidden'); els.cls.innerText = ""; els.btn.style.opacity = 0.5; els.lbl.innerText = "-";
        if (!this.selectedItem) { els.name.innerText = "ÏÑ†ÌÉùÎêú ÏóÜÏùå"; els.desc.innerText = "Ïú†ÎãõÏù¥ÎÇò Í±¥Î¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî."; return; }
        const item = this.selectedItem.item; const data = getData(item.type, item.level); els.name.innerText = `${data.name} LV.${item.level}`;
        if (item.type < 10) { 
            if (item.type === ITEM_TYPE.BUILDING_CHEST) els.desc.innerText = `ÎÇ®ÏùÄ ÌöüÏàò: ${item.usage}Ìöå`;
            else if (item.type === ITEM_TYPE.BUILDING_CAMP) els.desc.innerText = `Î≥¥Í¥Ä: ${item.storedUnits ? item.storedUnits.length : 0} / ${CAMP_CAPACITY[item.level]}`; // Modified here
            else { els.desc.innerText = "Ïú†Îãõ ÏÉùÏÇ∞"; const cost = data.energy || 1; els.lbl.innerText = `-${cost}‚ö°`; els.btn.style.opacity = 1; els.icon.innerText = ""; }
        } else if (item.type >= 20) { els.desc.innerText = "ÌÅ¥Î¶≠ÌïòÏó¨ ÌöçÎìù"; els.lbl.innerText = "ÌöçÎìù"; els.btn.style.opacity = 1; }
        else { 
            els.cls.innerText = data.class; els.desc.innerText = ""; els.stats.classList.remove('hidden');
            document.getElementById('st-hp').innerText = data.hp; document.getElementById('st-atk').innerText = data.atk; document.getElementById('st-def').innerText = data.def; 
            document.getElementById('st-spd').innerText = data.spd; document.getElementById('st-rng').innerText = data.rng; document.getElementById('st-mov').innerText = data.mov;
            els.lbl.innerText = `+${data.sell}`; els.icon.innerText = "üí∞"; els.btn.style.opacity = 1;
        }
    }
    handleAction() {
        if (!this.selectedItem) return; const { item, location } = this.selectedItem;
        if (item.type >= 10 && item.type < 20) { 
            if(location.zone===ZONES.GRID) this.grid[location.r][location.c]=null; else if(location.zone===ZONES.SQUAD1) this.squad1[location.idx]=null; else if(location.zone===ZONES.SQUAD2) this.squad2[location.idx]=null; else this.squad3[location.idx]=null;
            const val = getData(item.type, item.level).sell; this.gold += val; this.showToast(`+${val} G`); this.sound.playCollect(); this.selectItem(null); this.updateUI(); this.requestRender();
        } else if (item.type < 10 && item.type !== ITEM_TYPE.BUILDING_CHEST && item.type !== ITEM_TYPE.BUILDING_CAMP) this.produce(item);
    }
    setupInput() {
        const getPos = e => { const r = this.canvas.getBoundingClientRect(); return { x: ((e.touches?e.touches[0].clientX:e.clientX)-r.left)*(this.width/r.width), y: ((e.touches?e.touches[0].clientY:e.clientY)-r.top)*(this.width/r.width) }; };
        const start = e => {
            this.sound.resume(); const p = getPos(e); const hit = this.getZoneAt(p.x, p.y);
            if (hit) {
                if (hit.zone === ZONES.GRID && this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { this.tryUnlock(hit.r, hit.c); return; }
                let item = hit.zone===ZONES.GRID ? this.grid[hit.r][hit.c] : (hit.zone===ZONES.SQUAD1 ? this.squad1[hit.idx] : (hit.zone===ZONES.SQUAD2 ? this.squad2[hit.idx] : this.squad3[hit.idx]));
                this.potentialDrag = { startPos: p, item, hit };
            } else this.selectItem(null);
        };
        const move = e => {
            if (this.potentialDrag && !this.drag) { const p = getPos(e); if (Math.hypot(p.x-this.potentialDrag.startPos.x, p.y-this.potentialDrag.startPos.y) > 10 && this.potentialDrag.item) this.startDrag(this.potentialDrag.item, this.potentialDrag.hit, p); }
            if (this.drag) { this.drag.x = getPos(e).x; this.drag.y = getPos(e).y; this.hover = this.getZoneAt(this.drag.x, this.drag.y); this.requestRender(); }
        };
        const end = e => { if (this.drag) this.endDrag(); else if (this.potentialDrag) this.handleClick(this.potentialDrag.item, this.potentialDrag.hit); this.potentialDrag = null; this.drag = null; };
        this.canvas.onmousedown = start; window.onmousemove = move; window.onmouseup = end;
        this.canvas.ontouchstart = e => { start(e); e.preventDefault(); }; window.ontouchmove = e => { move(e); e.preventDefault(); }; window.ontouchend = end;
    }
    startDrag(item, hit, pos) {
        let cx, cy; if(hit.zone===ZONES.GRID) { cx = this.gridStartX+hit.c*this.gridTileSize; cy = this.gridStartY+hit.r*this.gridTileSize; } else if(hit.zone===ZONES.SQUAD1) { cx = this.squad1Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad1Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; } else if(hit.zone===ZONES.SQUAD2) { cx = this.squad2Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad2Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; } else { cx = this.squad3Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad3Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; }
        this.drag = { item, startZone: hit, x: pos.x, y: pos.y, offsetX: pos.x-cx, offsetY: pos.y-cy, size: hit.zone===ZONES.GRID?this.gridTileSize:this.squadCellSize };
        if(hit.zone===ZONES.GRID) this.grid[hit.r][hit.c]=null; else if(hit.zone===ZONES.SQUAD1) this.squad1[hit.idx]=null; else if(hit.zone===ZONES.SQUAD2) this.squad2[hit.idx]=null; else this.squad3[hit.idx]=null;
        this.selectItem(item, hit); this.requestRender();
    }
    endDrag() {
        const hit = this.getZoneAt(this.drag.x, this.drag.y); let returned = false;
        if (hit) {
            let target = null; if(hit.zone===ZONES.GRID) { if(this.gridState[hit.r][hit.c].type!==LOCK_TYPE.OPEN) returned=true; else target=this.grid[hit.r][hit.c]; } else if(hit.zone===ZONES.SQUAD1) target=this.squad1[hit.idx]; else if(hit.zone===ZONES.SQUAD2) target=this.squad2[hit.idx]; else target=this.squad3[hit.idx];
            if (!returned) {
                if (!target) { if(hit.zone===ZONES.GRID) this.grid[hit.r][hit.c]=this.drag.item; else if(hit.zone===ZONES.SQUAD1) this.squad1[hit.idx]=this.drag.item; else if(hit.zone===ZONES.SQUAD2) this.squad2[hit.idx]=this.drag.item; else this.squad3[hit.idx]=this.drag.item; this.selectItem(this.drag.item, hit); }
                else if (target.type===ITEM_TYPE.BUILDING_CAMP && this.drag.item.type>=10 && this.drag.item.type<20 && hit.zone===ZONES.GRID) { 
                    if (!target.storedUnits) target.storedUnits = []; 
                    const cap = CAMP_CAPACITY[target.level] || 4;
                    if (target.storedUnits.length < cap) {
                        target.storedUnits.push(this.drag.item);
                        this.showToast(`Î≥¥Í¥ÄÎê® (${target.storedUnits.length}/${cap})`);
                        this.sound.playClick();
                    } else {
                        this.showToast("Î≥¥Í¥ÄÌï®Ïù¥ Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§.");
                        returned = true;
                    }
                }
                else if (target.type===this.drag.item.type && target.level===this.drag.item.level) {
                    const isUnit = target.type>=10 && target.type<20; const maxLvl = isUnit ? 10 : 5; let canMerge = true;
                    
                    if(isUnit) { 
                        const bLvl = this.getHighestBuildingLevel(target.type); 
                        if(target.level >= bLvl+5) { 
                            this.showToast(`Ìï©ÏÑ± Î∂àÍ∞Ä (Í±¥Î¨º Lv.${target.level-4} ÌïÑÏöî)`); 
                            canMerge=false; returned=true; 
                        } 
                    }

                    if(canMerge && target.level < maxLvl) {
                        target.level++; target.scale=1.3;
                        if(target.type===ITEM_TYPE.BUILDING_CHEST) { 
                            target.usage = Math.floor((target.usage + this.drag.item.usage) * 0.5); 
                        }
                        const xp = MERGE_XP_DATA[target.level-1] || 1;
                        this.addXp(xp); this.showFloatingImage('xp', hit.zone===ZONES.GRID ? this.gridStartX+hit.c*this.gridTileSize : this.drag.x, this.drag.y);
                        this.spawnParticles(this.drag.x, this.drag.y, "#FFD700", 30, "spark"); this.sound.playMerge();
                    } else if(canMerge) { this.showToast("ÏµúÎåÄ Î†àÎ≤®"); returned=true; }
                } else returned=true;
            }
        } else returned=true;
        if (returned) { const s=this.drag.startZone; if(s.zone===ZONES.GRID) this.grid[s.r][s.c]=this.drag.item; else if(s.zone===ZONES.SQUAD1) this.squad1[s.idx]=this.drag.item; else if(s.zone===ZONES.SQUAD2) this.squad2[s.idx]=this.drag.item; else this.squad3[s.idx]=this.drag.item; }
        this.hover=null; this.updateUI(); this.requestRender(); this.drag=null;
    }
    handleClick(item, hit) {
        if(!item) { this.selectItem(null); return; }
        this.selectItem(item, hit);
        if(item.type>=20) this.collectResource(item, hit.r, hit.c);
        else if(item.type===ITEM_TYPE.BUILDING_CAMP) this.ejectCamp(item, hit.r, hit.c);
        else if(item.type<10 && item.type!==ITEM_TYPE.BUILDING_CAMP) {
            if(item.type===ITEM_TYPE.BUILDING_CHEST) this.produceFromChest(item, hit.r, hit.c);
            else this.produce(item);
        }
    }
    getZoneAt(x, y) {
        const check = (rect, rows, cols, size) => { if(x>=rect.x && x<rect.x+rect.w && y>=rect.y && y<rect.y+rect.h) { const c=Math.floor((x-rect.x)/size), r=Math.floor((y-rect.y)/size); if(c>=0 && c<cols && r>=0 && r<rows) return {c,r,idx:r*3+c}; } return null; };
        let res = check(this.squad1Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if(res) return {zone:ZONES.SQUAD1, ...res};
        res = check(this.squad2Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if(res) return {zone:ZONES.SQUAD2, ...res};
        if (this.thirdSquadUnlocked && this.squad3Rect) { res = check(this.squad3Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if(res) return {zone:ZONES.SQUAD3, ...res}; }
        if(x>=this.gridStartX && x<this.gridStartX+this.gridTileSize*CONFIG.gridCols && y>=this.gridStartY && y<this.gridStartY+this.gridTileSize*CONFIG.gridRows) { const c=Math.floor((x-this.gridStartX)/this.gridTileSize), r=Math.floor((y-this.gridStartY)/this.gridTileSize); if(c>=0 && c<CONFIG.gridCols && r>=0 && r<CONFIG.gridRows) return {zone:ZONES.GRID, r, c, idx:r*8+c}; }
        return null;
    }
    produce(building) {
        const buildingData = BUILDING_DATA[building.type];
        const stats = buildingData ? buildingData[building.level] : BUILDING_DATA[ITEM_TYPE.BUILDING_BARRACKS][1]; // Default fallback

        if(this.energy < stats.energy) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${stats.energy})`); return; }
        
        let unitType = ITEM_TYPE.UNIT_INFANTRY; 
        if(building.type === ITEM_TYPE.BUILDING_RANGE) unitType = ITEM_TYPE.UNIT_ARCHER; 
        else if(building.type === ITEM_TYPE.BUILDING_STABLE) unitType = ITEM_TYPE.UNIT_CAVALRY;

        let lvl = 1;
        const r = Math.random() * 100;
        let sum = 0;
        for(let i=0; i<stats.probs.length; i++) { 
            sum += stats.probs[i]; 
            if(r <= sum) { lvl = i+1; break; } 
        }

        if(this.spawnItem({type: unitType, level: lvl, scale: 0})) { 
            this.energy -= stats.energy; 
            this.updateUI(); 
            this.requestRender(); 
            this.sound.playSpawn(); 
        } else { 
            this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±"); 
        }
    }
    produceFromChest(chest, r, c) {
        if(this.energy<1) { this.showToast("ÏóêÎÑàÏßÄ Î∂ÄÏ°±"); return; }
        
        // Drop logic
        const table = CHEST_DROP_TABLE[chest.level] || CHEST_DROP_TABLE[1]; 
        let total=0; 
        table.forEach(e=>total+=e.prob); 
        let rnd=Math.random()*total, code=table[0].code; 
        for(let e of table) { if(rnd<e.prob){code=e.code;break;} rnd-=e.prob; }
        const info = getInfoFromCode(code);

        if(this.spawnItem({type:info.type, level:info.level, scale:0})) { 
            this.energy--; 
            chest.usage--; 
            chest.scale=1.2; 
            
            // Check usage
            if (chest.usage <= 0) {
                this.grid[r][c] = null; // Remove from grid
                if (this.selectedItem && this.selectedItem.item === chest) {
                    this.selectItem(null); // Deselect
                }
                this.showToast("ÏÉÅÏûêÍ∞Ä ÏÇ¨ÎùºÏ°åÏäµÎãàÎã§.");
            }
            
            this.updateUI(); 
            this.requestRender(); 
            this.sound.playSpawn(); 
        } else {
            this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±");
        }
    }
    spawnItem(item) {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) { this.grid[r][c]=item; const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2; this.spawnParticles(cx, cy, "#EEE", 10, "smoke"); return true; }
        return false;
    }
    ejectCamp(camp, r, c) {
        if(!camp.storedUnits || camp.storedUnits.length === 0) { this.showToast("ÎπÑÏñ¥ÏûàÏùå"); return; }
        const moves = [[0,1],[0,-1],[1,0],[-1,0]]; 
        for(let m of moves) { 
            const nr=r+m[0], nc=c+m[1]; 
            if(nr>=0 && nr<8 && nc>=0 && nc<8 && this.gridState[nr][nc].type===LOCK_TYPE.OPEN && !this.grid[nr][nc]) { 
                const unit = camp.storedUnits.pop(); // Take last added unit (LIFO)
                this.grid[nr][nc] = unit; 
                this.requestRender(); 
                this.sound.playClick(); 
                this.showToast(`Í∫ºÎÉÑ (${camp.storedUnits.length} ÎÇ®Ïùå)`);
                return; 
            } 
        }
        this.showToast("Ï£ºÎ≥Ä Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }
    collectResource(item, r, c) {
        const val = ITEM_VALUES[item.level] || 1; let pColor = "#fff";
        if(item.type===ITEM_TYPE.ITEM_GOLD) { this.gold+=val; this.showToast(`+${val}G`); pColor="#FFD700"; } else if(item.type===ITEM_TYPE.ITEM_ENERGY) { this.energy=Math.min(this.energy+val, this.maxEnergy); this.showToast(`+${val}‚ö°`); pColor="#00FFFF"; } else { this.gem+=val; this.showToast(`+${val}üíé`); pColor="#FF00FF"; }
        const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2; this.spawnParticles(cx, cy, pColor, 15, "spark"); this.sound.playCollect(); this.grid[r][c]=null; this.updateUI(); this.requestRender();
    }
    tryUnlock(r, c) {
        const l = this.gridState[r][c];
        if(l.type===LOCK_TYPE.GOLD) { if(this.gold>=l.value) { this.gold-=l.value; this.gridState[r][c]={type:LOCK_TYPE.OPEN}; this.showToast("Ìï¥Í∏à!"); this.spawnParticles(this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, this.gridStartY + r * this.gridTileSize + this.gridTileSize/2, "#FFF", 20, "confetti"); this.sound.playUnlock(); } else { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); this.sound.playError(); } }
        else if(l.type===LOCK_TYPE.LEVEL) { if(this.lordLevel>=l.value) { this.gridState[r][c]={type:LOCK_TYPE.OPEN}; this.showToast("Ìï¥Í∏à!"); this.spawnParticles(this.gridStartX + c * this.gridTileSize + this.gridTileSize/2, this.gridStartY + r * this.gridTileSize + this.gridTileSize/2, "#FFF", 20, "confetti"); this.sound.playUnlock(); } else { this.showToast(`LV.${l.value} ÌïÑÏöî`); this.sound.playError(); } }
        this.updateUI(); this.requestRender();
    }
    loop() {
        // Ïä§ÏøºÎìú Ïù¥Îèô ÏóÖÎç∞Ïù¥Ìä∏ (Îß§ ÌîÑÎ†àÏûÑ)
        this.updateArmies();

            if(this.isDirty || this.drag) {
                this.ctx.clearRect(0,0,this.width,this.height);
            this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50", ZONES.SQUAD1); this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3", ZONES.SQUAD2);
            if (this.thirdSquadUnlocked && this.squad3Rect) this.drawSquad(this.squad3, this.squad3Rect, "SQUAD 3", "#f59e0b", ZONES.SQUAD3);
            for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
                const x = this.gridStartX+c*this.gridTileSize, y = this.gridStartY+r*this.gridTileSize;
                const isHover = this.hover && this.hover.zone===ZONES.GRID && this.hover.r===r && this.hover.c===c, isSel = this.selectedItem && this.selectedItem.location.zone===ZONES.GRID && this.selectedItem.location.r===r && this.selectedItem.location.c===c;
                this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c], isHover, isSel);
            }
            if(this.drag) this.drawItem(this.drag.x-this.drag.size/2, this.drag.y-this.drag.size/2, this.drag.size, this.drag.item, true);
            for(let i=this.particles.length-1; i>=0; i--) { this.particles[i].update(); this.particles[i].draw(this.ctx); if(this.particles[i].life <= 0) this.particles.splice(i, 1); }
            let anim = false; this.grid.flat().concat(this.squad1).concat(this.squad2).concat(this.squad3).forEach(i=>{ if(i&&i.scale!==1){ i.scale+=(i.scale<1?0.1:-0.05); if(Math.abs(i.scale-1)<0.05)i.scale=1; anim=true; } });
            this.isDirty = anim || !!this.drag || this.particles.length > 0;
        }
        requestAnimationFrame(()=>this.loop());
    }
    getSquadPower(s) {
        let p = 0;
        for (let u of s) {
            if (!u || u.type < 10 || u.type >= 20) continue;
            const base = getData(u.type, u.level);
            const d = this.applyFieldBuffsToStats(base);
            if (d && d.hp) p += (d.hp + d.atk + d.def);
        }
        return p;
    }
    drawSquad(data, rect, label, color, zone) {
        const cp = this.getSquadPower(data);
        this.ctx.fillStyle = color; this.ctx.font="bold 40px sans-serif"; this.ctx.textAlign="center"; this.ctx.fillText(`${label}`, rect.x+rect.w/2, rect.y-22);
        this.ctx.fillStyle = color+"11"; this.ctx.fillRect(rect.x-5, rect.y-5, rect.w+10, rect.h+10);
        this.ctx.font="bold 40px sans-serif"; this.ctx.fillStyle = "#fff"; this.ctx.fillText(`‚öîÔ∏è ${cp}`, rect.x+rect.w/2, rect.y + rect.h + 39); 
        for(let i=0; i<9; i++) {
            const x = rect.x+(i%3)*this.squadCellSize, y = rect.y+Math.floor(i/3)*this.squadCellSize;
            const isHover = this.hover && this.hover.zone===zone && this.hover.idx===i, isSel = this.selectedItem && this.selectedItem.location.zone===zone && this.selectedItem.location.idx===i;
            this.drawCell(x, y, this.squadCellSize, data[i], {type:LOCK_TYPE.OPEN}, isHover, isSel);
        }
    }
    drawCell(x, y, s, item, lock, isHover, isSel) {
        const p=2, size=s-p*2;
        this.ctx.fillStyle = lock.type===LOCK_TYPE.OPEN ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.5)"; this.ctx.fillRect(x+p, y+p, size, size);
        if(isSel) { this.ctx.lineWidth=6; this.ctx.strokeStyle="#0f0"; this.ctx.strokeRect(x+p, y+p, size, size); }
        else if(isHover) { this.ctx.lineWidth=4; this.ctx.strokeStyle="#ff0"; this.ctx.strokeRect(x+p, y+p, size, size); }
        else { this.ctx.lineWidth=2; this.ctx.strokeStyle="rgba(0,0,0,0.3)"; this.ctx.strokeRect(x+p, y+p, size, size); }
        if(lock.type!==LOCK_TYPE.OPEN) {
            const img = this.assets.getImage(lock.type===LOCK_TYPE.GOLD?'1804':'lock');
            if(img && img.complete && img.naturalWidth>0) { const isz=size*0.6; this.ctx.drawImage(img, x+(s-isz)/2, y+(s-isz)/2, isz, isz); this.ctx.fillStyle=lock.type===LOCK_TYPE.GOLD?"#ffd700":"#fff"; this.ctx.font="bold 20px sans-serif"; this.ctx.textAlign="center"; this.ctx.strokeStyle="black"; this.ctx.lineWidth=4; const txt = lock.type===LOCK_TYPE.GOLD ? `üí∞${lock.value}` : `LV.${lock.value}`; this.ctx.strokeText(txt, x+s/2, y+s/2); this.ctx.fillText(txt, x+s/2, y+s/2); }
        } else if(item && item !== this.drag?.item) this.drawItem(x, y, s, item);
    }
    drawItem(x, y, s, item, isDrag=false) {
        const sc=isDrag?1.1:item.scale, p=4, ds=(s-p*2)*sc, offset=(s-ds)/2; const img = this.assets.getImage(item.type, item.level);
        
        // --- ADDED: LEVEL COLOR BORDER ---
        const lvColor = LEVEL_COLORS[item.level] || "#fff";
        
        if(img && img.complete && img.naturalWidth>0) {
            if(isDrag) { this.ctx.shadowColor="black"; this.ctx.shadowBlur=15; }
            const drawSize = ds * 1.2; const drawOffset = (s - drawSize) / 2;
            this.ctx.drawImage(img, x + drawOffset, y + drawOffset, drawSize, drawSize); this.ctx.shadowBlur=0;
        } else {
            let c = "#cfd8dc"; let sym = "‚ùì";
            if(item.type===ITEM_TYPE.BUILDING_BARRACKS) { c="#795548"; sym="üè†"; } else if(item.type===ITEM_TYPE.BUILDING_RANGE) { c="#388e3c"; sym="üéØ"; } else if(item.type===ITEM_TYPE.BUILDING_STABLE) { c="#1976d2"; sym="üê¥"; } else if(item.type===ITEM_TYPE.BUILDING_CHEST) { c="#ffa000"; sym="üéÅ"; } else if(item.type===ITEM_TYPE.BUILDING_CAMP) { c="#5d4037"; sym="‚õ∫"; } else if(item.type===ITEM_TYPE.UNIT_INFANTRY) { c="#eeeeee"; sym="üõ°Ô∏è"; } else if(item.type===ITEM_TYPE.UNIT_ARCHER) { c="#c8e6c9"; sym="üèπ"; } else if(item.type===ITEM_TYPE.UNIT_CAVALRY) { c="#bbdefb"; sym="üêé"; } else if(item.type===ITEM_TYPE.ITEM_GOLD) { c="#fff176"; sym="üí∞"; } else if(item.type===ITEM_TYPE.ITEM_ENERGY) { c="#80deea"; sym="‚ö°"; } else if(item.type===ITEM_TYPE.ITEM_CRYSTAL) { c="#e1bee7"; sym="üíé"; }
            const drawSize = ds * 1.2; const drawOffset = (s - drawSize) / 2;
            this.ctx.fillStyle = c; this.roundRect(x + drawOffset, y + drawOffset, drawSize, drawSize, 12); this.ctx.fill(); this.ctx.strokeStyle = "rgba(0,0,0,0.4)"; this.ctx.lineWidth = 2; this.ctx.stroke(); this.ctx.fillStyle = "rgba(0,0,0,0.6)"; this.ctx.font = `${Math.floor(drawSize*0.5)}px sans-serif`; this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle"; this.ctx.fillText(sym, x+s/2, y+s/2);
        }
        
        this.ctx.lineWidth = 3;
        this.ctx.strokeStyle = lvColor;
        this.ctx.strokeRect(x+p, y+p, ds, ds);

        const bx=x+s/2, by=y+ds; 
        if(item.type>=10 || item.type<10) { 
            this.ctx.fillStyle="rgba(0,0,0,0.8)"; this.ctx.beginPath(); this.ctx.arc(bx, by-10, 10, 0, Math.PI*2); this.ctx.fill(); this.ctx.strokeStyle="#fff"; this.ctx.lineWidth=1; this.ctx.stroke(); this.ctx.fillStyle="#fff"; this.ctx.font="bold 12px sans-serif"; this.ctx.textAlign="center"; this.ctx.fillText(item.level, bx, by-6);
        }
        
        // --- MODIFIED: Camp Storage Display ---
        if(item.type===ITEM_TYPE.BUILDING_CAMP) { 
            const count = item.storedUnits ? item.storedUnits.length : 0;
            const cap = CAMP_CAPACITY[item.level] || 4;
            
            // Styled Text Box
            const text = `${count}/${cap}`;
            this.ctx.font = "bold 16px sans-serif";
            const textW = this.ctx.measureText(text).width + 8;
            
            this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; // Semi-transparent black bg
            this.ctx.beginPath();
            this.ctx.roundRect(bx - textW/2, y + s/2 - 10, textW, 20, 4);
            this.ctx.fill();
            
            this.ctx.fillStyle = "#fff"; // White text
            this.ctx.shadowColor = "black";
            this.ctx.shadowBlur = 2;
            this.ctx.fillText(text, bx, y + s/2 + 6);
            this.ctx.shadowBlur = 0; // Reset shadow
        }
    }
    roundRect(x,y,w,h,r){this.ctx.beginPath();this.ctx.moveTo(x+r,y);this.ctx.arcTo(x+w,y,x+w,y+h,r);this.ctx.arcTo(x+w,y+h,x,y+h,r);this.ctx.arcTo(x,y+h,x,y,r);this.ctx.arcTo(x,y,x+w,y,r);this.ctx.closePath();}
    showToast(msg) { if (msg.includes("Î∂ÄÏ°±") || msg.includes("Î∂àÍ∞Ä")) this.sound.playError(); const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1000); }
    showFloatingImage(key, x, y) {
        const img = this.assets.getImage(key); if(!img) return; const el = document.createElement('img'); el.src = img.src; el.className='float-img';
        const r = this.canvas.getBoundingClientRect(); el.style.left = ((x/this.width)*r.width)+"px"; el.style.top = ((y/this.height)*r.height)+"px"; document.getElementById('canvas-wrapper').appendChild(el); setTimeout(()=>el.remove(), 1000);
    }
    showFloatingText(text, x, y, color) {
        const el = document.createElement('div');
        el.innerText = text; el.id = 'income-float'; el.style.color = color;
        // Simple positioning relative to container
        el.style.left = '50%'; el.style.top = '20%'; el.style.transform = 'translate(-50%, 0)';
        document.getElementById('canvas-wrapper').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    showJoinNotice(text) {
        const el = document.createElement('div');
        el.className = 'join-float';
        el.innerText = text;
        document.getElementById('game-container').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }
    updateUI() {
        document.getElementById('energy-display').innerText=`${this.energy}/${this.maxEnergy}`;
        document.getElementById('cp-display').innerText=`${this.cp}/${this.maxCp}`;
        document.getElementById('gold-display').innerText=this.gold; document.getElementById('gem-display').innerText=this.gem; document.getElementById('level-display').innerText=`LORD LV.${this.lordLevel}`; document.getElementById('xp-text').innerText=`${this.currentXp} / ${this.requiredXp}`; document.getElementById('xp-bar').style.width=`${(this.currentXp/this.requiredXp)*100}%`;
        const fieldCp = document.getElementById('field-cp-display'); if (fieldCp) fieldCp.innerText = `${this.cp}/${this.maxCp}`;
        this.saveGame();
    }
}
const game = new Game();
</script>
</body>
</html>
