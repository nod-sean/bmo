<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KOV Prototype v9 - Graphic Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a1a;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            margin: 0; padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* ì „ì²´ ì»¨í…Œì´ë„ˆ (9:16 ë¹„ìœ¨ ìœ ì§€) */
        #app-root {
            position: relative;
            background-color: #4e342e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            aspect-ratio: 9/16;
            height: 100vh;
            max-height: 100vh;
            max-width: 56.25vh; 
            display: flex;
            flex-direction: column;
        }

        /* 1. ìƒë‹¨ ì •ë³´ì°½ */
        #ui-header {
            flex: 0 0 10%;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            z-index: 20;
        }

        /* 2. ê²Œì„ ìº”ë²„ìŠ¤ */
        #canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #3e2723; /* ìº”ë²„ìŠ¤ ë°°ê²½ìƒ‰ ëª…ì‹œ */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 3. í•˜ë‹¨ ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        #ui-footer {
            flex: 0 0 15%;
            background: rgba(30, 20, 15, 0.95);
            border-top: 4px solid #8d6e63;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            z-index: 20;
        }

        /* UI Elements */
        .pill {
            background: #333; padding: 4px 12px;
            border-radius: 15px; display: flex; align-items: center; gap: 5px;
            font-size: 14px; font-weight: bold; border: 1px solid #555;
        }
        
        .btn {
            background: linear-gradient(to bottom, #ffb300, #ff6f00);
            color: #fff; border: none; padding: 10px 20px;
            border-radius: 8px; font-weight: bold; font-size: 14px;
            box-shadow: 0 4px 0 #e65100; cursor: pointer;
            margin: 0 5px;
        }
        .btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #e65100; }
        .btn-green { background: linear-gradient(to bottom, #66bb6a, #43a047); box-shadow: 0 4px 0 #2e7d32; }
        .btn-purple { background: linear-gradient(to bottom, #ab47bc, #8e24aa); box-shadow: 0 4px 0 #6a1b9a; }
        
        #toast {
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #fff;
            padding: 10px 20px; border-radius: 20px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
            z-index: 100; font-weight: bold; text-align: center;
        }
    </style>
</head>
<body>

<div id="app-root">
    <!-- Header -->
    <div id="ui-header">
        <div class="flex justify-between mb-2">
            <div class="pill"><span style="color:#ffeb3b">âš¡</span> <span id="energy-display">100/100</span></div>
            <div class="pill"><span style="color:#ffd700">ğŸ’°</span> <span id="gold-display">3000</span></div>
            <div class="pill"><span style="color:#4fc3f7">ğŸ’</span> <span id="gem-display">50</span></div>
        </div>
        <div class="flex justify-between px-1">
             <span class="text-gray-300 font-bold text-sm" id="level-display">LORD LV.1</span>
             <span class="text-green-400 font-bold text-sm" id="squad-power">POWER: 0</span>
        </div>
    </div>

    <!-- Game View -->
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="toast">ë©”ì‹œì§€</div>
    </div>

    <!-- Footer -->
    <div id="ui-footer">
        <h3 id="info-title" class="text-yellow-400 font-bold text-lg mb-1">ì¤€ë¹„ ì™„ë£Œ</h3>
        <p id="info-desc" class="text-gray-300 text-xs mb-3">ê±´ë¬¼ì„ ëˆŒëŸ¬ ìƒì‚°í•˜ê±°ë‚˜, ë“œë˜ê·¸í•˜ì—¬ ë¨¸ì§€í•˜ì„¸ìš”.</p>
        <div class="flex">
            <button class="btn" onclick="game.cheatEnergy()">âš¡ +30</button>
            <button class="btn btn-green" onclick="game.spawnChest()">ğŸ ìƒì</button>
            <button class="btn btn-purple" onclick="game.spawnCamp()">â›º ìº í”„</button>
        </div>
    </div>
</div>

<script>
/**
 * KOV Prototype v9
 * - Replaced external images with Canvas Drawing to fix "White Square" issue.
 * - Added Name Labels above Level Numbers.
 */

// --- Game Logic ---

const CONFIG = {
    gridCols: 8, gridRows: 8, gridPadding: 10,
    squadCols: 3, squadRows: 3, squadGap: 10,
    barracksCost: 5, maxLevel: 10
};

const ITEM_TYPE = {
    EMPTY: 0,
    BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3,
    BUILDING_CHEST: 4, BUILDING_CAMP: 5,
    UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12,
    ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22
};

const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2' };

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.wrapper = document.getElementById('canvas-wrapper');
        
        // Game State
        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null);
        this.squad2 = Array(9).fill(null);
        this.energy = 100; this.gold = 3000; this.gem = 50; this.lordLevel = 1;
        this.drag = null;

        this.initGame();
        
        window.addEventListener('resize', () => this.resize());
        this.resize();

        this.canvas.addEventListener('mousedown', e => this.handleInput(e, 'start'));
        window.addEventListener('mousemove', e => this.handleInput(e, 'move'));
        window.addEventListener('mouseup', e => this.handleInput(e, 'end'));
        
        this.canvas.addEventListener('touchstart', e => this.handleInput(e, 'start'), {passive: false});
        window.addEventListener('touchmove', e => this.handleInput(e, 'move'), {passive: false});
        window.addEventListener('touchend', e => this.handleInput(e, 'end'));

        this.loop();
    }

    initGame() {
        // Init Locks
        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                const isEdge = (r===0 || r===CONFIG.gridRows-1 || c===0 || c===CONFIG.gridCols-1);
                if(!isEdge) this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
                else {
                    if((r+c)%2===0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: 500 };
                    else this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: 3 };
                }
            }
        }
        // Init Buildings
        this.grid[2][2] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[2][4] = { type: ITEM_TYPE.BUILDING_RANGE, level: 1, scale: 1 };
        this.grid[2][5] = { type: ITEM_TYPE.BUILDING_STABLE, level: 1, scale: 1 };
        this.grid[3][3] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnit: null };
    }

    resize() {
        this.canvas.width = this.wrapper.clientWidth;
        this.canvas.height = this.wrapper.clientHeight;
        
        const W = this.canvas.width;
        const H = this.canvas.height;
        
        const squadAreaH = H * 0.35;
        this.squadCellSize = Math.min((W - 40) / 7, squadAreaH / 4);
        
        const squadW = this.squadCellSize * 3;
        const squadTotalW = squadW * 2 + 20;
        const squadStartX = (W - squadTotalW) / 2;
        const squadStartY = 20;

        this.squad1Rect = { x: squadStartX, y: squadStartY, w: squadW, h: squadW };
        this.squad2Rect = { x: squadStartX + squadW + 20, y: squadStartY, w: squadW, h: squadW };

        const gridAreaY = squadStartY + squadW + 30;
        const availH = H - gridAreaY - 10;
        const availW = W - 20;
        this.gridTileSize = Math.min(availW / CONFIG.gridCols, availH / CONFIG.gridRows);
        
        const gridTotalW = this.gridTileSize * CONFIG.gridCols;
        this.gridStartX = (W - gridTotalW) / 2;
        this.gridStartY = gridAreaY;
    }

    getCanvasPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: cx - rect.left, y: cy - rect.top };
    }

    getZoneAt(x, y) {
        if (x >= this.squad1Rect.x && x < this.squad1Rect.x + this.squad1Rect.w && y >= this.squad1Rect.y && y < this.squad1Rect.y + this.squad1Rect.h) {
            const c = Math.floor((x - this.squad1Rect.x) / this.squadCellSize);
            const r = Math.floor((y - this.squad1Rect.y) / this.squadCellSize);
            return { zone: ZONES.SQUAD1, idx: r * 3 + c };
        }
        if (x >= this.squad2Rect.x && x < this.squad2Rect.x + this.squad2Rect.w && y >= this.squad2Rect.y && y < this.squad2Rect.y + this.squad2Rect.h) {
            const c = Math.floor((x - this.squad2Rect.x) / this.squadCellSize);
            const r = Math.floor((y - this.squad2Rect.y) / this.squadCellSize);
            return { zone: ZONES.SQUAD2, idx: r * 3 + c };
        }
        if (x >= this.gridStartX && y >= this.gridStartY) {
            const c = Math.floor((x - this.gridStartX) / this.gridTileSize);
            const r = Math.floor((y - this.gridStartY) / this.gridTileSize);
            if (c >= 0 && c < CONFIG.gridCols && r >= 0 && r < CONFIG.gridRows) {
                return { zone: ZONES.GRID, r, c };
            }
        }
        return null;
    }

    handleInput(e, state) {
        if(state === 'start') e.preventDefault();
        let pos = (state !== 'end') ? this.getCanvasPos(e) : { x: this.drag?.x||0, y: this.drag?.y||0 };

        if (state === 'start') {
            const hit = this.getZoneAt(pos.x, pos.y);
            if (!hit) return;

            if (hit.zone === ZONES.GRID) {
                if (this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { this.tryUnlock(hit.r, hit.c); return; }
                const item = this.grid[hit.r][hit.c];
                if (item) {
                    if (item.type === ITEM_TYPE.BUILDING_CHEST) { this.openChest(hit.r, hit.c); return; }
                    if (item.type >= 20) { this.collectResource(item, hit.r, hit.c); return; }
                    if (item.type === ITEM_TYPE.BUILDING_CAMP) { this.ejectCamp(item, hit.r, hit.c); return; }
                    if (item.type < 10) { this.produce(item.type); return; }
                }
            }

            let item = null;
            if(hit.zone === ZONES.GRID) item = this.grid[hit.r][hit.c];
            else if(hit.zone === ZONES.SQUAD1) item = this.squad1[hit.idx];
            else if(hit.zone === ZONES.SQUAD2) item = this.squad2[hit.idx];

            if (item && item.type >= 10 && item.type < 20) {
                this.drag = { item: item, startZone: hit, x: pos.x, y: pos.y };
                if(hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = null;
                else if(hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = null;
                else if(hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = null;
            }
        }
        else if (state === 'move' && this.drag) {
            this.drag.x = pos.x; this.drag.y = pos.y;
        }
        else if (state === 'end' && this.drag) {
            const hit = this.getZoneAt(this.drag.x, this.drag.y);
            let returned = false;

            if (hit) {
                let target = null;
                if(hit.zone === ZONES.GRID) {
                    if(this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) returned = true;
                    else target = this.grid[hit.r][hit.c];
                }
                else if(hit.zone === ZONES.SQUAD1) target = this.squad1[hit.idx];
                else if(hit.zone === ZONES.SQUAD2) target = this.squad2[hit.idx];

                if (!returned) {
                    if (hit.zone === ZONES.GRID && target && target.type === ITEM_TYPE.BUILDING_CAMP && !target.storedUnit) {
                        target.storedUnit = this.drag.item;
                        this.showToast("ë³‘ì‚¬ ë³´ê´€ ì™„ë£Œ");
                    }
                    else if (!target) {
                        if(hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = this.drag.item;
                        else if(hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = this.drag.item;
                        else if(hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = this.drag.item;
                    }
                    else if (target.type === this.drag.item.type && target.level === this.drag.item.level && target.level < CONFIG.maxLevel) {
                        target.level++;
                        target.scale = 1.3;
                        this.showToast("Level Up!");
                    }
                    else returned = true;
                }
            } else returned = true;

            if (returned) {
                const s = this.drag.startZone;
                if(s.zone === ZONES.GRID) this.grid[s.r][s.c] = this.drag.item;
                else if(s.zone === ZONES.SQUAD1) this.squad1[s.idx] = this.drag.item;
                else if(s.zone === ZONES.SQUAD2) this.squad2[s.idx] = this.drag.item;
            }
            this.drag = null;
            this.updateUI();
        }
    }

    // --- Game Logic Methods ---
    produce(type) {
        if(this.energy < CONFIG.barracksCost) { this.showToast("ì—ë„ˆì§€ ë¶€ì¡±!"); return; }
        
        let unitType = ITEM_TYPE.UNIT_INFANTRY;
        if(type === ITEM_TYPE.BUILDING_RANGE) unitType = ITEM_TYPE.UNIT_ARCHER;
        if(type === ITEM_TYPE.BUILDING_STABLE) unitType = ITEM_TYPE.UNIT_CAVALRY;

        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                if(this.gridState[r][c].type === LOCK_TYPE.OPEN && !this.grid[r][c]) {
                    this.energy -= CONFIG.barracksCost;
                    this.grid[r][c] = { type: unitType, level: 1, scale: 0 };
                    this.updateUI();
                    return;
                }
            }
        }
        this.showToast("ê³µê°„ ë¶€ì¡±!");
    }

    openChest(r, c) {
        this.grid[r][c] = null;
        this.showToast("ìƒì ì˜¤í”ˆ...");
        setTimeout(() => {
            const rand = Math.random();
            let reward = ITEM_TYPE.ITEM_GOLD;
            if(rand > 0.6) reward = ITEM_TYPE.ITEM_ENERGY;
            this.grid[r][c] = { type: reward, level: 1, scale: 0 };
        }, 300);
    }

    collectResource(item, r, c) {
        if(item.type === ITEM_TYPE.ITEM_GOLD) this.gold += 100;
        if(item.type === ITEM_TYPE.ITEM_ENERGY) this.energy += 20;
        this.grid[r][c] = null;
        this.updateUI();
    }

    ejectCamp(camp, r, c) {
        if(!camp.storedUnit) { this.showToast("ë¹„ì–´ìˆìŒ"); return; }
        const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
        for(let n of neighbors) {
            const nr = r+n[0], nc = c+n[1];
            if(nr>=0 && nr<8 && nc>=0 && nc<8 && !this.grid[nr][nc] && this.gridState[nr][nc].type===LOCK_TYPE.OPEN) {
                this.grid[nr][nc] = camp.storedUnit;
                camp.storedUnit = null;
                return;
            }
        }
        this.showToast("ê³µê°„ ë¶€ì¡±");
    }

    tryUnlock(r, c) {
        const lock = this.gridState[r][c];
        if(lock.type === LOCK_TYPE.GOLD) {
            if(this.gold >= lock.value) {
                this.gold -= lock.value;
                this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
                this.showToast("í•´ê¸ˆ ì™„ë£Œ!");
            } else this.showToast("ê³¨ë“œ ë¶€ì¡±");
        } else if(lock.type === LOCK_TYPE.LEVEL) {
            if(this.lordLevel >= lock.value) {
                this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
                this.showToast("í•´ê¸ˆ ì™„ë£Œ!");
            } else this.showToast(`LV.${lock.value} í•„ìš”`);
        }
        this.updateUI();
    }

    // --- Rendering ---
    loop() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50");
        this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3");

        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                const x = this.gridStartX + c * this.gridTileSize;
                const y = this.gridStartY + r * this.gridTileSize;
                this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c]);
            }
        }

        if(this.drag) {
            this.drawItem(this.drag.x - this.gridTileSize/2, this.drag.y - this.gridTileSize/2, this.gridTileSize, this.drag.item, true);
        }

        this.grid.flat().forEach(i => i && this.anim(i));
        requestAnimationFrame(() => this.loop());
    }

    anim(item) {
        if(item.scale < 1) item.scale += 0.1;
        if(item.scale > 1) item.scale -= 0.05;
    }

    drawSquad(data, rect, label, color) {
        this.ctx.fillStyle = color;
        this.ctx.font = "bold 16px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText(label, rect.x + rect.w/2, rect.y - 8);
        
        this.ctx.fillStyle = color + "33";
        this.ctx.fillRect(rect.x-5, rect.y-5, rect.w+10, rect.h+10);

        for(let i=0; i<9; i++) {
            const c = i % 3; const r = Math.floor(i / 3);
            const x = rect.x + c * this.squadCellSize;
            const y = rect.y + r * this.squadCellSize;
            this.drawCell(x, y, this.squadCellSize, data[i], {type:LOCK_TYPE.OPEN});
        }
    }

    drawCell(x, y, size, item, lock) {
        const pad = 2;
        const innerSize = size - pad * 2;
        
        this.ctx.fillStyle = (lock.type !== LOCK_TYPE.OPEN) ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.1)";
        this.ctx.fillRect(x + pad, y + pad, innerSize, innerSize);
        this.ctx.strokeStyle = "rgba(0,0,0,0.3)";
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(x+pad, y+pad, innerSize, innerSize);

        if(lock.type !== LOCK_TYPE.OPEN) {
            this.ctx.fillStyle = "white";
            this.ctx.font = "16px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            const text = lock.type === LOCK_TYPE.GOLD ? `ğŸ’°${lock.value}` : `ğŸ”’LV.${lock.value}`;
            this.ctx.fillText(text, x + size/2, y + size/2);
            return;
        }

        if(item && item !== this.drag?.item) {
            this.drawItem(x, y, size, item);
        }
    }

    drawItem(x, y, size, item, isDrag=false) {
        const scale = isDrag ? 1.1 : item.scale;
        const pad = 4;
        const innerSize = size - pad * 2;
        const drawSize = innerSize * scale;
        const cx = x + size / 2;
        const cy = y + size / 2;
        const dx = cx - drawSize/2;
        const dy = cy - drawSize/2;

        if(isDrag) {
            this.ctx.shadowColor = "black";
            this.ctx.shadowBlur = 10;
        }

        // --- Procedural Drawing (No external images) ---
        const type = item.type;
        const level = item.level;
        
        // 1. Background Color
        let bgColor = "#aaa";
        let label = "";
        let symbol = "";

        if (type === ITEM_TYPE.BUILDING_BARRACKS) { bgColor = "#8d6e63"; label = "ë³‘ì˜"; symbol = "ğŸ "; }
        else if (type === ITEM_TYPE.BUILDING_RANGE) { bgColor = "#558b2f"; label = "ì‚¬ê²©ì¥"; symbol = "ğŸ¯"; }
        else if (type === ITEM_TYPE.BUILDING_STABLE) { bgColor = "#1565c0"; label = "ë§ˆêµ¬ê°„"; symbol = "ğŸ´"; }
        else if (type === ITEM_TYPE.BUILDING_CHEST) { bgColor = "#ffb300"; label = "ìƒì"; symbol = "ğŸ"; }
        else if (type === ITEM_TYPE.BUILDING_CAMP) { bgColor = "#795548"; label = "ìº í”„"; symbol = "â›º"; }
        else if (type === ITEM_TYPE.ITEM_GOLD) { bgColor = "#FFD700"; label = "ê³¨ë“œ"; symbol = "ğŸ’°"; }
        else if (type === ITEM_TYPE.ITEM_ENERGY) { bgColor = "#00E5FF"; label = "ì—ë„ˆì§€"; symbol = "âš¡"; }
        else if (type === ITEM_TYPE.ITEM_CRYSTAL) { bgColor = "#E040FB"; label = "ìˆ˜ì •"; symbol = "ğŸ’"; }
        else if (type === ITEM_TYPE.UNIT_INFANTRY) { bgColor = "#fff"; label = "ë³´ë³‘"; symbol = "ğŸ›¡ï¸"; }
        else if (type === ITEM_TYPE.UNIT_ARCHER) { bgColor = "#c8e6c9"; label = "ê¶ë³‘"; symbol = "ğŸ¹"; }
        else if (type === ITEM_TYPE.UNIT_CAVALRY) { bgColor = "#bbdefb"; label = "ê¸°ë³‘"; symbol = "ğŸ"; }

        // Draw Box
        this.ctx.fillStyle = bgColor;
        this.roundRect(dx, dy, drawSize, drawSize, 10);
        this.ctx.fill();
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = "rgba(0,0,0,0.3)";
        this.ctx.stroke();

        // 2. Name Label (Top)
        this.ctx.fillStyle = "black";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "top";
        // ê±´ë¬¼ì€ í…ìŠ¤íŠ¸ê°€ ì˜ ë³´ì´ê²Œ, ìœ ë‹›ì€ ì‘ê²Œ
        if (type < 10) this.ctx.fillStyle = "white"; 
        this.ctx.fillText(label, cx, dy + 5);

        // 3. Center Symbol
        this.ctx.font = "24px sans-serif";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText(symbol, cx, cy);

        // 4. Level Number (Bottom)
        if ((type >= 10 && type < 20) || type >= 20) {
            this.ctx.fillStyle = "black";
            this.ctx.font = "bold 16px sans-serif";
            this.ctx.textBaseline = "bottom";
            this.ctx.fillText(level, cx, dy + drawSize - 5);
        }

        // Camp Stored Indicator
        if (type === ITEM_TYPE.BUILDING_CAMP && item.storedUnit) {
            this.ctx.fillStyle = "white";
            this.ctx.strokeStyle = "black";
            this.ctx.lineWidth = 3;
            this.ctx.strokeText("IN", cx + 15, cy + 15);
            this.ctx.fillText("IN", cx + 15, cy + 15);
        }

        this.ctx.shadowBlur = 0;
    }

    roundRect(x, y, w, h, r) {
        this.ctx.beginPath();
        this.ctx.moveTo(x + r, y);
        this.ctx.arcTo(x + w, y, x + w, y + h, r);
        this.ctx.arcTo(x + w, y + h, x, y + h, r);
        this.ctx.arcTo(x, y + h, x, y, r);
        this.ctx.arcTo(x, y, x + w, y, r);
        this.ctx.closePath();
    }

    // --- Helpers ---
    showToast(msg) {
        const el = document.getElementById('toast');
        el.innerText = msg; el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 1000);
    }
    updateUI() {
        document.getElementById('energy-display').innerText = this.energy;
        document.getElementById('gold-display').innerText = this.gold;
    }
    cheatEnergy() { this.energy+=30; this.updateUI(); }
    spawnChest() {
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) 
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.grid[r][c] = {type: ITEM_TYPE.BUILDING_CHEST, level:1, scale:0}; return;
            }
    }
    spawnCamp() {
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) 
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.grid[r][c] = {type: ITEM_TYPE.BUILDING_CAMP, level:1, scale:0}; return;
            }
    }
}

const game = new Game();
</script>
</body>
</html>