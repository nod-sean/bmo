<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KOV - Field Objects Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
/* ... (기존 스타일 유지) ... */
* {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

body {
    background-color: #000;
    touch-action: none;
    font-family: 'Segoe UI', sans-serif;
    overflow: hidden;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100vw;
    height: 100dvh;
}

#game-container {
    position: relative;
    background-color: #4e342e;
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
    width: 100%;
    min-height: 22px;
    height: 100%;
    max-width: 56.25vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Header */
.header-panel {
    flex: 0 0 auto;
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.0));
    color: white;
    padding: 6px 8px;
    /* Reduced padding */
    padding-top: max(6px, env(safe-area-inset-top));
    z-index: 20;
    overflow-x: auto;
    /* Allow scroll if needed, or hidden */
    scrollbar-width: none;
    /* Hide scrollbar */
}

.res-pill {
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #555;
    border-radius: 99px;
    padding: 2px 8px;
    /* Reduced padding */
    display: flex;
    align-items: center;
    gap: 4px;
    /* Reduced gap */
    font-weight: bold;
    font-size: 11px;
    /* Reduced font size */
    color: #fff;
    cursor: pointer;
    transition: transform 0.1s;
    white-space: nowrap;
    /* Prevent wrapping */
}

.res-pill:active {
    transform: scale(0.95);
    background: rgba(255, 255, 255, 0.1);
}

.res-icon {
    width: 18px;
    height: 18px;
    object-fit: contain;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* Canvas */
#canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
    background-color: #3e2723;
    width: 100%;
    min-height: 22px;
}

canvas {
    display: block;
    width: 100%;
    min-height: 22px;
    height: 100%;
    image-rendering: pixelated;
}

/* Footer */
.footer-panel {
    flex: 0 0 auto;
    background: #d7ccc8;
    border-top: 4px solid #8d6e63;
    padding: 8px 12px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    display: flex;
    align-items: center;
    justify-content: space-between;
    min-height: 90px;
    z-index: 20;
}

.info-box {
    flex: 1;
    background: #f5f5f5;
    border: 1px solid #8d6e63;
    border-radius: 6px;
    padding: 4px 8px;
    height: 60px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    color: #3e2723;
    margin: 0 6px;
    overflow: hidden;
    color: #3e2723;
    margin: 0 6px;
    overflow: hidden;
    display: none;
    /* Force hidden by default */
}

.modal-overlay.open {
    display: flex;
}

.stat-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2px;
    font-size: 10px;
    font-weight: bold;
    color: #444;
    margin-top: 2px;
}

/* Action Buttons */
.action-btn {
    width: 56px;
    height: 56px;
    background: linear-gradient(to bottom, #ffca28, #ff6f00);
    border: 1px solid #e65100;
    border-radius: 10px;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 3px 0 #bf360c, 0 5px 5px rgba(0, 0, 0, 0.3);
    transition: all 0.1s;
    position: relative;
    padding-bottom: 2px;
}

.action-btn:active {
    transform: translateY(3px);
    box-shadow: 0 0 0 #bf360c, 0 0 0 rgba(0, 0, 0, 0);
    border-bottom-width: 0;
}

.world-btn {
    background: linear-gradient(to bottom, #42a5f5, #1565c0);
    border-color: #0d47a1;
    box-shadow: 0 3px 0 #0d47a1, 0 5px 5px rgba(0, 0, 0, 0.3);
}

.world-btn:active {
    box-shadow: 0 0 0 #0d47a1;
}

.build-btn {
    background: linear-gradient(to bottom, #8d6e63, #5d4037);
    border-color: #3e2723;
    box-shadow: 0 3px 0 #3e2723, 0 5px 5px rgba(0, 0, 0, 0.3);
}

.build-btn:active {
    box-shadow: 0 0 0 #3e2723;
}

.btn-icon {
    font-size: 22px;
    line-height: 1;
    margin-bottom: 2px;
    filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.2));
}

.btn-label {
    font-size: 11px;
    font-weight: bold;
    line-height: 1;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.4);
    letter-spacing: -0.5px;
}

/* Modals & Popups */
.modal-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
    backdrop-filter: blur(2px);
}

.modal-overlay.open {
    opacity: 1;
    pointer-events: auto;
}

.modal-content {
    background: #3e2723;
    border: 2px solid #8d6e63;
    border-radius: 12px;
    padding: 20px;
    width: 85%;
    max-width: 320px;
    text-align: center;
    color: white;
    transform: scale(0.9);
    transition: transform 0.2s;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
}

.modal-overlay.open .modal-content {
    transform: scale(1);
}

.modal-content.wide {
    max-width: 360px;
}

.close-modal {
    position: absolute;
    top: 10px;
    right: 15px;
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
    z-index: 10;
}

.close-modal:hover {
    color: #fff;
}

#field-modal {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    min-height: 22px;
    height: 100%;
    background: #222;
    z-index: 90;
    transform: translateY(100%);
    transition: transform 0.3s ease-out;
    display: flex;
    flex-direction: column;
    color: white;
}

#field-modal.open {
    transform: translateY(0);
}

.shop-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    overflow-y: auto;
    padding: 10px;
}

.shop-item {
    background: #4e342e;
    border: 2px solid #8d6e63;
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
}

.toggle-switch {
    width: 40px;
    height: 20px;
    background: #555;
    border-radius: 20px;
    position: relative;
    transition: 0.3s;
}

.toggle-switch.on {
    background: #4caf50;
}

.toggle-knob {
    width: 16px;
    height: 16px;
    background: #fff;
    border-radius: 50%;
    position: absolute;
    top: 2px;
    left: 2px;
    transition: 0.3s;
}

.toggle-switch.on .toggle-knob {
    left: 22px;
}

:root {
    --cloud-img: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc2NCcgaGVpZ2h0PSc2NCcgdmlld0JveD0nMCAwIDY0IDY0Jz48ZyBmaWxsPScjZjhmOGY4Jz48ZWxsaXBzZSBjeD0nMTgnIGN5PSczNicgcng9JzE4JyByeT0nMTInLz48ZWxsaXBzZSBjeD0nMzInIGN5PScyNicgcng9JzIyJyByeT0nMTQnLz48ZWxsaXBzZSBjeD0nNDgnIGN5PSczNCcgcng9JzE4JyByeT0nMTInLz48cmVjdCB4PSc2JyB5PSczMCcgd2lkdGg9JzUyJyBoZWlnaHQ9JzIyJyByeD0nMTEnLz48L2c+PGcgZmlsbD0nI2VkZWRlZCc+PGVsbGlwc2UgY3g9JzI0JyBjeT0nNDAnIHJ4PScxNicgcnk9JzEwJy8+PGVsbGlwc2UgY3g9JzQwJyBjeT0nMzgnIHJ4PScxNicgcnk9JzEwJy8+PC9nPjwvc3ZnPg==");
}

/* Field Styles */
.field-cell {
    width: 12px;
    height: 12px;
    transition: all 0.2s;
    border-radius: 1px;
    position: relative;
    z-index: 10;
    overflow: hidden;
}

.field-occupied {
    border: 1px solid #42a5f5;
    box-shadow: 0 0 2px #42a5f5;
    z-index: 10;
    opacity: 1.0 !important;
}

.field-target {
    outline: 1px solid #ffd700;
    box-shadow: 0 0 4px #ffd700;
    z-index: 15;
}

.field-selected {
    outline: 2px solid #22d3ee;
    box-shadow: 0 0 6px rgba(34, 211, 238, 0.9);
    z-index: 16;
}

.field-path {
    outline: 1px solid rgba(255, 255, 255, 0.5);
    background: rgba(255, 255, 255, 0.08);
    z-index: 12;
}

.field-wall {
    background-color: #8b5a3c !important;
    background-image:
        linear-gradient(0deg, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.12)),
        repeating-linear-gradient(90deg, rgba(0, 0, 0, 0.18) 0 1px, transparent 1px 6px),
        repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.18) 0 1px, transparent 1px 6px),
        repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.12) 0 1px, transparent 1px 12px);
    background-size: 100% 100%, 6px 6px, 6px 6px, 12px 12px;
    background-position: 0 0, 0 0, 0 0, 3px 3px;
    border: 1px solid rgba(0, 0, 0, 0.25);
    box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.35);
}

.field-wall::after {
    content: '🧱';
    font-size: 9px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.45;
    filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45));
}

#path-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 15;
}

.path-line-bg {
    stroke: rgba(0, 0, 0, 0.6);
    stroke-width: 4;
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.path-line {
    stroke: #ffd700;
    stroke-width: 2;
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.field-badge {
    position: absolute;
    left: 50%;
    bottom: 0;
    transform: translate(-50%, 1px);
    padding: 0 1px;
    border-radius: 2px;
    font-size: 3px;
    font-weight: 700;
    line-height: 1;
    letter-spacing: -0.2px;
    color: #f8fafc;
    background: rgba(0, 0, 0, 0.2);
    z-index: 18;
    opacity: 0.4;
    pointer-events: none;
}

.field-badge.active {
    color: #d1fae5;
    background: rgba(34, 197, 94, 0.25);
}

.field-badge.inactive {
    color: #fee2e2;
    background: rgba(239, 68, 68, 0.2);
}

.field-time {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(4px, 0.5vw, 6px);
    font-weight: 700;
    color: #ffe08a;
    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.75);
    pointer-events: none;
    letter-spacing: -0.35px;
    z-index: 25;
    line-height: 1;
    opacity: 0.5;
    transform: translateY(var(--label-offset, -1px)) scale(var(--label-scale, 1));
    transform-origin: center bottom;
}

.field-time.lower {
    --label-offset: 0px;
}

.field-cell::after {
    z-index: 12;
}

.field-move-eligible {
    outline: 1px dashed rgba(255, 255, 255, 0.35);
}

.field-move-source {
    outline: 1px solid #4ade80;
    box-shadow: 0 0 4px rgba(74, 222, 128, 0.9);
}

/* --- Phase 4: Social & BM Styles --- */

/* Header Profile */
.header-profile {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 48px;
    height: 48px;
    background: #2a2a2a;
    border: 2px solid #fbbf24;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
}

.header-profile .avatar {
    font-size: 28px;
}

.header-profile .level-badge {
    position: absolute;
    bottom: -6px;
    right: -6px;
    background: #dc2626;
    color: white;
    font-size: 10px;
    font-weight: bold;
    padding: 2px 5px;
    border-radius: 99px;
    border: 1px solid white;
}

/* Adjust Header Padding for Profile */
.header-panel {
    padding-left: 65px;
    position: relative;
}

/* Chat Floating Button */
.chat-float-btn {
    position: absolute;
    bottom: 110px;
    left: 16px;
    right: auto;
    width: 48px;
    height: 48px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #60a5fa;
    border-radius: 50%;
    color: white;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 90;
    backdrop-filter: blur(4px);
    transition: transform 0.2s;
}

.chat-float-btn:active {
    transform: scale(0.9);
}

/* Chat Drawer */
.chat-drawer {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 45%;
    background: rgba(17, 24, 39, 0.95);
    border-top: 2px solid #4b5563;
    z-index: 100;
    display: flex;
    flex-direction: column;
    transform: translateY(110%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
}

.chat-drawer.open {
    transform: translateY(0);
}

.chat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: #1f2937;
    border-bottom: 1px solid #374151;
    font-weight: bold;
    color: #e5e7eb;
}

.chat-tabs {
    display: flex;
    background: #111827;
}

.chat-tabs button {
    flex: 1;
    padding: 10px;
    background: transparent;
    color: #9ca3af;
    border: none;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
}

.chat-tabs button.active {
    color: #60a5fa;
    border-bottom-color: #60a5fa;
    background: rgba(96, 165, 250, 0.1);
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.chat-line {
    font-size: 13px;
    color: #ffffff !important;
    line-height: 1.4;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
}

.chat-line .sender {
    color: #fbbf24;
    font-weight: bold;
    margin-right: 4px;
}

.chat-line.me {
    text-align: right;
}

.chat-line.me .sender {
    display: none;
}

.chat-line.me .text {
    background: #1e40af;
    color: white;
    padding: 4px 10px;
    border-radius: 12px 12px 0 12px;
    display: inline-block;
}

.chat-input-area {
    padding: 10px;
    background: #1f2937;
    display: flex;
    gap: 8px;
}

.chat-input-area input {
    flex: 1;
    background: #374151;
    border: 1px solid #4b5563;
    border-radius: 4px;
    color: white;
    padding: 8px;
}

.chat-input-area button {
    padding: 8px 16px;
    background: #2563eb;
    color: white;
    border-radius: 4px;
    font-weight: bold;
}

/* Profile View */
.profile-view {
    padding: 20px;
    text-align: center;
}

.profile-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin-bottom: 24px;
}

.profile-avatar-lg {
    width: 80px;
    height: 80px;
    background: #2a2a2a;
    border: 3px solid #fbbf24;
    border-radius: 16px;
    font-size: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.profile-info h3 {
    margin: 0;
    font-size: 20px;
    color: white;
    display: flex;
    align-items: center;
    gap: 8px;
}

.profile-info p {
    margin: 4px 0 0;
    color: #9ca3af;
    font-size: 14px;
}

.edit-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
}

.profile-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 24px;
}

.stat-box {
    background: #374151;
    padding: 12px;
    border-radius: 8px;
}

.stat-box div {
    color: #9ca3af;
    font-size: 12px;
    margin-bottom: 4px;
}

.stat-box span {
    color: #fbbf24;
    font-size: 18px;
    font-weight: bold;
}

.profile-actions {
    display: flex;
    gap: 10px;
}

.btn-action {
    flex: 1;
    padding: 12px;
    background: #4b5563;
    color: white;
    border-radius: 8px;
    font-weight: bold;
}

.shop-tabs {
    display: flex;
    gap: 5px;
    margin-bottom: 10px;
    padding: 0 5px;
}

.shop-tab {
    flex: 1;
    padding: 8px;
    background: #374151;
    color: #9ca3af;
    border-radius: 6px;
    font-size: 12px;
}

.shop-tab.active {
    background: #fbbf24;
    color: #111827;
    font-weight: bold;
}

/* Fog of War */
.field-fog {
    background-color: #0b0b0b !important;
    border: none;
    cursor: default;
    z-index: 100;
    opacity: 1 !important;
}

.field-cloud-blocked {
    z-index: 14;
    background-color: transparent;
}

.field-cloud-layer {
    position: absolute;
    inset: 0;
    background-image: var(--cloud-img);
    background-repeat: no-repeat;
    background-size: 100% 100%;
    background-position: center;
    pointer-events: none;
    z-index: 30;
    filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.25));
}

.field-bottom-bar {
    position: absolute;
    left: 8px;
    right: 8px;
    bottom: 8px;
    background: rgba(15, 15, 15, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.18);
    border-radius: 10px;
    padding: 8px 8px;
    display: flex;
    align-items: flex-start;
    gap: 8px;
    z-index: 80;
    pointer-events: auto;
    max-height: 38vh;
    overflow: hidden;
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
    backdrop-filter: blur(2px);
}

.field-bottom-icon {
    width: 26px;
    height: 26px;
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.08);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #f8fafc;
    flex: 0 0 auto;
    overflow: hidden;
}

.field-bottom-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.field-bottom-text {
    display: flex;
    flex-direction: column;
    min-width: 0;
    flex: 1;
    gap: 4px;
}

.field-bottom-header {
    display: grid;
    grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
    gap: 10px;
    align-items: start;
}

.field-bottom-header-left {
    display: flex;
    flex-direction: column;
    gap: 2px;
    min-width: 0;
}

.field-bottom-header-right {
    display: flex;
    flex-direction: column;
    gap: 2px;
    min-width: 0;
}

.field-bottom-name {
    font-size: clamp(12px, 2.2vw, 14px);
    color: #f8fafc;
    font-weight: bold;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.field-bottom-meta {
    font-size: clamp(10px, 1.6vw, 12px);
    color: #cbd5f5;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.field-bottom-grid {
    display: grid;
    grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
    gap: 10px;
    align-items: start;
}

.field-bottom-grid>.field-bottom-details {
    min-width: 0;
}

.field-bottom-details {
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: clamp(10px, 1.4vw, 12px);
    color: #e5e7eb;
    max-height: 20vh;
    overflow: auto;
    padding-right: 2px;
    line-height: 1.3;
}

.field-bottom-section-title {
    font-size: clamp(10px, 1.5vw, 12px);
    color: #fbbf24;
    font-weight: 700;
    letter-spacing: -0.2px;
}

.field-bottom-summary {
    font-size: clamp(11px, 1.6vw, 13px);
    color: #f8fafc;
    font-weight: 600;
}

.field-bottom-divider {
    height: 1px;
    background: rgba(255, 255, 255, 0.08);
    margin: 2px 0;
}

.field-bottom-details .field-info-row {
    font-size: inherit;
}

.field-bottom-details .field-info-small {
    font-size: clamp(9px, 1.2vw, 11px);
    color: #9ca3af;
    width: 100%;
    min-height: 22px;
}

.field-bottom-bar .field-info-row {
    display: grid;
    grid-template-columns: minmax(64px, 90px) 1fr;
    align-items: center;
    gap: 6px;
    justify-content: start;
}

.field-bottom-bar .field-info-row span {
    text-align: left;
}

.field-bottom-bar .field-info-row span:first-child {
    color: #a7b0c8;
}

.field-bottom-bar .field-info-row span:last-child {
    color: #e5e7eb;
}

.field-bottom-bar .field-info-small {
    color: #94a3b8;
}

.field-bottom-move {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

#field-move-options {
    padding-left: 8px;
    border-left: 1px solid rgba(255, 255, 255, 0.08);
}

@media (max-width: 520px) {
    .field-eta-btn {
        padding: 2px 6px;
        font-size: clamp(9px, 2.2vw, 11px);
    }
}

@media (max-width: 360px) {
    .field-bottom-bar {
        bottom: 8px;
        padding: 9px 10px;
        max-height: 42vh;
    }

    .field-bottom-grid {
        grid-template-columns: 1fr;
    }
}

/* Object Icons */
.field-gate {
    border: 1px solid #ef4444;
}

.field-gate.locked::after {
    content: '🔒';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-gate.unlocked::after {
    content: '👐';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-castle::after {
    content: '🏰';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-fortress::after {
    content: '🏯';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-citadel::after {
    content: '🏯';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-dragon::after {
    content: '🐉';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-shop::after {
    content: '🛒';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-tavern::after {
    content: '🍺';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-ruins::after {
    content: '🏛️';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-statue::after {
    content: '🗿';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* New Objects: Gold Mine & Fountain */
.field-goldmine::after {
    content: '⛏️';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-fountain::after {
    content: '⛲';
    font-size: 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.field-move-info {
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 11px;
    color: #f8fafc;
    display: flex;
    justify-content: space-between;
    gap: 6px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
}

.field-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: 60;
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 6px 8px 0;
    pointer-events: none;
}

.field-overlay>* {
    pointer-events: auto;
}

.field-effect-log {
    background: rgba(0, 0, 0, 0.55);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 10px;
    color: #e5e7eb;
    display: none;
    flex-direction: column;
    gap: 2px;
    width: min(240px, 78vw);
}

.field-effect-log .title {
    font-weight: bold;
    color: #fbbf24;
    font-size: 10px;
}

.field-effect-log .entry {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.field-floating-wrap {
    position: relative;
    z-index: 70;
    display: none;
    flex-direction: column;
    gap: 6px;
    width: min(240px, 78vw);
    pointer-events: auto;
    align-self: flex-start;
}

.field-info-panel {
    background: rgba(20, 20, 20, 0.94);
    border: 1px solid rgba(255, 255, 255, 0.18);
    border-radius: 8px;
    padding: 8px 10px;
    margin-bottom: 0;
    font-size: 12px;
    color: #fff;
    transform: translateY(6px) scale(0.98);
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: transform 0.2s ease, opacity 0.2s ease, max-height 0.2s ease;
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.4);
}

.field-info-panel.open {
    transform: translateY(0) scale(1);
    opacity: 1;
    max-height: 240px;
}

.field-info-title {
    font-weight: bold;
    color: #ffd700;
    font-size: 13px;
    margin-bottom: 4px;
}

.field-info-row {
    display: flex;
    justify-content: space-between;
    gap: 8px;
}

.field-info-small {
    font-size: 11px;
    color: #ccc;
    margin-top: 4px;
}

.field-move-options {
    margin-top: 6px;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.field-eta-btn {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.12);
    color: #e5e7eb;
    padding: 3px 6px;
    border-radius: 6px;
    font-size: clamp(9px, 1.1vw, 11px);
    text-align: left;
    width: 100%;
    min-height: 22px;
}

.field-eta-btn.active {
    border-color: #fbbf24;
    color: #fbbf24;
    box-shadow: 0 0 0 1px rgba(251, 191, 36, 0.4);
}

.field-eta-btn.disabled {
    opacity: 0.5;
}

.field-eta-btn span {
    white-space: nowrap;
}

.field-eta-btn span:last-child {
    overflow: hidden;
    text-overflow: ellipsis;
}

.field-eta-btn.field-info-row {
    grid-template-columns: 30px 1fr;
}

.field-action-btn.disabled {
    opacity: 0.5;
}

.field-info-bar {
    height: 6px;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 2px;
}

.field-info-bar-fill {
    height: 100%;
    background: #fbbf24;
}

.shop-list {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-top: 8px;
}

.shop-card {
    background: #2b2b2b;
    border: 1px solid #4b4b4b;
    border-radius: 10px;
    padding: 8px;
    text-align: left;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-height: 92px;
}

.shop-card .name {
    font-weight: bold;
    color: #f8fafc;
}

.shop-card .meta {
    color: #cbd5f5;
    font-size: 10px;
    min-height: 18px;
}

.shop-card .level {
    color: #94a3b8;
    font-size: 10px;
}

.shop-card .price-btn {
    align-self: stretch;
    background: #f59e0b;
    color: #111827;
    border-radius: 8px;
    padding: 6px 0;
    font-weight: bold;
    font-size: 11px;
    margin-top: auto;
}

.shop-card .price-btn:active {
    transform: scale(0.98);
}

.shop-card.disabled {
    opacity: 0.45;
}

.shop-card.disabled .price-btn {
    background: #374151;
    color: #9ca3af;
}

.shop-icon {
    width: 26px;
    height: 26px;
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.08);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.shop-icon-img {
    width: 100%;
    min-height: 22px;
    height: 100%;
    object-fit: contain;
}

.shop-row {
    display: flex;
    align-items: center;
    gap: 6px;
}

.shop-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
}

.shop-title {
    font-weight: bold;
    color: #f8fafc;
}

.shop-refresh {
    color: #9ca3af;
    font-size: 10px;
}

.shop-card.restock {
    animation: restockPulse 0.8s ease-out;
    box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.6);
}

@keyframes restockPulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.0);
    }

    50% {
        transform: scale(1.03);
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.5);
    }

    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.0);
    }
}

.field-action-menu {
    position: absolute;
    background: rgba(15, 15, 15, 0.95);
    border: 1px solid #666;
    border-radius: 8px;
    padding: 6px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 120;
    min-width: 90px;
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.5);
}

.field-action-btn {
    background: #2f2f2f;
    border: 1px solid #555;
    color: #fff;
    padding: 6px 8px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
}

.field-action-btn:active {
    transform: scale(0.97);
}

#income-float {
    position: absolute;
    color: #ffd700;
    font-weight: bold;
    font-size: 12px;
    pointer-events: none;
    animation: floatUp 1s forwards;
    z-index: 200;
    text-shadow: 1px 1px 0 #000;
}

@keyframes floatUp {
    0% {
        transform: translateY(0);
        opacity: 1;
    }

    100% {
        transform: translateY(-20px);
        opacity: 0;
    }
}

.join-float {
    position: absolute;
    left: 50%;
    bottom: 18%;
    transform: translateX(-50%);
    color: #4ade80;
    font-weight: bold;
    font-size: 12px;
    pointer-events: none;
    animation: floatUp 1s forwards;
    z-index: 220;
    text-shadow: 1px 1px 0 #000;
}

#toast {
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: #fff;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 200;
    border: 2px solid #ffd700;
    white-space: nowrap;
    pointer-events: none;
}

/* Army Marker */
.army-marker {
    position: absolute;
    width: 12px;
    height: 12px;
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
    transition: transform 0.1s linear;
    z-index: 50;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 8px;
    font-weight: bold;
    color: black;
    overflow: visible;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.army-marker.selected {
    box-shadow: 0 0 15px 2px #ffd700;
    transform: scale(1.3);
    z-index: 51;
}

.squad-selector {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(30, 30, 30, 0.95);
    border: 2px solid #8d6e63;
    border-radius: 12px;
    padding: 10px;
    display: flex;
    gap: 8px;
    z-index: 100;
    width: 90%;
    max-width: 300px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
}

.squad-card {
    flex: 1;
    background: #3e2723;
    border: 1px solid #555;
    border-radius: 8px;
    padding: 8px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}

.squad-card:active {
    transform: scale(0.95);
}

.squad-card.disabled {
    opacity: 0.5;
    pointer-events: none;
    filter: grayscale(1);
}

.squad-status {
    font-size: 10px;
    color: #aaa;
    margin-top: 2px;
}

.selected-army-hud {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(30, 30, 30, 0.9);
    border: 1px solid #ffd700;
    border-radius: 30px;
    padding: 8px 20px;
    z-index: 95;
    display: flex;
    gap: 15px;
    align-items: center;
    color: white;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
}

.hud-name {
    font-weight: bold;
    color: #ffd700;
    font-size: 14px;
}

.hud-btn {
    background: #d32f2f;
    border: none;
    border-radius: 12px;
    padding: 4px 12px;
    font-size: 10px;
    font-weight: bold;
    cursor: pointer;
    color: white;
}

#levelup-banner {
    position: absolute;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    z-index: 150;
    pointer-events: none;
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

#levelup-banner.show {
    transform: translate(-50%, -50%) scale(1);
}

.levelup-stat {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 5px;
}

.levelup-old {
    color: #aaa;
}

.levelup-arrow {
    color: #fbbf24;
    margin: 0 10px;
}

.levelup-new {
    color: #4ade80;
    font-weight: bold;
}

/* Battle System Styles */
#modal-battle .modal-content {
    max-width: 400px;
    padding: 10px;
}

.battle-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.battle-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #555;
    padding-bottom: 5px;
    margin-bottom: 5px;
}

.battle-stage {
    position: relative;
    width: 100%;
    height: 200px;
    background: #222;
    border: 1px solid #444;
    border-radius: 6px;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
}

.battle-stage.active {
    background: #331111;
}

.battle-log {
    height: 80px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.5);
    font-size: 10px;
    text-align: left;
    padding: 5px;
    border-top: 1px solid #444;
    width: 100%;
}

.battle-grid-check {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 4px;
    margin: 10px auto;
    width: 140px;
}

.battle-cell {
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px dashed #666;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    position: relative;
}

.battle-cell.enemy {
    border-color: #ef4444;
    background: rgba(239, 68, 68, 0.1);
}

.battle-cell.ally {
    border-color: #3b82f6;
    background: rgba(59, 130, 246, 0.1);
}

.battle-unit {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.battle-hp-bar {
    width: 90%;
    height: 4px;
    background: #444;
    margin-top: 2px;
    border-radius: 2px;
    overflow: hidden;
}

.battle-hp-fill {
    height: 100%;
    background: #ef4444;
}

.battle-cell.ally .battle-hp-fill {
    background: #3b82f6;
}

.battle-result-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    z-index: 50;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 15px;
}

.battle-result-text {
    font-size: 32px;
    font-weight: bold;
    text-shadow: 0 0 10px currentColor;
}

.battle-result-text.win {
    color: #ffd700;
}

.battle-result-text.lose {
    color: #ef4444;
}

.battle-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.battle-btn {
    padding: 8px 20px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 12px;
    cursor: pointer;
    border: none;
}

.battle-btn.start {
    background: #ef4444;
    color: white;
}

.battle-btn.close {
    background: #444;
    color: #ccc;
}

/* Battle Prep Styles */
.battle-cell.prep {
    cursor: grab;
    border-style: solid;
    background: rgba(255, 255, 255, 0.1);
}

.battle-cell.prep:active {
    cursor: grabbing;
}

.battle-cell.prep.empty {
    border: 1px dashed #555;
    background: rgba(0, 0, 0, 0.2);
}

.battle-cell.prep.ally:hover {
    border-color: #ffd700;
    background: rgba(255, 255, 255, 0.15);
}

/* Enemy prep cells are static */
.battle-cell.prep.enemy {
    cursor: default;
    opacity: 0.8;
}
</style>
</head>

<body>

    <div id="game-container">
        <div id="levelup-banner"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/levelup.png"
                onerror="this.style.display='none'"></div>

        <!-- Header -->
        <div class="header-panel">
            <div class="flex justify-between mb-1">
                <div class="res-pill" onclick="game.openRefill('energy')">
                    <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/energy.png" class="res-icon"
                        onerror="this.style.display='none';this.nextElementSibling.innerText='⚡'+this.nextElementSibling.innerText">
                    <span id="energy-display">50/50</span>
                    <span class="text-gray-400 text-[10px] ml-1">+</span>
                </div>
                <div class="res-pill" onclick="game.openRefill('cp')">
                    <span class="res-icon">🧭</span>
                    <span id="cp-display">20/20</span>
                    <span class="text-gray-400 text-[10px] ml-1">+</span>
                </div>
                <div class="res-pill" onclick="game.openRefill('gold')">
                    <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/gold.png" class="res-icon"
                        onerror="this.style.display='none';this.nextElementSibling.innerText='💰'+this.nextElementSibling.innerText">
                    <span id="gold-display">3000</span>
                    <span class="text-gray-400 text-[10px] ml-1">+</span>
                </div>
                <div class="res-pill" onclick="game.openRefill('crystal')">
                    <img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/crystal.png" class="res-icon"
                        onerror="this.style.display='none';this.nextElementSibling.innerText='💎'+this.nextElementSibling.innerText">
                    <span id="gem-display">50</span>
                    <span class="text-gray-400 text-[10px] ml-1">+</span>
                </div>
            </div>
            <div class="flex flex-col w-full">
                <div class="flex justify-between items-end px-1">
                    <span class="font-bold text-yellow-400 text-xs" id="level-display">LORD LV.1</span>
                    <span class="font-bold text-gray-300 text-xs flex items-center gap-1"><span id="xp-text">0 /
                            10</span> XP</span>
                </div>
                <div class="w-full bg-gray-800 h-2 mt-1 rounded-full overflow-hidden border border-gray-600 relative">
                    <div id="xp-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
                </div>
            </div>
            <!-- Dev Tools -->
            <!-- Dev Tools -->
            <div class="flex gap-2 mt-1 opacity-30 hover:opacity-100 transition-opacity justify-end items-center"
                style="display:none;">
                <button onclick="game.resetGame()"
                    class="bg-red-800 text-white px-2 py-1 rounded text-[10px] border border-red-500 hover:bg-red-600">🔄리셋</button>
                <button onclick="game.cheatEnergy()"
                    class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">⚡+30</button>
                <button onclick="game.spawnChest()"
                    class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">🎁상자</button>
                <button onclick="game.cheatLevelUp()"
                    class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">⬆️LvUP</button>
            </div>
        </div>

        <!-- Main Canvas -->
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- Footer -->
        <div class="footer-panel">
            <button class="action-btn chat-btn bg-gray-700 border-gray-600" id="chat-btn" onclick="game.toggleChat()">
                <span class="text-2xl filter drop-shadow">💬</span>
            </button>
            <div class="info-box" id="info-panel">
                <div class="flex justify-between items-center"><span class="font-bold text-sm truncate"
                        id="info-name">선택 없음</span><span class="text-[10px] text-gray-500 font-bold"
                        id="info-class"></span></div>
                <div class="stat-grid hidden" id="unit-stats-grid">
                    <div class="stat-item">❤<span id="st-hp">0</span></div>
                    <div class="stat-item">⚔<span id="st-atk">0</span></div>
                    <div class="stat-item">🛡️<span id="st-def">0</span></div>
                    <div class="stat-item">🦶<span id="st-spd">0</span></div>
                    <div class="stat-item">🎯<span id="st-rng">0</span></div>
                    <div class="stat-item">🏃<span id="st-mov">0</span></div>
                </div>
                <div class="text-[10px] text-gray-600 truncate mt-1" id="info-desc">오브젝트를 선택하세요.</div>
            </div>

            <button class="action-btn" id="btn-action" onclick="game.handleAction()">
                <span class="btn-icon" id="action-icon">💰</span>
                <span class="btn-label" id="action-label">Sell</span>
            </button>
            <button class="action-btn build-btn" style="margin-left:5px;" onclick="game.toggleShop()">
                <span class="btn-icon">🏠</span>
                <span class="btn-label">건설</span>
            </button>
            <button class="action-btn world-btn" style="margin-left:5px;" onclick="game.toggleField()">
                <span class="btn-icon">🌍</span>
                <span class="btn-label">필드</span>
            </button>
        </div>

        <!-- Modals -->
        <div id="field-modal">
            <div class="flex justify-between items-center px-3 py-2 border-b border-gray-600 bg-gray-900">
                <h2 class="text-lg font-bold text-yellow-400" id="modal-title">메뉴</h2>
                <button onclick="game.closeModal()" class="w-7 h-7 text-gray-400 font-bold text-sm">✖</button>
            </div>
            <div class="flex-1 overflow-auto bg-gray-800 p-2 relative" id="modal-content"></div>
        </div>

        <div id="modal-levelup" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-2xl font-bold text-yellow-400 mb-4">LEVEL UP!</h2>
                <div class="text-6xl mb-4">🆙</div>
                <div class="bg-gray-800 rounded p-4 mb-4 text-left text-sm">
                    <div class="levelup-stat">
                        <span>레벨 (Lord Level)</span>
                        <span><span id="lv-old" class="levelup-old">1</span> <span class="levelup-arrow">▶</span> <span
                                id="lv-new" class="levelup-new">2</span></span>
                    </div>
                    <div class="levelup-stat" style="border:none">
                        <span>최대 에너지</span>
                        <span><span id="en-old" class="levelup-old">50</span> <span class="levelup-arrow">▶</span> <span
                                id="en-new" class="levelup-new">52</span></span>
                    </div>
                </div>
                <button onclick="document.getElementById('modal-levelup').classList.remove('open')"
                    class="w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-lg font-bold">확인</button>
            </div>
        </div>

        <div id="modal-refill" class="modal-overlay">
            <div class="modal-content">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold text-white" id="refill-title">리소스 충전</h2>
                    <button onclick="document.getElementById('modal-refill').classList.remove('open')"
                        class="text-gray-400">✖</button>
                </div>
                <div id="refill-options" class="grid gap-3"></div>
            </div>
        </div>

        <div id="modal-settings" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-xl font-bold text-gray-200 mb-6">설정 (Settings)</h2>
                <div class="space-y-4 text-left">
                    <div class="flex justify-between items-center bg-gray-800 p-3 rounded">
                        <span>배경음악 (BGM)</span>
                        <div class="toggle-switch on" onclick="game.toggleSetting('bgm', this)">
                            <div class="toggle-knob"></div>
                        </div>
                    </div>
                    <div class="flex justify-between items-center bg-gray-800 p-3 rounded">
                        <span>효과음 (SFX)</span>
                        <div class="toggle-switch on" onclick="game.toggleSetting('sfx', this)">
                            <div class="toggle-knob"></div>
                        </div>
                    </div>
                    <div class="bg-gray-800 p-3 rounded text-xs text-gray-400">
                        <p>UID: <span id="settings-uid" class="text-gray-200">User_1234</span></p>
                        <p>Version: 0.3.3 (Hotfix: Data & Field Objects)</p>
                    </div>
                </div>
                <div class="mt-6 flex gap-2">
                    <button onclick="game.resetGame()"
                        class="flex-1 bg-red-800 py-2 rounded text-xs text-red-200 border border-red-600 hover:bg-red-700">계정
                        초기화</button>
                    <button onclick="document.getElementById('modal-settings').classList.remove('open')"
                        class="flex-1 bg-gray-600 py-2 rounded text-xs border border-gray-500 hover:bg-gray-500">닫기</button>
                </div>
            </div>
        </div>

        <div id="modal-object" class="modal-overlay">
            <div class="modal-content">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold text-white" id="object-modal-title">오브젝트</h2>
                    <button
                        onclick="document.getElementById('modal-object').classList.remove('open'); document.querySelector('#modal-object .modal-content')?.classList.remove('wide')"
                        class="text-gray-400">✖</button>
                </div>
                <div id="object-modal-body" class="text-left text-sm text-gray-200 space-y-2"></div>
                <button
                    onclick="document.getElementById('modal-object').classList.remove('open'); document.querySelector('#modal-object .modal-content')?.classList.remove('wide')"
                    class="w-full bg-gray-700 hover:bg-gray-600 py-2 rounded text-xs border border-gray-600 mt-4">닫기</button>
            </div>
        </div>

        <div id="modal-battle" class="modal-overlay">
            <div class="modal-content">
                <div class="battle-header">
                    <h2 class="text-lg font-bold text-red-500">⚔ BATTLE</h2>
                    <div class="text-xs text-gray-400" id="battle-target-name">Target</div>
                </div>
                <div class="battle-container">
                    <div class="battle-stage" id="battle-stage">
                        <div class="flex gap-8 items-center">
                            <div class="flex flex-col items-center">
                                <span class="text-blue-400 font-bold text-xs mb-1">ALLIES</span>
                                <div class="battle-grid-check" id="battle-grid-ally"></div>
                            </div>
                            <div class="text-2xl font-bold text-gray-500">VS</div>
                            <div class="flex flex-col items-center">
                                <span class="text-red-400 font-bold text-xs mb-1">ENEMIES</span>
                                <div class="battle-grid-check" id="battle-grid-enemy"></div>
                            </div>
                        </div>
                        <div class="battle-result-overlay" id="battle-result-overlay">
                            <div class="battle-result-text" id="battle-result-title">VICTORY</div>
                            <button onclick="game.closeBattleModal()" class="battle-btn close">닫기</button>
                        </div>
                    </div>
                    <div class="battle-log" id="battle-log"></div>
                    <div class="battle-controls" id="battle-controls">
                        <button class="battle-btn close" onclick="game.closeBattleModal()">취소</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="modal-battle-prep" class="modal-overlay">
            <div class="modal-content">
                <div class="battle-header">
                    <h2 class="text-lg font-bold text-yellow-400">전투 준비 (유닛 배치)</h2>
                    <div class="text-xs text-gray-400">드래그하여 위치를 변경하세요</div>
                </div>
                <div class="battle-container">
                    <div class="flex justify-around items-center w-full mb-4">
                        <div class="flex flex-col items-center">
                            <span class="text-blue-400 font-bold text-sm mb-2">아군 (Drag)</span>
                            <div class="battle-grid-check" id="prep-grid-ally"></div>
                        </div>
                        <div class="text-2xl font-bold text-gray-500">VS</div>
                        <div class="flex flex-col items-center">
                            <span class="text-red-400 font-bold text-sm mb-2">적군</span>
                            <div class="battle-grid-check" id="prep-grid-enemy"></div>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <button class="battle-btn close"
                            onclick="this.closest('.modal-overlay').classList.remove('open'); this.closest('.modal-overlay').style.display='none'; game.closeBattlePrepModal()">취소</button>
                        <button class="battle-btn start"
                            onclick="this.closest('.modal-overlay').classList.remove('open'); this.closest('.modal-overlay').style.display='none'; game.confirmBattleStart()">전투
                            개시!</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="toast">메시지</div>
    </div>

    <script>
class BattleSimulator {
    constructor() {
        this.log = [];
        this.maxTurns = 50;
    }

    // allies, defenders: Array of { hp, atk, def, spd, range, type, slot ... }
    simulate(allies, defenders) {
        const steps = []; // { type: 'log'|'attack', msg: string, attackerId: string, defenderId: string, damage: number, newHp: number }

        steps.push({ type: 'log', msg: "⚔️ 전투 시뮬레이션 시작" });

        // Working copies
        let teamA = allies.map(u => ({ ...u, team: 'A', id: `ally-${u.slot}`, currentHp: u.hp }));
        let teamB = defenders.map(u => ({ ...u, team: 'B', id: `enemy-${u.slot}`, currentHp: u.hp }));

        let turn = 0;
        let winner = null;

        while (turn < this.maxTurns) {
            turn++;
            steps.push({ type: 'log', msg: `\n[Turn ${turn}]` });

            // 1. Gather all live units
            let activeUnits = [...teamA, ...teamB].filter(u => u.currentHp > 0);
            if (activeUnits.length === 0) break;

            // 2. Sort by SPD (descending)
            activeUnits.sort((a, b) => b.spd - a.spd || (Math.random() - 0.5));

            // 3. Turn Execution
            for (const unit of activeUnits) {
                if (unit.currentHp <= 0) continue;

                // Select Targets
                const enemies = unit.team === 'A' ? teamB : teamA;
                const liveEnemies = enemies.filter(e => e.currentHp > 0);

                if (liveEnemies.length === 0) {
                    winner = unit.team === 'A' ? 'allies' : 'defenders';
                    break;
                }

                const target = this.selectTarget(unit, liveEnemies);
                if (target) {
                    this.attack(unit, target, steps);
                }
            }

            if (winner) break;

            if (teamA.every(u => u.currentHp <= 0)) { winner = 'defenders'; break; }
            if (teamB.every(u => u.currentHp <= 0)) { winner = 'allies'; break; }
        }

        if (!winner) {
            const hpA = teamA.reduce((s, u) => s + Math.max(0, u.currentHp), 0);
            const hpB = teamB.reduce((s, u) => s + Math.max(0, u.currentHp), 0);
            winner = hpA >= hpB ? 'allies' : 'defenders';
            steps.push({ type: 'log', msg: "최대 턴 도달! 판정승: " + winner });
        } else {
            steps.push({ type: 'log', msg: "승리: " + winner });
        }

        return {
            winner,
            steps,
            survivors: winner === 'allies' ? teamA : teamB
        };
    }

    selectTarget(attacker, enemies) {
        // Simple Logic: Pick random target from "Frontmost" available row
        // Sort enemies by slot (0..8)
        // Group by row: 0-2, 3-5, 6-8.
        // If range > 1, maybe can target back?
        // For MVP 3x3, let's just target the unit with smallest slot index (Front-Top priority) 
        // or random among the frontmost existing units.

        // Find min row index present
        const rows = [
            enemies.filter(e => e.slot >= 0 && e.slot <= 2),
            enemies.filter(e => e.slot >= 3 && e.slot <= 5),
            enemies.filter(e => e.slot >= 6 && e.slot <= 8)
        ];

        for (const row of rows) {
            if (row.length > 0) {
                // Found frontmost row with units. Pick random one.
                return row[Math.floor(Math.random() * row.length)];
            }
        }
        return enemies[0];
    }

    attack(attacker, defender, steps) {
        // Damage Formula
        // Base = Atk - (Def * 0.3)
        // Type Advantage: Infantry(10) > Cavalry(12) > Archer(11) > Infantry(10)
        // Metal(10) > Wood(11) > Earth(12) ? No, names are Unit Types.

        let multiplier = 1.0;
        const typeA = attacker.classType;
        const typeD = defender.classType;

        // Advantage Map
        // 10: Infantry, 11: Archer, 12: Cavalry
        // Inf > Cav (Wait, usually Inf > Cav? No, Spear > Cav. Sword > Axe...)
        // Standard Triangle: Cav > Arch > Inf > Cav? 
        // Roadmap: "보병 > 기병 > 궁병 > 보병" (Inf > Cav > Arch > Inf) -> wait, text says Inf > Cav.
        // Let's follow Roadmap Text: "보병 > 기병 > 궁병 > 보병"

        if (typeA === 10 && typeD === 12) multiplier = 1.3; // Inf > Cav
        else if (typeA === 12 && typeD === 11) multiplier = 1.3; // Cav > Arch
        else if (typeA === 11 && typeD === 10) multiplier = 1.3; // Arch > Inf

        else if (typeA === 12 && typeD === 10) multiplier = 0.8;
        else if (typeA === 11 && typeD === 12) multiplier = 0.8;
        else if (typeA === 10 && typeD === 11) multiplier = 0.8;

        // Calc Dmg
        let damage = Math.max(1, (attacker.atk * multiplier) - (defender.def * 0.5));

        let msg = `${attacker.name} -> ${defender.name}: ${Math.floor(damage)} 피해`;
        if (multiplier > 1.0) msg += " (우위)";
        else if (multiplier < 1.0) msg += " (열세)";

        // Crit
        if (Math.random() < 0.1) {
            damage *= 1.5;
            msg = `⚡ 치명타! ` + msg;
        }

        damage = Math.floor(damage);
        defender.currentHp -= damage;

        steps.push({
            type: 'attack',
            msg: msg,
            attackerId: attacker.id,
            defenderId: defender.id,
            damage: damage,
            targetHp: defender.currentHp
        });

        if (defender.currentHp <= 0) {
            steps.push({ type: 'log', msg: `💀 ${defender.name} 사망!` });
        }
    }
}

window.BattleSimulator = BattleSimulator;

</script>
    <script>
window.GAME_DATA = {
  "buildings": {
    "2101": {
      "code": 2101,
      "name": "barracks",
      "name_kr": "병영",
      "level": 1,
      "merge_max": 6,
      "energy": 1,
      "prob_1": 90,
      "prob_2": 10,
      "prob_3": 0,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2102": {
      "code": 2102,
      "name": "barracks",
      "name_kr": "병영",
      "level": 2,
      "merge_max": 7,
      "energy": 2,
      "prob_1": 0,
      "prob_2": 90,
      "prob_3": 10,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2103": {
      "code": 2103,
      "name": "barracks",
      "name_kr": "병영",
      "level": 3,
      "merge_max": 8,
      "energy": 3,
      "prob_1": 0,
      "prob_2": 45,
      "prob_3": 55,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2104": {
      "code": 2104,
      "name": "barracks",
      "name_kr": "병영",
      "level": 4,
      "merge_max": 9,
      "energy": 4,
      "prob_1": 0,
      "prob_2": 0,
      "prob_3": 90,
      "prob_4": 10,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2105": {
      "code": 2105,
      "name": "barracks",
      "name_kr": "병영",
      "level": 5,
      "merge_max": 10,
      "energy": 5,
      "prob_1": 0,
      "prob_2": 0,
      "prob_3": 80,
      "prob_4": 10,
      "prob_5": 10,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2201": {
      "code": 2201,
      "name": "Archery Range",
      "name_kr": "사격장",
      "level": 1,
      "merge_max": 6,
      "energy": 1,
      "prob_1": 90,
      "prob_2": 10,
      "prob_3": 0,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2202": {
      "code": 2202,
      "name": "Archery Range",
      "name_kr": "사격장",
      "level": 2,
      "merge_max": 7,
      "energy": 2,
      "prob_1": 0,
      "prob_2": 90,
      "prob_3": 10,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2203": {
      "code": 2203,
      "name": "Archery Range",
      "name_kr": "사격장",
      "level": 3,
      "merge_max": 8,
      "energy": 3,
      "prob_1": 0,
      "prob_2": 45,
      "prob_3": 55,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2204": {
      "code": 2204,
      "name": "Archery Range",
      "name_kr": "사격장",
      "level": 4,
      "merge_max": 9,
      "energy": 4,
      "prob_1": 0,
      "prob_2": 0,
      "prob_3": 90,
      "prob_4": 10,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2205": {
      "code": 2205,
      "name": "Archery Range",
      "name_kr": "사격장",
      "level": 5,
      "merge_max": 10,
      "energy": 5,
      "prob_1": 0,
      "prob_2": 0,
      "prob_3": 80,
      "prob_4": 10,
      "prob_5": 10,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2301": {
      "code": 2301,
      "name": "Stable",
      "name_kr": "마구간",
      "level": 1,
      "merge_max": 6,
      "energy": 1,
      "prob_1": 90,
      "prob_2": 10,
      "prob_3": 0,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2302": {
      "code": 2302,
      "name": "Stable",
      "name_kr": "마구간",
      "level": 2,
      "merge_max": 7,
      "energy": 2,
      "prob_1": 0,
      "prob_2": 90,
      "prob_3": 10,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2303": {
      "code": 2303,
      "name": "Stable",
      "name_kr": "마구간",
      "level": 3,
      "merge_max": 8,
      "energy": 3,
      "prob_1": 0,
      "prob_2": 45,
      "prob_3": 55,
      "prob_4": 0,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2304": {
      "code": 2304,
      "name": "Stable",
      "name_kr": "마구간",
      "level": 4,
      "merge_max": 9,
      "energy": 4,
      "prob_1": 0,
      "prob_2": 0,
      "prob_3": 90,
      "prob_4": 10,
      "prob_5": 0,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    },
    "2305": {
      "code": 2305,
      "name": "Stable",
      "name_kr": "마구간",
      "level": 5,
      "merge_max": 10,
      "energy": 5,
      "prob_1": 0,
      "prob_2": 0,
      "prob_3": 80,
      "prob_4": 10,
      "prob_5": 10,
      "prob_6": 0,
      "prob_7": 0,
      "prob_8": 0,
      "prob_9": 0,
      "prob_10": 0
    }
  },
  "camps": {
    "3101": {
      "code": 3101,
      "name": "camp",
      "name_kr": "막사",
      "level": 1,
      "capacity": 4
    },
    "3102": {
      "code": 3102,
      "name": "camp",
      "name_kr": "막사",
      "level": 2,
      "capacity": 6
    },
    "3103": {
      "code": 3103,
      "name": "camp",
      "name_kr": "막사",
      "level": 3,
      "capacity": 8
    },
    "3104": {
      "code": 3104,
      "name": "camp",
      "name_kr": "막사",
      "level": 4,
      "capacity": 12
    },
    "3105": {
      "code": 3105,
      "name": "camp",
      "name_kr": "막사",
      "level": 5,
      "capacity": 16
    }
  },
  "chests": {
    "2801": {
      "1801": 50,
      "1802": 0,
      "1803": 0,
      "1804": 0,
      "1805": 0,
      "1811": 50,
      "1812": 0,
      "1813": 0,
      "1814": 0,
      "1815": 0,
      "1821": 0,
      "1822": 0,
      "1823": 0,
      "1824": 0,
      "1825": 0,
      "code": 2801,
      "name": "Bronze Chest",
      "name_kr": "동 상자",
      "level": 1,
      "limit": 5
    },
    "2802": {
      "1801": 25,
      "1802": 25,
      "1803": 0,
      "1804": 0,
      "1805": 0,
      "1811": 25,
      "1812": 25,
      "1813": 0,
      "1814": 0,
      "1815": 0,
      "1821": 0,
      "1822": 0,
      "1823": 0,
      "1824": 0,
      "1825": 0,
      "code": 2802,
      "name": "Silver Chest",
      "name_kr": "은 상자",
      "level": 2,
      "limit": 5
    },
    "2803": {
      "1801": 20,
      "1802": 20,
      "1803": 10,
      "1804": 0,
      "1805": 0,
      "1811": 20,
      "1812": 20,
      "1813": 10,
      "1814": 0,
      "1815": 0,
      "1821": 0,
      "1822": 0,
      "1823": 0,
      "1824": 0,
      "1825": 0,
      "code": 2803,
      "name": "Gold Chest",
      "name_kr": "금 상자",
      "level": 3,
      "limit": 5
    },
    "2804": {
      "1801": 0,
      "1802": 20,
      "1803": 20,
      "1804": 5,
      "1805": 0,
      "1811": 0,
      "1812": 20,
      "1813": 20,
      "1814": 5,
      "1815": 0,
      "1821": 10,
      "1822": 0,
      "1823": 0,
      "1824": 0,
      "1825": 0,
      "code": 2804,
      "name": "Platinum Chest",
      "name_kr": "백금 상자",
      "level": 4,
      "limit": 5
    },
    "2805": {
      "1801": 0,
      "1802": 15,
      "1803": 20,
      "1804": 10,
      "1805": 0,
      "1811": 0,
      "1812": 15,
      "1813": 20,
      "1814": 10,
      "1815": 0,
      "1821": 5,
      "1822": 5,
      "1823": 0,
      "1824": 0,
      "1825": 0,
      "code": 2805,
      "name": "Diamond Chest",
      "name_kr": "다이아 상자",
      "level": 5,
      "limit": 5
    }
  },
  "constants": {
    "REFILL_DATA": {
      "energy": [
        {
          "energy_refill": 5,
          "crystal": 2,
          "ad": 0,
          "limit": 0
        },
        {
          "energy_refill": 10,
          "crystal": 4,
          "ad": 0,
          "limit": 0
        },
        {
          "energy_refill": 30,
          "crystal": 11,
          "ad": 0,
          "limit": 0
        },
        {
          "energy_refill": 50,
          "crystal": 18,
          "ad": 0,
          "limit": 0
        },
        {
          "energy_refill": 100,
          "crystal": 35,
          "ad": 0,
          "limit": 0
        },
        {
          "energy_refill": 3,
          "crystal": 0,
          "ad": 1,
          "limit": 3
        }
      ],
      "gold": [
        {
          "gold_refill": 5,
          "crystal": 2,
          "ad": 0,
          "limit": 0
        },
        {
          "gold_refill": 10,
          "crystal": 4,
          "ad": 0,
          "limit": 0
        },
        {
          "gold_refill": 30,
          "crystal": 11,
          "ad": 0,
          "limit": 0
        },
        {
          "gold_refill": 50,
          "crystal": 18,
          "ad": 0,
          "limit": 0
        },
        {
          "gold_refill": 100,
          "crystal": 35,
          "ad": 0,
          "limit": 0
        },
        {
          "gold_refill": 3,
          "crystal": 0,
          "ad": 1,
          "limit": 3
        }
      ],
      "cp": [
        {
          "cp_refill": 5,
          "crystal": 2,
          "ad": 0,
          "limit": 0
        },
        {
          "cp_refill": 10,
          "crystal": 4,
          "ad": 0,
          "limit": 0
        },
        {
          "cp_refill": 30,
          "crystal": 11,
          "ad": 0,
          "limit": 0
        },
        {
          "cp_refill": 50,
          "crystal": 18,
          "ad": 0,
          "limit": 0
        },
        {
          "cp_refill": 100,
          "crystal": 35,
          "ad": 0,
          "limit": 0
        },
        {
          "cp_refill": 3,
          "crystal": 0,
          "ad": 1,
          "limit": 3
        }
      ],
      "crystal": [
        {
          "code": 101,
          "crystal_refill": 10,
          "bonus": 0,
          "cost": 1
        },
        {
          "code": 102,
          "crystal_refill": 50,
          "bonus": 2,
          "cost": 5
        },
        {
          "code": 103,
          "crystal_refill": 100,
          "bonus": 5,
          "cost": 10
        },
        {
          "code": 104,
          "crystal_refill": 200,
          "bonus": 20,
          "cost": 20
        },
        {
          "code": 105,
          "crystal_refill": 500,
          "bonus": 75,
          "cost": 50
        },
        {
          "code": 106,
          "crystal_refill": 1000,
          "bonus": 200,
          "cost": 100
        }
      ]
    },
    "ABILITY_CODES": {},
    "BUILDING_LIMITS": {},
    "SHOP_DATA": [
      {
        "type": 2101,
        "name": "병영",
        "price": 0,
        "icon": "🏠"
      },
      {
        "type": 2201,
        "name": "사격장",
        "price": 0,
        "icon": "🏠"
      },
      {
        "type": 2301,
        "name": "마구간",
        "price": 0,
        "icon": "🏠"
      }
    ]
  },
  "field_map": [
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5221,
      100,
      5231,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5231,
      100,
      5221,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      5121,
      200,
      200,
      0,
      100,
      100,
      5101,
      100,
      100,
      5111,
      200,
      200,
      5121,
      200,
      200,
      5111,
      100,
      100,
      5101,
      100,
      100,
      5111,
      200,
      200,
      5121,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5211,
      100,
      5200,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5200,
      100,
      5211,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      0,
      0,
      5111,
      0,
      0,
      0,
      0,
      0,
      5112,
      0,
      0,
      0,
      0,
      0,
      5113,
      0,
      0,
      0,
      0,
      0,
      5112,
      0,
      0,
      0,
      0,
      0,
      5111,
      0,
      0
    ],
    [
      100,
      100,
      100,
      100,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      100,
      100,
      100,
      100
    ],
    [
      100,
      5221,
      100,
      5211,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      5211,
      100,
      5221,
      100
    ],
    [
      100,
      100,
      5101,
      100,
      100,
      5112,
      300,
      300,
      5122,
      300,
      300,
      5113,
      400,
      400,
      5123,
      400,
      400,
      5113,
      300,
      300,
      5122,
      300,
      300,
      5112,
      100,
      100,
      5101,
      100,
      100
    ],
    [
      100,
      5231,
      100,
      5200,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      5200,
      100,
      5231,
      100
    ],
    [
      100,
      100,
      100,
      100,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      100,
      100,
      100,
      100
    ],
    [
      0,
      0,
      5111,
      0,
      0,
      0,
      0,
      0,
      5113,
      0,
      0,
      0,
      0,
      0,
      5114,
      0,
      0,
      0,
      0,
      0,
      5113,
      0,
      0,
      0,
      0,
      0,
      5111,
      0,
      0
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      500,
      500,
      500,
      500,
      500,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      500,
      500,
      500,
      500,
      500,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      5121,
      200,
      200,
      5113,
      400,
      400,
      5123,
      400,
      400,
      5114,
      500,
      500,
      5131,
      500,
      500,
      5114,
      400,
      400,
      5123,
      400,
      400,
      5113,
      200,
      200,
      5121,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      500,
      500,
      500,
      500,
      500,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      500,
      500,
      500,
      500,
      500,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      0,
      0,
      5111,
      0,
      0,
      0,
      0,
      0,
      5113,
      0,
      0,
      0,
      0,
      0,
      5114,
      0,
      0,
      0,
      0,
      0,
      5113,
      0,
      0,
      0,
      0,
      0,
      5111,
      0,
      0
    ],
    [
      100,
      100,
      100,
      100,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      100,
      100,
      100,
      100
    ],
    [
      100,
      5231,
      100,
      5200,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      5200,
      100,
      5231,
      100
    ],
    [
      100,
      100,
      5101,
      100,
      100,
      5112,
      300,
      300,
      5122,
      300,
      300,
      5113,
      400,
      400,
      5123,
      400,
      400,
      5113,
      300,
      300,
      5122,
      300,
      300,
      5112,
      100,
      100,
      5101,
      100,
      100
    ],
    [
      100,
      5221,
      100,
      5211,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      5211,
      100,
      5221,
      100
    ],
    [
      100,
      100,
      100,
      100,
      100,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      400,
      400,
      400,
      400,
      400,
      0,
      300,
      300,
      300,
      300,
      300,
      0,
      100,
      100,
      100,
      100,
      100
    ],
    [
      0,
      0,
      5111,
      0,
      0,
      0,
      0,
      0,
      5112,
      0,
      0,
      0,
      0,
      0,
      5113,
      0,
      0,
      0,
      0,
      0,
      5112,
      0,
      0,
      0,
      0,
      0,
      5111,
      0,
      0
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5211,
      100,
      5200,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5200,
      100,
      5211,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      5121,
      200,
      200,
      5111,
      100,
      100,
      5101,
      100,
      100,
      5111,
      200,
      200,
      5100,
      200,
      200,
      5111,
      100,
      100,
      5101,
      100,
      100,
      5111,
      200,
      200,
      5121,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5221,
      100,
      5231,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      5231,
      100,
      5221,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ],
    [
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200,
      0,
      100,
      100,
      100,
      100,
      100,
      0,
      200,
      200,
      200,
      200,
      200
    ]
  ],
  "field_objects": {
    "5101": {
      "code": 5101,
      "name": "castle",
      "name_kr": "성",
      "level": 1,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5111": {
      "code": 5111,
      "name": "gate",
      "name_kr": "관문",
      "level": 1,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 1304,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5121": {
      "code": 5121,
      "name": "citadel",
      "name_kr": "성채",
      "level": 1,
      "unit_1": 1105,
      "count_1": 3,
      "unit_2": 1205,
      "count_2": 3,
      "unit_3": 1305,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5122": {
      "code": 5122,
      "name": "citadel",
      "name_kr": "성채",
      "level": 2,
      "unit_1": 1106,
      "count_1": 3,
      "unit_2": 1206,
      "count_2": 3,
      "unit_3": 1306,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5123": {
      "code": 5123,
      "name": "citadel",
      "name_kr": "성채",
      "level": 3,
      "unit_1": 1107,
      "count_1": 3,
      "unit_2": 1207,
      "count_2": 3,
      "unit_3": 1307,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5131": {
      "code": 5131,
      "name": "dragon",
      "name_kr": "용",
      "level": 1,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5141": {
      "code": 5141,
      "name": "gate",
      "name_kr": "관문",
      "level": 4,
      "unit_1": 1107,
      "count_1": 3,
      "unit_2": 1207,
      "count_2": 3,
      "unit_3": 1307,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5201": {
      "code": 5201,
      "name": "gold mine",
      "name_kr": "금광",
      "level": 1,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 1304,
      "count_3": 3,
      "ability_1": 1,
      "value_1": 10,
      "ability_2": 2,
      "value_2": 1,
      "reward": 0
    },
    "5202": {
      "code": 5202,
      "name": "gold mine",
      "name_kr": "금광",
      "level": 2,
      "unit_1": 1106,
      "count_1": 3,
      "unit_2": 1206,
      "count_2": 3,
      "unit_3": 1306,
      "count_3": 3,
      "ability_1": 1,
      "value_1": 20,
      "ability_2": 2,
      "value_2": 1,
      "reward": 0
    },
    "5211": {
      "code": 5211,
      "name": "Energy Fountain",
      "name_kr": "에너지 분수",
      "level": 1,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 1304,
      "count_3": 3,
      "ability_1": 3,
      "value_1": 10,
      "ability_2": 4,
      "value_2": 1,
      "reward": 0
    },
    "5212": {
      "code": 5212,
      "name": "Energy Fountain",
      "name_kr": "에너지 분수",
      "level": 2,
      "unit_1": 1106,
      "count_1": 3,
      "unit_2": 1206,
      "count_2": 3,
      "unit_3": 1306,
      "count_3": 3,
      "ability_1": 3,
      "value_1": 20,
      "ability_2": 4,
      "value_2": 1,
      "reward": 0
    },
    "5221": {
      "code": 5221,
      "name": "shop",
      "name_kr": "상점",
      "level": 1,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 1304,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5231": {
      "code": 5231,
      "name": "tavern",
      "name_kr": "주점",
      "level": 1,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 1304,
      "count_3": 3,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5241": {
      "code": 5241,
      "name": "ruins",
      "name_kr": "유적",
      "level": 1,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 1304,
      "count_3": 3,
      "ability_1": 5,
      "value_1": 5,
      "ability_2": 6,
      "value_2": 1,
      "reward": 0
    },
    "5242": {
      "code": 5242,
      "name": "ruins",
      "name_kr": "유적",
      "level": 2,
      "unit_1": 1106,
      "count_1": 3,
      "unit_2": 1206,
      "count_2": 3,
      "unit_3": 1306,
      "count_3": 3,
      "ability_1": 5,
      "value_1": 10,
      "ability_2": 6,
      "value_2": 1,
      "reward": 0
    },
    "5301": {
      "code": 5301,
      "name": "Statue of Atk",
      "name_kr": "공격력 석상",
      "level": 1,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5302": {
      "code": 5302,
      "name": "Statue of Atk",
      "name_kr": "공격력 석상",
      "level": 2,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5311": {
      "code": 5311,
      "name": "Statue of Def",
      "name_kr": "방어력 석상",
      "level": 1,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5312": {
      "code": 5312,
      "name": "Statue of Def",
      "name_kr": "방어력 석상",
      "level": 2,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5321": {
      "code": 5321,
      "name": "Statue of Hp",
      "name_kr": "체력 석상",
      "level": 1,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5322": {
      "code": 5322,
      "name": "Statue of Hp",
      "name_kr": "체력 석상",
      "level": 2,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5331": {
      "code": 5331,
      "name": "Statue of Spd",
      "name_kr": "속도 석상",
      "level": 1,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "5332": {
      "code": 5332,
      "name": "Statue of Spd",
      "name_kr": "속도 석상",
      "level": 2,
      "unit_1": 0,
      "count_1": 0,
      "unit_2": 0,
      "count_2": 0,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 0
    },
    "6101": {
      "code": 6101,
      "name": "Bruiser",
      "name_kr": "산적",
      "level": 1,
      "unit_1": 1101,
      "count_1": 3,
      "unit_2": 1102,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6102": {
      "code": 6102,
      "name": "Bruiser",
      "name_kr": "산적",
      "level": 2,
      "unit_1": 1102,
      "count_1": 3,
      "unit_2": 1103,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6103": {
      "code": 6103,
      "name": "Bruiser",
      "name_kr": "산적",
      "level": 3,
      "unit_1": 1103,
      "count_1": 3,
      "unit_2": 1104,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6104": {
      "code": 6104,
      "name": "Bruiser",
      "name_kr": "산적",
      "level": 4,
      "unit_1": 1104,
      "count_1": 3,
      "unit_2": 1105,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6105": {
      "code": 6105,
      "name": "Bruiser",
      "name_kr": "산적",
      "level": 5,
      "unit_1": 1105,
      "count_1": 3,
      "unit_2": 1106,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6111": {
      "code": 6111,
      "name": "Shooter",
      "name_kr": "습격자",
      "level": 1,
      "unit_1": 1201,
      "count_1": 3,
      "unit_2": 1202,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6112": {
      "code": 6112,
      "name": "Shooter",
      "name_kr": "습격자",
      "level": 2,
      "unit_1": 1202,
      "count_1": 3,
      "unit_2": 1203,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6113": {
      "code": 6113,
      "name": "Shooter",
      "name_kr": "습격자",
      "level": 3,
      "unit_1": 1203,
      "count_1": 3,
      "unit_2": 1204,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6114": {
      "code": 6114,
      "name": "Shooter",
      "name_kr": "습격자",
      "level": 4,
      "unit_1": 1204,
      "count_1": 3,
      "unit_2": 1205,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6115": {
      "code": 6115,
      "name": "Shooter",
      "name_kr": "습격자",
      "level": 5,
      "unit_1": 1205,
      "count_1": 3,
      "unit_2": 1206,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6121": {
      "code": 6121,
      "name": "Raider",
      "name_kr": "약탈자",
      "level": 1,
      "unit_1": 1301,
      "count_1": 3,
      "unit_2": 1302,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6122": {
      "code": 6122,
      "name": "Raider",
      "name_kr": "약탈자",
      "level": 2,
      "unit_1": 1302,
      "count_1": 3,
      "unit_2": 1303,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6123": {
      "code": 6123,
      "name": "Raider",
      "name_kr": "약탈자",
      "level": 3,
      "unit_1": 1303,
      "count_1": 3,
      "unit_2": 1304,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6124": {
      "code": 6124,
      "name": "Raider",
      "name_kr": "약탈자",
      "level": 4,
      "unit_1": 1304,
      "count_1": 3,
      "unit_2": 1305,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    },
    "6125": {
      "code": 6125,
      "name": "Raider",
      "name_kr": "약탈자",
      "level": 5,
      "unit_1": 1305,
      "count_1": 3,
      "unit_2": 1306,
      "count_2": 3,
      "unit_3": 0,
      "count_3": 0,
      "ability_1": 0,
      "value_1": 0,
      "ability_2": 0,
      "value_2": 0,
      "reward": 4
    }
  },
  "items": {
    "1801": {
      "code": 1801,
      "name": "골드",
      "name_kr": "Gold",
      "level": 1,
      "earn": 1
    },
    "1802": {
      "code": 1802,
      "name": "골드",
      "name_kr": "Gold",
      "level": 2,
      "earn": 2
    },
    "1803": {
      "code": 1803,
      "name": "골드",
      "name_kr": "Gold",
      "level": 3,
      "earn": 6
    },
    "1804": {
      "code": 1804,
      "name": "골드",
      "name_kr": "Gold",
      "level": 4,
      "earn": 14
    },
    "1805": {
      "code": 1805,
      "name": "골드",
      "name_kr": "Gold",
      "level": 5,
      "earn": 32
    },
    "1811": {
      "code": 1811,
      "name": "에너지",
      "name_kr": "Energy",
      "level": 1,
      "earn": 1
    },
    "1812": {
      "code": 1812,
      "name": "에너지",
      "name_kr": "Energy",
      "level": 2,
      "earn": 2
    },
    "1813": {
      "code": 1813,
      "name": "에너지",
      "name_kr": "Energy",
      "level": 3,
      "earn": 6
    },
    "1814": {
      "code": 1814,
      "name": "에너지",
      "name_kr": "Energy",
      "level": 4,
      "earn": 14
    },
    "1815": {
      "code": 1815,
      "name": "에너지",
      "name_kr": "Energy",
      "level": 5,
      "earn": 32
    },
    "1821": {
      "code": 1821,
      "name": "크리스탈",
      "name_kr": "Crystal",
      "level": 1,
      "earn": 1
    },
    "1822": {
      "code": 1822,
      "name": "크리스탈",
      "name_kr": "Crystal",
      "level": 2,
      "earn": 2
    },
    "1823": {
      "code": 1823,
      "name": "크리스탈",
      "name_kr": "Crystal",
      "level": 3,
      "earn": 6
    },
    "1824": {
      "code": 1824,
      "name": "크리스탈",
      "name_kr": "Crystal",
      "level": 4,
      "earn": 14
    },
    "1825": {
      "code": 1825,
      "name": "크리스탈",
      "name_kr": "Crystal",
      "level": 5,
      "earn": 32
    }
  },
  "level_data": [
    {
      "level": 1,
      "xp": 0,
      "energy_max": 50,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 2,
      "xp": 10,
      "energy_max": 52,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 3,
      "xp": 25,
      "energy_max": 54,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 4,
      "xp": 43,
      "energy_max": 56,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 5,
      "xp": 65,
      "energy_max": 58,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 6,
      "xp": 91,
      "energy_max": 60,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 7,
      "xp": 122,
      "energy_max": 62,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 8,
      "xp": 157,
      "energy_max": 64,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 9,
      "xp": 197,
      "energy_max": 66,
      "energy_regen": 1,
      "cp_max": 20,
      "cp_regen": 1
    },
    {
      "level": 10,
      "xp": 242,
      "energy_max": 68,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 11,
      "xp": 292,
      "energy_max": 70,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 12,
      "xp": 347,
      "energy_max": 72,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 13,
      "xp": 408,
      "energy_max": 74,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 14,
      "xp": 474,
      "energy_max": 76,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 15,
      "xp": 546,
      "energy_max": 78,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 16,
      "xp": 624,
      "energy_max": 80,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 17,
      "xp": 708,
      "energy_max": 82,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 18,
      "xp": 798,
      "energy_max": 84,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 19,
      "xp": 894,
      "energy_max": 86,
      "energy_regen": 1,
      "cp_max": 22,
      "cp_regen": 1
    },
    {
      "level": 20,
      "xp": 996,
      "energy_max": 88,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 21,
      "xp": 1104,
      "energy_max": 90,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 22,
      "xp": 1219,
      "energy_max": 92,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 23,
      "xp": 1340,
      "energy_max": 94,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 24,
      "xp": 1468,
      "energy_max": 96,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 25,
      "xp": 1603,
      "energy_max": 98,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 26,
      "xp": 1744,
      "energy_max": 100,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 27,
      "xp": 1892,
      "energy_max": 102,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 28,
      "xp": 2047,
      "energy_max": 104,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 29,
      "xp": 2209,
      "energy_max": 106,
      "energy_regen": 1,
      "cp_max": 24,
      "cp_regen": 1
    },
    {
      "level": 30,
      "xp": 2378,
      "energy_max": 108,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 31,
      "xp": 2554,
      "energy_max": 110,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 32,
      "xp": 2738,
      "energy_max": 112,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 33,
      "xp": 2929,
      "energy_max": 114,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 34,
      "xp": 3127,
      "energy_max": 116,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 35,
      "xp": 3333,
      "energy_max": 118,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 36,
      "xp": 3546,
      "energy_max": 120,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 37,
      "xp": 3767,
      "energy_max": 122,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 38,
      "xp": 3996,
      "energy_max": 124,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 39,
      "xp": 4232,
      "energy_max": 126,
      "energy_regen": 1,
      "cp_max": 26,
      "cp_regen": 1
    },
    {
      "level": 40,
      "xp": 4476,
      "energy_max": 128,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 41,
      "xp": 4728,
      "energy_max": 130,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 42,
      "xp": 4988,
      "energy_max": 132,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 43,
      "xp": 5256,
      "energy_max": 134,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 44,
      "xp": 5532,
      "energy_max": 136,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 45,
      "xp": 5816,
      "energy_max": 138,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 46,
      "xp": 6108,
      "energy_max": 140,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 47,
      "xp": 6408,
      "energy_max": 142,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 48,
      "xp": 6716,
      "energy_max": 144,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 49,
      "xp": 7033,
      "energy_max": 146,
      "energy_regen": 1,
      "cp_max": 28,
      "cp_regen": 1
    },
    {
      "level": 50,
      "xp": 7358,
      "energy_max": 148,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 51,
      "xp": 7691,
      "energy_max": 150,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 52,
      "xp": 8033,
      "energy_max": 152,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 53,
      "xp": 8383,
      "energy_max": 154,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 54,
      "xp": 8742,
      "energy_max": 156,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 55,
      "xp": 9109,
      "energy_max": 158,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 56,
      "xp": 9485,
      "energy_max": 160,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 57,
      "xp": 9870,
      "energy_max": 162,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 58,
      "xp": 10263,
      "energy_max": 164,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 59,
      "xp": 10665,
      "energy_max": 166,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 60,
      "xp": 11076,
      "energy_max": 168,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 61,
      "xp": 11496,
      "energy_max": 170,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 62,
      "xp": 11925,
      "energy_max": 172,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 63,
      "xp": 12363,
      "energy_max": 174,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 64,
      "xp": 12810,
      "energy_max": 176,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 65,
      "xp": 13266,
      "energy_max": 178,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 66,
      "xp": 13731,
      "energy_max": 180,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 67,
      "xp": 14205,
      "energy_max": 182,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 68,
      "xp": 14688,
      "energy_max": 184,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 69,
      "xp": 15180,
      "energy_max": 186,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 70,
      "xp": 15682,
      "energy_max": 188,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 71,
      "xp": 16193,
      "energy_max": 190,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 72,
      "xp": 16713,
      "energy_max": 192,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 73,
      "xp": 17242,
      "energy_max": 194,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 74,
      "xp": 17781,
      "energy_max": 196,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 75,
      "xp": 18329,
      "energy_max": 198,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 76,
      "xp": 18887,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 77,
      "xp": 19454,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 78,
      "xp": 20031,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 79,
      "xp": 20617,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 80,
      "xp": 21213,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 81,
      "xp": 21819,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 82,
      "xp": 22434,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 83,
      "xp": 23059,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 84,
      "xp": 23694,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 85,
      "xp": 24339,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 86,
      "xp": 24994,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 87,
      "xp": 25658,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 88,
      "xp": 26332,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 89,
      "xp": 27016,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 90,
      "xp": 27710,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 91,
      "xp": 28414,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 92,
      "xp": 29128,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 93,
      "xp": 29852,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 94,
      "xp": 30587,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 95,
      "xp": 31332,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 96,
      "xp": 32087,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 97,
      "xp": 32852,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 98,
      "xp": 33627,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 99,
      "xp": 34413,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 100,
      "xp": 35209,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 101,
      "xp": 36015,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 102,
      "xp": 36832,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 103,
      "xp": 37659,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 104,
      "xp": 38496,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 105,
      "xp": 39344,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 106,
      "xp": 40202,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 107,
      "xp": 41071,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 108,
      "xp": 41950,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 109,
      "xp": 42840,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 110,
      "xp": 43741,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 111,
      "xp": 44652,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 112,
      "xp": 45574,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 113,
      "xp": 46507,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 114,
      "xp": 47450,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 115,
      "xp": 48404,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 116,
      "xp": 49369,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 117,
      "xp": 50345,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 118,
      "xp": 51331,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 119,
      "xp": 52328,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 120,
      "xp": 53336,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 121,
      "xp": 54355,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 122,
      "xp": 55385,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 123,
      "xp": 56426,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 124,
      "xp": 57478,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 125,
      "xp": 58541,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 126,
      "xp": 59615,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 127,
      "xp": 60700,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 128,
      "xp": 61796,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 129,
      "xp": 62903,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 130,
      "xp": 64022,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 131,
      "xp": 65152,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 132,
      "xp": 66293,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 133,
      "xp": 67445,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 134,
      "xp": 68609,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 135,
      "xp": 69784,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 136,
      "xp": 70970,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 137,
      "xp": 72167,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 138,
      "xp": 73376,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 139,
      "xp": 74596,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 140,
      "xp": 75828,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 141,
      "xp": 77071,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 142,
      "xp": 78326,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 143,
      "xp": 79592,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 144,
      "xp": 80870,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 145,
      "xp": 82159,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 146,
      "xp": 83460,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 147,
      "xp": 84772,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 148,
      "xp": 86096,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 149,
      "xp": 87431,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 150,
      "xp": 88778,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 151,
      "xp": 90137,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 152,
      "xp": 91508,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 153,
      "xp": 92890,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 154,
      "xp": 94284,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 155,
      "xp": 95690,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 156,
      "xp": 97108,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 157,
      "xp": 98537,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 158,
      "xp": 99978,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 159,
      "xp": 101431,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 160,
      "xp": 102896,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 161,
      "xp": 104373,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 162,
      "xp": 105862,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 163,
      "xp": 107363,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 164,
      "xp": 108876,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 165,
      "xp": 110401,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 166,
      "xp": 111938,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 167,
      "xp": 113487,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 168,
      "xp": 115048,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 169,
      "xp": 116621,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 170,
      "xp": 118206,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 171,
      "xp": 119803,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 172,
      "xp": 121412,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 173,
      "xp": 123033,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 174,
      "xp": 124667,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 175,
      "xp": 126313,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 176,
      "xp": 127971,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 177,
      "xp": 129641,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 178,
      "xp": 131324,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 179,
      "xp": 133019,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 180,
      "xp": 134726,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 181,
      "xp": 136446,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 182,
      "xp": 138178,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 183,
      "xp": 139922,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 184,
      "xp": 141679,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 185,
      "xp": 143448,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 186,
      "xp": 145230,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 187,
      "xp": 147024,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 188,
      "xp": 148830,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 189,
      "xp": 150649,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 190,
      "xp": 152481,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 191,
      "xp": 154325,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 192,
      "xp": 156182,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 193,
      "xp": 158051,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 194,
      "xp": 159933,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 195,
      "xp": 161827,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 196,
      "xp": 163734,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 197,
      "xp": 165654,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 198,
      "xp": 167586,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 199,
      "xp": 169531,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 200,
      "xp": 171489,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 201,
      "xp": 173460,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 202,
      "xp": 175443,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 203,
      "xp": 177439,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 204,
      "xp": 179448,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 205,
      "xp": 181470,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 206,
      "xp": 183504,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 207,
      "xp": 185551,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 208,
      "xp": 187611,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 209,
      "xp": 189684,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 210,
      "xp": 191770,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 211,
      "xp": 193869,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 212,
      "xp": 195981,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 213,
      "xp": 198106,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 214,
      "xp": 200244,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 215,
      "xp": 202395,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 216,
      "xp": 204559,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 217,
      "xp": 206736,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 218,
      "xp": 208926,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 219,
      "xp": 211129,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 220,
      "xp": 213345,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 221,
      "xp": 215574,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 222,
      "xp": 217816,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 223,
      "xp": 220071,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 224,
      "xp": 222340,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 225,
      "xp": 224622,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 226,
      "xp": 226917,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 227,
      "xp": 229225,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 228,
      "xp": 231546,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 229,
      "xp": 233881,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 230,
      "xp": 236229,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 231,
      "xp": 238590,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 232,
      "xp": 240964,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 233,
      "xp": 243352,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 234,
      "xp": 245753,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 235,
      "xp": 248167,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 236,
      "xp": 250595,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 237,
      "xp": 253036,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 238,
      "xp": 255491,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 239,
      "xp": 257959,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 240,
      "xp": 260440,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 241,
      "xp": 262935,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 242,
      "xp": 265443,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 243,
      "xp": 267965,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 244,
      "xp": 270500,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 245,
      "xp": 273049,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 246,
      "xp": 275611,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 247,
      "xp": 278187,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 248,
      "xp": 280777,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 249,
      "xp": 283380,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 250,
      "xp": 285997,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 251,
      "xp": 288627,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 252,
      "xp": 291271,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 253,
      "xp": 293929,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 254,
      "xp": 296600,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 255,
      "xp": 299285,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 256,
      "xp": 301984,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 257,
      "xp": 304696,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 258,
      "xp": 307422,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 259,
      "xp": 310162,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 260,
      "xp": 312916,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 261,
      "xp": 315683,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 262,
      "xp": 318464,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 263,
      "xp": 321259,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 264,
      "xp": 324068,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 265,
      "xp": 326891,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 266,
      "xp": 329728,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 267,
      "xp": 332578,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 268,
      "xp": 335442,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 269,
      "xp": 338320,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 270,
      "xp": 341212,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 271,
      "xp": 344118,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 272,
      "xp": 347038,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 273,
      "xp": 349972,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 274,
      "xp": 352920,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 275,
      "xp": 355882,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 276,
      "xp": 358858,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 277,
      "xp": 361848,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 278,
      "xp": 364852,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 279,
      "xp": 367870,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 280,
      "xp": 370902,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 281,
      "xp": 373948,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 282,
      "xp": 377008,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 283,
      "xp": 380082,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 284,
      "xp": 383171,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 285,
      "xp": 386274,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 286,
      "xp": 389391,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 287,
      "xp": 392522,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 288,
      "xp": 395667,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 289,
      "xp": 398826,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 290,
      "xp": 402000,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 291,
      "xp": 405188,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 292,
      "xp": 408390,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 293,
      "xp": 411606,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 294,
      "xp": 414837,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 295,
      "xp": 418082,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 296,
      "xp": 421341,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 297,
      "xp": 424615,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 298,
      "xp": 427903,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 299,
      "xp": 431205,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 300,
      "xp": 434522,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 301,
      "xp": 437853,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 302,
      "xp": 441199,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 303,
      "xp": 444559,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 304,
      "xp": 447933,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 305,
      "xp": 451322,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 306,
      "xp": 454725,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 307,
      "xp": 458143,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 308,
      "xp": 461575,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 309,
      "xp": 465022,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 310,
      "xp": 468483,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 311,
      "xp": 471959,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 312,
      "xp": 475449,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 313,
      "xp": 478954,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 314,
      "xp": 482473,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 315,
      "xp": 486007,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 316,
      "xp": 489556,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 317,
      "xp": 493119,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 318,
      "xp": 496697,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 319,
      "xp": 500289,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 320,
      "xp": 503896,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 321,
      "xp": 507518,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 322,
      "xp": 511154,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 323,
      "xp": 514805,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 324,
      "xp": 518471,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 325,
      "xp": 522152,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 326,
      "xp": 525847,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 327,
      "xp": 529557,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 328,
      "xp": 533282,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 329,
      "xp": 537022,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 330,
      "xp": 540776,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 331,
      "xp": 544545,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 332,
      "xp": 548329,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 333,
      "xp": 552128,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 334,
      "xp": 555942,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 335,
      "xp": 559771,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 336,
      "xp": 563614,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 337,
      "xp": 567472,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 338,
      "xp": 571345,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 339,
      "xp": 575233,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 340,
      "xp": 579136,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 341,
      "xp": 583054,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 342,
      "xp": 586987,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 343,
      "xp": 590935,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 344,
      "xp": 594898,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 345,
      "xp": 598876,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 346,
      "xp": 602869,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 347,
      "xp": 606877,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 348,
      "xp": 610900,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 349,
      "xp": 614938,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 350,
      "xp": 618991,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 351,
      "xp": 623059,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 352,
      "xp": 627142,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 353,
      "xp": 631240,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 354,
      "xp": 635353,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 355,
      "xp": 639481,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 356,
      "xp": 643625,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 357,
      "xp": 647784,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 358,
      "xp": 651958,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 359,
      "xp": 656147,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 360,
      "xp": 660351,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 361,
      "xp": 664570,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 362,
      "xp": 668805,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 363,
      "xp": 673055,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 364,
      "xp": 677320,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 365,
      "xp": 681600,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 366,
      "xp": 685896,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 367,
      "xp": 690207,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 368,
      "xp": 694533,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 369,
      "xp": 698874,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 370,
      "xp": 703231,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 371,
      "xp": 707603,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 372,
      "xp": 711990,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 373,
      "xp": 716393,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 374,
      "xp": 720811,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 375,
      "xp": 725244,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 376,
      "xp": 729693,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 377,
      "xp": 734157,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 378,
      "xp": 738637,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 379,
      "xp": 743132,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 380,
      "xp": 747643,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 381,
      "xp": 752169,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 382,
      "xp": 756710,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 383,
      "xp": 761267,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 384,
      "xp": 765839,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 385,
      "xp": 770427,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 386,
      "xp": 775030,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 387,
      "xp": 779649,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 388,
      "xp": 784283,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 389,
      "xp": 788933,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 390,
      "xp": 793598,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 391,
      "xp": 798279,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 392,
      "xp": 802976,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 393,
      "xp": 807688,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 394,
      "xp": 812416,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 395,
      "xp": 817159,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 396,
      "xp": 821918,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 397,
      "xp": 826693,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 398,
      "xp": 831483,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 399,
      "xp": 836289,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 400,
      "xp": 841111,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 401,
      "xp": 845948,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 402,
      "xp": 850801,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 403,
      "xp": 855670,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 404,
      "xp": 860554,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 405,
      "xp": 865454,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 406,
      "xp": 870370,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 407,
      "xp": 875302,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 408,
      "xp": 880249,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 409,
      "xp": 885212,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 410,
      "xp": 890191,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 411,
      "xp": 895186,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 412,
      "xp": 900197,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 413,
      "xp": 905223,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 414,
      "xp": 910265,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 415,
      "xp": 915323,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 416,
      "xp": 920397,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 417,
      "xp": 925487,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 418,
      "xp": 930593,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 419,
      "xp": 935715,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 420,
      "xp": 940853,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 421,
      "xp": 946006,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 422,
      "xp": 951175,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 423,
      "xp": 956360,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 424,
      "xp": 961561,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 425,
      "xp": 966778,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 426,
      "xp": 972011,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 427,
      "xp": 977260,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 428,
      "xp": 982525,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 429,
      "xp": 987806,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 430,
      "xp": 993103,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 431,
      "xp": 998416,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 432,
      "xp": 1003745,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 433,
      "xp": 1009090,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 434,
      "xp": 1014451,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 435,
      "xp": 1019828,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 436,
      "xp": 1025222,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 437,
      "xp": 1030632,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 438,
      "xp": 1036058,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 439,
      "xp": 1041500,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 440,
      "xp": 1046958,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 441,
      "xp": 1052432,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 442,
      "xp": 1057922,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 443,
      "xp": 1063428,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 444,
      "xp": 1068951,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 445,
      "xp": 1074490,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 446,
      "xp": 1080045,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 447,
      "xp": 1085616,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 448,
      "xp": 1091203,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 449,
      "xp": 1096807,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 450,
      "xp": 1102427,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 451,
      "xp": 1108063,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 452,
      "xp": 1113715,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 453,
      "xp": 1119384,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 454,
      "xp": 1125069,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 455,
      "xp": 1130770,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 456,
      "xp": 1136487,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 457,
      "xp": 1142221,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 458,
      "xp": 1147971,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 459,
      "xp": 1153737,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 460,
      "xp": 1159520,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 461,
      "xp": 1165319,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 462,
      "xp": 1171135,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 463,
      "xp": 1176967,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 464,
      "xp": 1182815,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 465,
      "xp": 1188680,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 466,
      "xp": 1194561,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 467,
      "xp": 1200459,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 468,
      "xp": 1206373,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 469,
      "xp": 1212303,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 470,
      "xp": 1218250,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 471,
      "xp": 1224213,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 472,
      "xp": 1230193,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 473,
      "xp": 1236189,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 474,
      "xp": 1242202,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 475,
      "xp": 1248231,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 476,
      "xp": 1254277,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 477,
      "xp": 1260339,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 478,
      "xp": 1266418,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 479,
      "xp": 1272513,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 480,
      "xp": 1278625,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 481,
      "xp": 1284753,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 482,
      "xp": 1290898,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 483,
      "xp": 1297060,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 484,
      "xp": 1303238,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 485,
      "xp": 1309433,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 486,
      "xp": 1315644,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 487,
      "xp": 1321872,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 488,
      "xp": 1328117,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 489,
      "xp": 1334378,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 490,
      "xp": 1340656,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 491,
      "xp": 1346951,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 492,
      "xp": 1353262,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 493,
      "xp": 1359590,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 494,
      "xp": 1365935,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 495,
      "xp": 1372296,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 496,
      "xp": 1378674,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 497,
      "xp": 1385069,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 498,
      "xp": 1391481,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 499,
      "xp": 1397909,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    },
    {
      "level": 500,
      "xp": 1404354,
      "energy_max": 200,
      "energy_regen": 1,
      "cp_max": 30,
      "cp_regen": 1
    }
  ],
  "localization": {},
  "merge_xp": {},
  "units": {
    "1101": {
      "code": 1101,
      "name": "Militia",
      "name_kr": "민병",
      "class": 1,
      "level": 1,
      "unlock": 1,
      "hp": 10,
      "atk": 5,
      "def": 10,
      "spd": 5,
      "range": 1,
      "move": 1,
      "sell": 0
    },
    "1102": {
      "code": 1102,
      "name": "Infantry",
      "name_kr": "보병",
      "class": 1,
      "level": 2,
      "unlock": 1,
      "hp": 20,
      "atk": 7,
      "def": 15,
      "spd": 7,
      "range": 1,
      "move": 1,
      "sell": 1
    },
    "1103": {
      "code": 1103,
      "name": "Swordsman",
      "name_kr": "검병",
      "class": 1,
      "level": 3,
      "unlock": 1,
      "hp": 30,
      "atk": 9,
      "def": 20,
      "spd": 9,
      "range": 1,
      "move": 1,
      "sell": 1
    },
    "1104": {
      "code": 1104,
      "name": "Shieldman",
      "name_kr": "방패병",
      "class": 1,
      "level": 4,
      "unlock": 1,
      "hp": 40,
      "atk": 11,
      "def": 25,
      "spd": 11,
      "range": 1,
      "move": 1,
      "sell": 2
    },
    "1105": {
      "code": 1105,
      "name": "Heavy Infantry",
      "name_kr": "중갑병",
      "class": 1,
      "level": 5,
      "unlock": 1,
      "hp": 50,
      "atk": 13,
      "def": 30,
      "spd": 13,
      "range": 1,
      "move": 1,
      "sell": 3
    },
    "1106": {
      "code": 1106,
      "name": "Elite",
      "name_kr": "정예병",
      "class": 1,
      "level": 6,
      "unlock": 1,
      "hp": 60,
      "atk": 15,
      "def": 35,
      "spd": 15,
      "range": 1,
      "move": 1,
      "sell": 6
    },
    "1107": {
      "code": 1107,
      "name": "Guard",
      "name_kr": "근위병",
      "class": 1,
      "level": 7,
      "unlock": 2,
      "hp": 70,
      "atk": 17,
      "def": 40,
      "spd": 17,
      "range": 1,
      "move": 1,
      "sell": 12
    },
    "1108": {
      "code": 1108,
      "name": "Templar",
      "name_kr": "템플러",
      "class": 1,
      "level": 8,
      "unlock": 3,
      "hp": 80,
      "atk": 19,
      "def": 45,
      "spd": 19,
      "range": 1,
      "move": 1,
      "sell": 25
    },
    "1109": {
      "code": 1109,
      "name": "Paladin",
      "name_kr": "팔라딘",
      "class": 1,
      "level": 9,
      "unlock": 4,
      "hp": 90,
      "atk": 21,
      "def": 50,
      "spd": 21,
      "range": 1,
      "move": 1,
      "sell": 50
    },
    "1110": {
      "code": 1110,
      "name": "Hero",
      "name_kr": "영웅",
      "class": 1,
      "level": 10,
      "unlock": 5,
      "hp": 100,
      "atk": 23,
      "def": 55,
      "spd": 23,
      "range": 1,
      "move": 1,
      "sell": 100
    },
    "1201": {
      "code": 1201,
      "name": "Rookie Archer",
      "name_kr": "초보 궁수",
      "class": 2,
      "level": 1,
      "unlock": 1,
      "hp": 10,
      "atk": 10,
      "def": 5,
      "spd": 5,
      "range": 2,
      "move": 1,
      "sell": 0
    },
    "1202": {
      "code": 1202,
      "name": "Archer",
      "name_kr": "궁수",
      "class": 2,
      "level": 2,
      "unlock": 1,
      "hp": 20,
      "atk": 15,
      "def": 7,
      "spd": 7,
      "range": 2,
      "move": 1,
      "sell": 1
    },
    "1203": {
      "code": 1203,
      "name": "Hunter",
      "name_kr": "사냥꾼",
      "class": 2,
      "level": 3,
      "unlock": 1,
      "hp": 30,
      "atk": 20,
      "def": 9,
      "spd": 9,
      "range": 2,
      "move": 1,
      "sell": 1
    },
    "1204": {
      "code": 1204,
      "name": "Marksman",
      "name_kr": "명사수",
      "class": 2,
      "level": 4,
      "unlock": 1,
      "hp": 40,
      "atk": 25,
      "def": 11,
      "spd": 11,
      "range": 2,
      "move": 1,
      "sell": 2
    },
    "1205": {
      "code": 1205,
      "name": "Sniper",
      "name_kr": "저격수",
      "class": 2,
      "level": 5,
      "unlock": 1,
      "hp": 50,
      "atk": 30,
      "def": 13,
      "spd": 13,
      "range": 3,
      "move": 1,
      "sell": 3
    },
    "1206": {
      "code": 1206,
      "name": "Elite Archer",
      "name_kr": "정예 궁수",
      "class": 2,
      "level": 6,
      "unlock": 1,
      "hp": 60,
      "atk": 35,
      "def": 15,
      "spd": 15,
      "range": 3,
      "move": 1,
      "sell": 6
    },
    "1207": {
      "code": 1207,
      "name": "Deadeye",
      "name_kr": "데드아이",
      "class": 2,
      "level": 7,
      "unlock": 2,
      "hp": 70,
      "atk": 40,
      "def": 17,
      "spd": 17,
      "range": 3,
      "move": 1,
      "sell": 12
    },
    "1208": {
      "code": 1208,
      "name": "Pathfinder",
      "name_kr": "패스파인더",
      "class": 2,
      "level": 8,
      "unlock": 3,
      "hp": 80,
      "atk": 45,
      "def": 19,
      "spd": 19,
      "range": 3,
      "move": 1,
      "sell": 25
    },
    "1209": {
      "code": 1209,
      "name": "Bowmaster",
      "name_kr": "보우마스터",
      "class": 2,
      "level": 9,
      "unlock": 4,
      "hp": 90,
      "atk": 50,
      "def": 21,
      "spd": 21,
      "range": 3,
      "move": 1,
      "sell": 50
    },
    "1210": {
      "code": 1210,
      "name": "Divine Archer",
      "name_kr": "신궁",
      "class": 2,
      "level": 10,
      "unlock": 5,
      "hp": 100,
      "atk": 55,
      "def": 23,
      "spd": 23,
      "range": 3,
      "move": 1,
      "sell": 100
    },
    "1301": {
      "code": 1301,
      "name": "Rider",
      "name_kr": "기병",
      "class": 3,
      "level": 1,
      "unlock": 1,
      "hp": 10,
      "atk": 5,
      "def": 5,
      "spd": 10,
      "range": 1,
      "move": 2,
      "sell": 0
    },
    "1302": {
      "code": 1302,
      "name": "Light Cavalry",
      "name_kr": "경기병",
      "class": 3,
      "level": 2,
      "unlock": 1,
      "hp": 20,
      "atk": 7,
      "def": 7,
      "spd": 15,
      "range": 1,
      "move": 2,
      "sell": 1
    },
    "1303": {
      "code": 1303,
      "name": "Lancer",
      "name_kr": "창기병",
      "class": 3,
      "level": 3,
      "unlock": 1,
      "hp": 30,
      "atk": 9,
      "def": 9,
      "spd": 20,
      "range": 1,
      "move": 2,
      "sell": 1
    },
    "1304": {
      "code": 1304,
      "name": "Knight",
      "name_kr": "기사",
      "class": 3,
      "level": 4,
      "unlock": 1,
      "hp": 40,
      "atk": 11,
      "def": 11,
      "spd": 25,
      "range": 1,
      "move": 2,
      "sell": 2
    },
    "1305": {
      "code": 1305,
      "name": "Heavy Cavalry",
      "name_kr": "중기병",
      "class": 3,
      "level": 5,
      "unlock": 1,
      "hp": 50,
      "atk": 13,
      "def": 13,
      "spd": 30,
      "range": 1,
      "move": 3,
      "sell": 3
    },
    "1306": {
      "code": 1306,
      "name": "Elite Cavalry",
      "name_kr": "정예 기병",
      "class": 3,
      "level": 6,
      "unlock": 1,
      "hp": 60,
      "atk": 15,
      "def": 15,
      "spd": 35,
      "range": 1,
      "move": 3,
      "sell": 6
    },
    "1307": {
      "code": 1307,
      "name": "Vanguard Knight",
      "name_kr": "선봉 기사",
      "class": 3,
      "level": 7,
      "unlock": 2,
      "hp": 70,
      "atk": 17,
      "def": 17,
      "spd": 40,
      "range": 1,
      "move": 3,
      "sell": 12
    },
    "1308": {
      "code": 1308,
      "name": "Dread Knight",
      "name_kr": "암흑 기사",
      "class": 3,
      "level": 8,
      "unlock": 3,
      "hp": 80,
      "atk": 19,
      "def": 19,
      "spd": 45,
      "range": 1,
      "move": 3,
      "sell": 25
    },
    "1309": {
      "code": 1309,
      "name": "Holy Knight",
      "name_kr": "신성 기사",
      "class": 3,
      "level": 9,
      "unlock": 4,
      "hp": 90,
      "atk": 21,
      "def": 21,
      "spd": 50,
      "range": 1,
      "move": 3,
      "sell": 50
    },
    "1310": {
      "code": 1310,
      "name": "Dragoon",
      "name_kr": "용기병",
      "class": 3,
      "level": 10,
      "unlock": 5,
      "hp": 100,
      "atk": 23,
      "def": 23,
      "spd": 55,
      "range": 1,
      "move": 3,
      "sell": 100
    }
  },
  "unlock_conditions": {
    "level": [
      [
        24,
        20,
        14,
        10,
        10,
        14,
        20,
        24
      ],
      [
        23,
        18,
        6,
        2,
        2,
        6,
        18,
        21
      ],
      [
        17,
        8,
        0,
        0,
        0,
        0,
        9,
        15
      ],
      [
        13,
        5,
        0,
        0,
        0,
        0,
        3,
        11
      ],
      [
        13,
        5,
        0,
        0,
        0,
        0,
        3,
        11
      ],
      [
        17,
        8,
        0,
        0,
        0,
        0,
        9,
        15
      ],
      [
        23,
        19,
        7,
        4,
        4,
        7,
        19,
        21
      ],
      [
        25,
        22,
        16,
        12,
        12,
        16,
        22,
        25
      ]
    ],
    "gold": [
      [
        100,
        50,
        30,
        20,
        20,
        30,
        50,
        100
      ],
      [
        50,
        40,
        10,
        5,
        5,
        10,
        40,
        50
      ],
      [
        30,
        10,
        0,
        0,
        0,
        0,
        10,
        30
      ],
      [
        20,
        5,
        0,
        0,
        0,
        0,
        5,
        20
      ],
      [
        20,
        5,
        0,
        0,
        0,
        0,
        5,
        20
      ],
      [
        30,
        10,
        0,
        0,
        0,
        0,
        10,
        30
      ],
      [
        50,
        40,
        10,
        5,
        5,
        10,
        40,
        50
      ],
      [
        100,
        50,
        30,
        20,
        20,
        30,
        50,
        100
      ]
    ]
  },
  "build_timestamp": "2026-02-06T19:26:22.788Z"
};
</script>
    <script>
const GITHUB_REPO = "nod-sean/bmo";
const GITHUB_BRANCH = "main";
const ASSET_KEYS = [
    '1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110',
    '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210',
    '1301', '1302', '1303', '1304', '1305', '1306', '1307', '1308', '1309', '1310',
    '2101', '2102', '2103', '2104', '2105', '2201', '2204', '2205',
    '2301', '2302', '2303', '2304', '2801', '2802', '2803', '2804', '2805',
    '3101', '3102', '3103', '3104', '3105',
    '1801', '1802', '1803', '1804', '1805', '1811', '1812', '1813', '1814', '1815',
    '1821', '1822', '1823', '1824', '1825', 'lock', 'gold', 'energy', 'crystal', 'xp', 'levelup', 'field_bg'
];

const CONFIG = { gridCols: 8, gridRows: 8, gridTopY: 460, gridPadding: 20, squadCols: 3, squadRows: 3, squadTopY: 40, squadGap: 80, squadCellSize: 130, squadGap3: 24, squadCellSize3: 110 };
const ITEM_TYPE = {
    EMPTY: 0,
    BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3, BUILDING_CHEST: 4, BUILDING_CAMP: 5,
    UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12,
    UNIT_DRAGON: 9999, // Boss Unit
    ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22
};
const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2', SQUAD3: 'squad3' };

// Initialize Data from Window
const GAME_DATA = window.GAME_DATA || {};
const LEVEL_DATA = GAME_DATA.level_data || [];
const REFILL_DATA = GAME_DATA.constants?.REFILL_DATA || {};
const ABILITY_CODES = GAME_DATA.constants?.ABILITY_CODES || {};
const FIELD_OBJECT_DATA = GAME_DATA.field_objects || {};

// Process FIELD_OBJECT_DATA to construct 'defenders' array from flat unit/count fields
Object.values(FIELD_OBJECT_DATA).forEach(obj => {
    if (!obj.defenders) {
        obj.defenders = [];
        for (let i = 1; i <= 3; i++) {
            const u = obj[`unit_${i}`];
            const c = obj[`count_${i}`];
            if (u && c > 0) {
                obj.defenders.push({ code: u, count: c, slot: i - 1 });
            }
        }
    }
});

// Process FIELD_OBJECT_DATA to construct 'abilities' array from flat ability/value fields
Object.values(FIELD_OBJECT_DATA).forEach(obj => {
    if (!obj.abilities) {
        obj.abilities = [];
        for (let i = 1; i <= 2; i++) {
            const a = obj[`ability_${i}`];
            const v = obj[`value_${i}`];
            if (a) {
                obj.abilities.push({ code: a, value: v });
            }
        }
    }
});

const ITEM_TABLE = GAME_DATA.items || {};
const UNIT_STATS = GAME_DATA.units || {};
const BUILDING_LIMITS = GAME_DATA.constants?.BUILDING_LIMITS || {};
const SHOP_DATA = GAME_DATA.constants?.SHOP_DATA || [];
const BATTLE_CONSTANTS = GAME_DATA.constants?.BATTLE_CONSTANTS || { BASE_DMG: 1, ADVANTAGE_BONUS: 1.5, DISADVANTAGE_PENALTY: 0.7, CRIT_CHANCE: 0.1, CRIT_MULT: 2.0 };
const CAMP_CAPACITY = GAME_DATA.camps ? Object.fromEntries(Object.values(GAME_DATA.camps).map(c => [c.level || 1, c.capacity])) : { 1: 4, 2: 6, 3: 8, 4: 12, 5: 16 };
const UNLOCK_CONDITIONS = GAME_DATA.unlock_conditions || { level: [], gold: [] };

// Derived or Static
const BUILDING_TYPE_MAP = {
    [ITEM_TYPE.BUILDING_BARRACKS]: '2101',
    [ITEM_TYPE.BUILDING_RANGE]: '2201',
    [ITEM_TYPE.BUILDING_STABLE]: '2301',
    [ITEM_TYPE.BUILDING_CAMP]: '3101'
    // Chests handled separately
};

const MOVE_MS_PER_MIN = 120; // 데모용 스케일: 1분 = 120ms
const CP_COST_PER_TILE = 1;
const TERRAIN_COLORS = { 100: "#4a6e3a", 200: "#2e5a2a", 300: "#8b6f3d", 400: "#7a7a7a", 500: "#7a1f1f" };
const TERRAIN_COLORS_BORDER = { 100: "#5b7b47", 200: "#3b6a36", 300: "#9b7e4a", 400: "#8a8a8a", 500: "#8a2b2b" };

function isTerrainCode(code) { return code >= 100 && code < 600; }
function isWallTile(code) { return code === 0; }
function getTerrainBase(code) { return Math.floor(code / 100) * 100; }
function getTerrainName(code) {
    const base = getTerrainBase(code);
    const name = base === 100 ? "평원" : base === 200 ? "숲" : base === 300 ? "고원" : base === 400 ? "산악" : base === 500 ? "화산" : "지형";
    return (code % 100 === 1) ? `${name} 경계` : name;
}
function getTerrainBaseName(code) {
    const base = getTerrainBase(code);
    return base === 100 ? "평원" : base === 200 ? "숲" : base === 300 ? "고원" : base === 400 ? "산악" : base === 500 ? "화산" : "지형";
}

// function isCastleTile(code) { return code === 1 || code === 5101; } // Unified
function isCastleTile(code) { return code == 1 || code == 5101; }
function isGateTile(code) { return code == 2 || (code >= 5111 && code <= 5114); }
function isCitadelTile(code) { return code == 3 || (code >= 5121 && code <= 5123); }
function isDragonTile(code) { return code == 5131; }
function isGoldMineTile(code) {
    return code == 5 || code == 5200 || (code >= 5201 && code <= 5202);
}
function isFountainTile(code) { return code == 6 || (code >= 5211 && code <= 5212); }
function isShopTile(code) { return code === 5221; }
function isTavernTile(code) { return code === 5231; }
function isRuinsTile(code) { return code === 5241 || code === 5242; }
function isStatueTile(code) { return code >= 5301 && code <= 5332; }
function isBorderTerrain(code) { return isTerrainCode(code) && code % 100 === 1; }
function isBlockingField(code) { return isWallTile(code) || isGateTile(code) || isCitadelTile(code) || isDragonTile(code) || isBorderTerrain(code); }
function getStatueKind(code) {
    if (code >= 5301 && code <= 5302) return "atk";
    if (code >= 5311 && code <= 5312) return "def";
    if (code >= 5321 && code <= 5322) return "hp";
    if (code >= 5331 && code <= 5332) return "spd";
    return null;
}
function getObjectLevelFromCode(type) {
    // Rely on object data if possible, fallback to calculation
    if (FIELD_OBJECT_DATA[type]) return FIELD_OBJECT_DATA[type].level;
    if (isGateTile(type)) return Math.max(1, type - 5110);
    if (isCitadelTile(type)) return Math.max(1, type - 5120);
    if (isGoldMineTile(type)) return Math.max(1, type - 5200);
    if (isFountainTile(type)) return Math.max(1, type - 5210);
    if (isRuinsTile(type)) return Math.max(1, type - 5240);
    if (isStatueTile(type)) return type % 10;
    return 1;
}

const FIELD_DEFENDERS = {}; // Deprecated, use FIELD_OBJECT_DATA directly

// --- LEVEL COLORS ---
const LEVEL_COLORS = {
    1: "#FFFFFF", 2: "#BDBDBD", 3: "#6D4C41", 4: "#2E7D32", 5: "#00897B",
    6: "#1E88E5", 7: "#6A1B9A", 8: "#F57C00", 9: "#C62828", 10: "#212121"
};

const STATUE_BUFF_FALLBACK = { 1: 0.05, 2: 0.10 };
const CITADEL_CP_BONUS = 0;
const GATE_UPKEEP_PER_LEVEL = 1;
const CITADEL_UPKEEP_PER_LEVEL = 2;


const UNIT_TYPE_ADVANTAGE = {
    [ITEM_TYPE.UNIT_INFANTRY]: ITEM_TYPE.UNIT_ARCHER, // 보병 > 궁병
    [ITEM_TYPE.UNIT_ARCHER]: ITEM_TYPE.UNIT_CAVALRY,  // 궁병 > 기병
    [ITEM_TYPE.UNIT_CAVALRY]: ITEM_TYPE.UNIT_INFANTRY // 기병 > 보병
};



const MERGE_XP_DATA = GAME_DATA.merge_xp || { 1: 1, 2: 2, 3: 4, 4: 5, 5: 6, 6: 8, 7: 10, 8: 15, 9: 20, 10: 0 };
const ITEM_VALUES = {};
Object.values(GAME_DATA.items || {}).forEach(item => {
    // Basic heuristics to identify gold items by code range or name if needed, assuming items table is primarily for resources
    if (item.code >= 1801 && item.code <= 1809) {
        ITEM_VALUES[item.level] = item.earn;
    }
});
if (Object.keys(ITEM_VALUES).length === 0) Object.assign(ITEM_VALUES, { 1: 1, 2: 2, 3: 6, 4: 14, 5: 32 });
const UNLOCK_GOLD_MAP = GAME_DATA.unlock_conditions?.gold || [];
const UNLOCK_LEVEL_MAP = GAME_DATA.unlock_conditions?.level || [];

const BUILDING_DATA = {};
Object.entries(BUILDING_TYPE_MAP).forEach(([type, baseCode]) => {
    BUILDING_DATA[type] = {};
    for (let lv = 1; lv <= 10; lv++) {
        const code = parseInt(baseCode) + (lv - 1);
        const data = (GAME_DATA.buildings || {})[code];
        if (data) {
            // Construct probs array from flat fields
            const probs = [];
            for (let i = 1; i <= 10; i++) {
                probs.push(data[`prob_${i}`] || 0);
            }

            BUILDING_DATA[type][lv] = {
                merge_max: 5 + lv,
                energy: data.energy || data.Energy || 0, // Handle potential casing mismatch
                probs: probs
            };
        }
    }
});
const CHEST_DROP_TABLE = {};
Object.entries(GAME_DATA.chests || {}).forEach(([chestCode, chestData]) => {
    const drops = [];
    Object.entries(chestData).forEach(([key, val]) => {
        // Assume number keys like "1801", "1802" are item codes for drops
        const code = parseInt(key);
        if (!isNaN(code) && code >= 1800 && code < 1900 && val > 0) {
            drops.push({ code: code, prob: val });
        }
    });
    // The key in CHEST_DROP_TABLE seems to be 1-based level index in the legacy code (1, 2, 3, 4, 5)
    // Map chest level directly
    CHEST_DROP_TABLE[chestData.level] = drops;
});
// Fallback if data missing
if (Object.keys(CHEST_DROP_TABLE).length === 0) {
    Object.assign(CHEST_DROP_TABLE, { 1: [{ code: 1801, prob: 50 }, { code: 1811, prob: 50 }], 2: [{ code: 1801, prob: 25 }, { code: 1802, prob: 25 }, { code: 1811, prob: 25 }, { code: 1812, prob: 25 }] }); // Truncated fallback for safety
}

// --- PHASE 2 MAP DATA (FIELD_OBJECT_1) ---
// --- FIELD EVENT DATA ---
const FIELD_EVENT_TYPES = {
    BANDIT: 2001,       // Weak Enemy (Plains/Forest)
    BANDIT_LEADER: 2002,// Strong Enemy (Mountains)
    DUNGEON: 2010,      // Hard Mode
    PORTAL: 2020,       // Teleport
    CARAVAN: 2030       // Shop/Trade
};

// Spawn Rates (Prob per 1000 tiles, approximate)
const FIELD_EVENT_RATES = {
    [FIELD_EVENT_TYPES.BANDIT]: 15,
    [FIELD_EVENT_TYPES.BANDIT_LEADER]: 5,
    [FIELD_EVENT_TYPES.DUNGEON]: 3,
    [FIELD_EVENT_TYPES.PORTAL]: 2,
    [FIELD_EVENT_TYPES.CARAVAN]: 4
};

// Drop Tables
const EVENT_DROP_TABLE = {
    [FIELD_EVENT_TYPES.BANDIT]: { gold: [50, 100], items: [{ code: 1801, prob: 20 }] }, // Low gold, low chance crop
    [FIELD_EVENT_TYPES.BANDIT_LEADER]: { gold: [200, 400], items: [{ code: 1811, prob: 30 }, { code: 1201, prob: 10 }] }, // Mid gold, Iron/Weapon
    [FIELD_EVENT_TYPES.DUNGEON]: { gold: [500, 1000], items: [{ code: 2101, prob: 50 }, { code: 1210, prob: 20 }] } // High gold, Building/Rare
};

const FIELD_MAP_DATA = [
    [200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200],
    [200, 200, 200, 200, 200, 0, 100, 5221, 100, 5231, 100, 0, 200, 200, 200, 200, 200, 0, 100, 5231, 100, 5221, 100, 0, 200, 200, 200, 200, 200],
    [200, 200, 5121, 200, 200, 0, 100, 100, 5101, 100, 100, 5111, 200, 200, 5121, 200, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 200, 5121, 200, 200],
    [200, 200, 200, 200, 200, 0, 100, 5211, 100, 5200, 100, 0, 200, 200, 200, 200, 200, 0, 100, 5200, 100, 5211, 100, 0, 200, 200, 200, 200, 200],
    [200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200],
    [0, 0, 5111, 0, 0, 0, 0, 0, 5112, 0, 0, 0, 0, 0, 5113, 0, 0, 0, 0, 0, 5112, 0, 0, 0, 0, 0, 5111, 0, 0],
    [100, 100, 100, 100, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 100, 100, 100, 100],
    [100, 5221, 100, 5211, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 5211, 100, 5221, 100],
    [100, 100, 5101, 100, 100, 5112, 300, 300, 5122, 300, 300, 5113, 400, 400, 5123, 400, 400, 5113, 300, 300, 5122, 300, 300, 5112, 100, 100, 5101, 100, 100],
    [100, 5231, 100, 5200, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 5200, 100, 5231, 100],
    [100, 100, 100, 100, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 100, 100, 100, 100],
    [0, 0, 5111, 0, 0, 0, 0, 0, 5113, 0, 0, 0, 0, 0, 5114, 0, 0, 0, 0, 0, 5113, 0, 0, 0, 0, 0, 5111, 0, 0],
    [200, 200, 200, 200, 200, 0, 400, 400, 400, 400, 400, 0, 500, 500, 500, 500, 500, 0, 400, 400, 400, 400, 400, 0, 200, 200, 200, 200, 200],
    [200, 200, 200, 200, 200, 0, 400, 400, 400, 400, 400, 0, 500, 500, 500, 500, 500, 0, 400, 400, 400, 400, 400, 0, 200, 200, 200, 200, 200],
    [200, 200, 5121, 200, 200, 5113, 400, 400, 5123, 400, 400, 5114, 500, 500, 5131, 500, 500, 5114, 400, 400, 5123, 400, 400, 5113, 200, 200, 5121, 200, 200],
    [200, 200, 200, 200, 200, 0, 400, 400, 400, 400, 400, 0, 500, 500, 500, 500, 500, 0, 400, 400, 400, 400, 400, 0, 200, 200, 200, 200, 200],
    [200, 200, 200, 200, 200, 0, 400, 400, 400, 400, 400, 0, 500, 500, 500, 500, 500, 0, 400, 400, 400, 400, 400, 0, 200, 200, 200, 200, 200],
    [0, 0, 5111, 0, 0, 0, 0, 0, 5113, 0, 0, 0, 0, 0, 5114, 0, 0, 0, 0, 0, 5113, 0, 0, 0, 0, 0, 5111, 0, 0],
    [100, 100, 100, 100, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 100, 100, 100, 100],
    [100, 5231, 100, 5200, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 5200, 100, 5231, 100],
    [100, 100, 5101, 100, 100, 5112, 300, 300, 5122, 300, 300, 5113, 400, 400, 5123, 400, 400, 5113, 300, 300, 5122, 300, 300, 5112, 100, 100, 5101, 100, 100],
    [100, 5221, 100, 5211, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 5211, 100, 5221, 100],
    [100, 100, 100, 100, 100, 0, 300, 300, 300, 300, 300, 0, 400, 400, 400, 400, 400, 0, 300, 300, 300, 300, 300, 0, 100, 100, 100, 100, 100],
    [0, 0, 5111, 0, 0, 0, 0, 0, 5112, 0, 0, 0, 0, 0, 5113, 0, 0, 0, 0, 0, 5112, 0, 0, 0, 0, 0, 5111, 0, 0],
    [200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200],
    [200, 200, 200, 200, 200, 0, 100, 5211, 100, 5200, 100, 0, 200, 200, 200, 200, 200, 0, 100, 5200, 100, 5211, 100, 0, 200, 200, 200, 200, 200],
    [200, 200, 5121, 200, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 200, 5100, 200, 200, 5111, 100, 100, 5101, 100, 100, 5111, 200, 200, 5121, 200, 200],
    [200, 200, 200, 200, 200, 0, 100, 5221, 100, 5231, 100, 0, 200, 200, 200, 200, 200, 0, 100, 5231, 100, 5221, 100, 0, 200, 200, 200, 200, 200],
    [200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200, 0, 100, 100, 100, 100, 100, 0, 200, 200, 200, 200, 200],
];
const FIELD_TERRAIN_DATA = FIELD_MAP_DATA.map(row => row.slice());
const MAP_SIZE = FIELD_MAP_DATA.length;
const PLAYER_START = { r: 22, c: 7 };
const FOG_RADIUS = 8;

const FIELD_OBJECT_PROB = [
    { code: 5301, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
    { code: 5302, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
    { code: 5311, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
    { code: 5312, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
    { code: 5321, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
    { code: 5322, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
    { code: 5331, fields: [0, 50, 50, 0, 0], min: 1, max: 2 },
    { code: 5332, fields: [0, 0, 30, 70, 0], min: 1, max: 2 },
    { code: 1801, fields: [50, 50, 0, 0, 0], min: 24, max: 32 },
    { code: 1802, fields: [0, 50, 50, 0, 0], min: 12, max: 16 },
    { code: 1803, fields: [0, 0, 50, 50, 0], min: 6, max: 8 },
    { code: 1804, fields: [0, 0, 0, 50, 50], min: 3, max: 5 },
    { code: 1805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1811, fields: [50, 50, 0, 0, 0], min: 24, max: 32 },
    { code: 1812, fields: [0, 50, 50, 0, 0], min: 12, max: 16 },
    { code: 1813, fields: [0, 0, 50, 50, 0], min: 6, max: 8 },
    { code: 1814, fields: [0, 0, 0, 50, 50], min: 3, max: 5 },
    { code: 1815, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1821, fields: [0, 0, 50, 50, 0], min: 8, max: 12 },
    { code: 1822, fields: [0, 0, 0, 50, 50], min: 4, max: 6 },
    { code: 1823, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1824, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1825, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2101, fields: [0, 20, 20, 30, 30], min: 8, max: 16 },
    { code: 2102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2201, fields: [0, 20, 20, 30, 30], min: 8, max: 16 },
    { code: 2202, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2203, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2204, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2205, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2301, fields: [0, 20, 20, 30, 30], min: 8, max: 16 },
    { code: 2302, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2303, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2304, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2305, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2801, fields: [0, 30, 30, 40, 0], min: 10, max: 20 },
    { code: 2802, fields: [0, 10, 20, 30, 40], min: 5, max: 10 },
    { code: 2803, fields: [0, 0, 0, 30, 70], min: 2, max: 5 },
    { code: 2804, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3101, fields: [0, 20, 20, 30, 30], min: 15, max: 30 },
    { code: 3102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
];

const FIELD_OBJECT_REGEN = [
    { code: 1801, fields: [50, 50, 0, 0, 0], min: 8, max: 16 },
    { code: 1802, fields: [0, 50, 50, 0, 0], min: 4, max: 8 },
    { code: 1803, fields: [0, 0, 50, 50, 0], min: 2, max: 4 },
    { code: 1804, fields: [0, 0, 0, 50, 50], min: 1, max: 2 },
    { code: 1805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1811, fields: [50, 50, 0, 0, 0], min: 8, max: 16 },
    { code: 1812, fields: [0, 50, 50, 0, 0], min: 4, max: 8 },
    { code: 1813, fields: [0, 0, 50, 50, 0], min: 2, max: 4 },
    { code: 1814, fields: [0, 0, 0, 50, 50], min: 1, max: 2 },
    { code: 1815, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1821, fields: [0, 0, 50, 50, 0], min: 1, max: 2 },
    { code: 1822, fields: [0, 0, 0, 50, 50], min: 0, max: 0 },
    { code: 1823, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1824, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 1825, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2101, fields: [0, 20, 20, 30, 30], min: 1, max: 2 },
    { code: 2102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2201, fields: [0, 20, 20, 30, 30], min: 1, max: 2 },
    { code: 2202, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2203, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2204, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2205, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2301, fields: [0, 20, 20, 30, 30], min: 1, max: 2 },
    { code: 2302, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2303, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2304, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2305, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2801, fields: [0, 30, 30, 40, 0], min: 4, max: 8 },
    { code: 2802, fields: [0, 10, 20, 30, 40], min: 2, max: 4 },
    { code: 2803, fields: [0, 0, 0, 30, 70], min: 1, max: 2 },
    { code: 2804, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 2805, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3101, fields: [0, 20, 20, 30, 30], min: 2, max: 4 },
    { code: 3102, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3103, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3104, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
    { code: 3105, fields: [0, 0, 0, 0, 0], min: 0, max: 0 },
];

const OBJECT_REGEN_INTERVAL_MIN = 10;
const OBJECT_REGEN_INTERVAL_MS = OBJECT_REGEN_INTERVAL_MIN * 60 * 1000;


function getTerrainGroupFromCode(code) {
    const base = getTerrainBase(code);
    if (base === 100) return 1;
    if (base === 200) return 2;
    if (base === 300) return 3;
    if (base === 400) return 4;
    if (base === 500) return 5;
    return null;
}

function pickWeightedGroup(weights, pools) {
    const candidates = weights.map((weight, idx) => ({ group: idx + 1, weight, size: pools[idx + 1]?.length || 0 }));
    const eligible = candidates.filter(c => c.weight > 0 && c.size > 0);
    if (eligible.length === 0) {
        const fallback = candidates.filter(c => c.size > 0);
        if (fallback.length === 0) return null;
        return fallback[Math.floor(Math.random() * fallback.length)].group;
    }
    const total = eligible.reduce((sum, c) => sum + c.weight, 0);
    let roll = Math.random() * total;
    for (const c of eligible) {
        roll -= c.weight;
        if (roll <= 0) return c.group;
    }
    return eligible[eligible.length - 1].group;
}

function pickFromPool(group, pools) {
    const pool = pools[group];
    if (!pool || pool.length === 0) return null;
    const idx = Math.floor(Math.random() * pool.length);
    return pool.splice(idx, 1)[0];
}

function buildTerrainPools() {
    const pools = { 1: [], 2: [], 3: [], 4: [], 5: [] };
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const type = FIELD_MAP_DATA[r][c];
            if (!isTerrainCode(type) || isBorderTerrain(type)) continue;
            const group = getTerrainGroupFromCode(type);
            if (group) pools[group].push({ r, c });
        }
    }
    return pools;
}

function applyObjectProbPlacements() {
    const pools = buildTerrainPools();
    const placements = [];
    FIELD_OBJECT_PROB.forEach(entry => {
        const min = entry.min || 0;
        const max = entry.max || 0;
        if (max <= 0) return;
        const count = min === max ? min : (min + Math.floor(Math.random() * (max - min + 1)));
        for (let i = 0; i < count; i++) {
            const group = pickWeightedGroup(entry.fields, pools);
            let cell = group ? pickFromPool(group, pools) : null;
            if (!cell) {
                const fallback = Object.keys(pools).map(n => parseInt(n, 10)).filter(g => pools[g].length > 0);
                if (fallback.length === 0) break;
                const g = fallback[Math.floor(Math.random() * fallback.length)];
                cell = pickFromPool(g, pools);
            }
            if (!cell) break;
            FIELD_MAP_DATA[cell.r][cell.c] = entry.code;
            placements.push({ r: cell.r, c: cell.c, code: entry.code });
        }
    });
    return placements;
}

function applyObjectProbToMap() {
    if (typeof window === 'undefined') return;
    const key = 'kov_field_object_prob_v1';
    let placements = null;
    try {
        const raw = localStorage.getItem(key);
        if (raw) placements = JSON.parse(raw);
    } catch (e) { }
    if (!Array.isArray(placements)) {
        placements = applyObjectProbPlacements();
        try {
            localStorage.setItem(key, JSON.stringify(placements));
        } catch (e) { }
    } else {
        let changed = false;
        const next = [];
        placements.forEach(p => {
            if (!FIELD_MAP_DATA[p.r] || typeof FIELD_MAP_DATA[p.r][p.c] === 'undefined') { changed = true; return; }
            const base = FIELD_TERRAIN_DATA?.[p.r]?.[p.c];
            if (isWallTile(base) || isBorderTerrain(FIELD_MAP_DATA[p.r][p.c]) || isBorderTerrain(base)) {
                if (base !== undefined && base !== null) FIELD_MAP_DATA[p.r][p.c] = base;
                changed = true;
                return;
            }
            if (!isTerrainCode(FIELD_MAP_DATA[p.r][p.c])) { changed = true; return; }
            FIELD_MAP_DATA[p.r][p.c] = p.code;
            next.push(p);
        });
        if (changed) {
            try { localStorage.setItem(key, JSON.stringify(next)); } catch (e) { }
        }
    }
}

applyObjectProbToMap();

function purgeBorderObjects() {
    let changed = false;
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const base = FIELD_TERRAIN_DATA?.[r]?.[c];
            if (!isBorderTerrain(base) && !isWallTile(base)) continue;
            if (isTerrainCode(FIELD_MAP_DATA[r][c])) continue;
            FIELD_MAP_DATA[r][c] = base;
            changed = true;
        }
    }
    return changed;
}

purgeBorderObjects();

function buildRegenPools() {
    const pools = { 1: [], 2: [], 3: [], 4: [], 5: [] };
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const base = FIELD_TERRAIN_DATA?.[r]?.[c];
            if (!isTerrainCode(base) || isBorderTerrain(base)) continue;
            if (!isTerrainCode(FIELD_MAP_DATA[r][c])) continue;
            const group = getTerrainGroupFromCode(base);
            if (group) pools[group].push({ r, c });
        }
    }
    return pools;
}

function countFieldObjects() {
    const counts = {};
    for (let r = 0; r < FIELD_MAP_DATA.length; r++) {
        for (let c = 0; c < FIELD_MAP_DATA[r].length; c++) {
            const code = FIELD_MAP_DATA[r][c];
            counts[code] = (counts[code] || 0) + 1;
        }
    }
    return counts;
}

function applyObjectRegenCycle(regenByCode, regenTargets, now) {
    const pools = buildRegenPools();
    const counts = countFieldObjects();
    const placements = [];
    FIELD_OBJECT_REGEN.forEach(entry => {
        const max = entry.max || 0;
        const min = entry.min || 0;
        if (max <= 0) return;
        const current = counts[entry.code] || 0;
        if (!regenTargets[entry.code]) {
            const span = Math.max(0, max - min);
            regenTargets[entry.code] = min + (span > 0 ? Math.floor(Math.random() * (span + 1)) : 0);
        }
        const target = regenTargets[entry.code];
        if (current >= target) return;
        const last = regenByCode?.[entry.code] || 0;
        if (now - last < OBJECT_REGEN_INTERVAL_MS) return;

        const group = pickWeightedGroup(entry.fields, pools);
        let cell = group ? pickFromPool(group, pools) : null;
        if (!cell) {
            const fallback = Object.keys(pools).map(n => parseInt(n, 10)).filter(g => pools[g].length > 0);
            if (fallback.length === 0) return;
            const g = fallback[Math.floor(Math.random() * fallback.length)];
            cell = pickFromPool(g, pools);
        }
        if (!cell) return;
        FIELD_MAP_DATA[cell.r][cell.c] = entry.code;
        counts[entry.code] = current + 1;
        placements.push({ r: cell.r, c: cell.c, code: entry.code });
        if (regenByCode) regenByCode[entry.code] = now;
    });
    return placements;
}

// Helper Functions
function getCode(type, level) {
    if (type === ITEM_TYPE.UNIT_INFANTRY) return 1100 + level;
    if (type === ITEM_TYPE.UNIT_ARCHER) return 1200 + level;
    if (type === ITEM_TYPE.UNIT_CAVALRY) return 1300 + level;
    if (type === ITEM_TYPE.BUILDING_BARRACKS) return 2100 + level;
    if (type === ITEM_TYPE.BUILDING_RANGE) return 2200 + level;
    if (type === ITEM_TYPE.BUILDING_STABLE) return 2300 + level;
    if (type === ITEM_TYPE.BUILDING_CHEST) return 2800 + level;
    if (type === ITEM_TYPE.BUILDING_CAMP) return 3100 + level;
    if (type === ITEM_TYPE.ITEM_GOLD) return 1800 + level;
    if (type === ITEM_TYPE.ITEM_ENERGY) return 1810 + level;
    if (type === ITEM_TYPE.ITEM_CRYSTAL) return 1820 + level;
    return 0;
}
function getInfoFromCode(code) {
    if (code >= 1100 && code < 1200) return { type: ITEM_TYPE.UNIT_INFANTRY, level: code % 100 };
    if (code >= 1200 && code < 1300) return { type: ITEM_TYPE.UNIT_ARCHER, level: code % 100 };
    if (code >= 1300 && code < 1400) return { type: ITEM_TYPE.UNIT_CAVALRY, level: code % 100 };
    if (code >= 2100 && code < 2110) return { type: ITEM_TYPE.BUILDING_BARRACKS, level: code - 2100 };
    if (code >= 2200 && code < 2210) return { type: ITEM_TYPE.BUILDING_RANGE, level: code - 2200 };
    if (code >= 2300 && code < 2310) return { type: ITEM_TYPE.BUILDING_STABLE, level: code - 2300 };
    if (code >= 2800 && code < 2810) return { type: ITEM_TYPE.BUILDING_CHEST, level: code - 2800 };
    if (code >= 3100 && code < 3110) return { type: ITEM_TYPE.BUILDING_CAMP, level: code - 3100 };
    if (code >= 1800 && code < 1810) return { type: ITEM_TYPE.ITEM_GOLD, level: code - 1800 };
    if (code >= 1810 && code < 1820) return { type: ITEM_TYPE.ITEM_ENERGY, level: code - 1810 };
    if (code >= 1820 && code < 1830) return { type: ITEM_TYPE.ITEM_CRYSTAL, level: code - 1820 };
    return null;
}
function getData(type, level) {
    if (type >= 20) {
        if (type === ITEM_TYPE.ITEM_GOLD) return { name: "골드", earn: ITEM_VALUES[level] };
        if (type === ITEM_TYPE.ITEM_ENERGY) return { name: "에너지", earn: ITEM_VALUES[level] };
        if (type === ITEM_TYPE.ITEM_CRYSTAL) return { name: "크리스탈", earn: ITEM_VALUES[level] };
    }
    if (type < 10) {
        if (type === ITEM_TYPE.BUILDING_BARRACKS) return { name: "병영", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_BARRACKS][level]?.energy };
        if (type === ITEM_TYPE.BUILDING_RANGE) return { name: "사격장", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_RANGE][level]?.energy };
        if (type === ITEM_TYPE.BUILDING_STABLE) return { name: "마구간", energy: BUILDING_DATA[ITEM_TYPE.BUILDING_STABLE][level]?.energy };
        if (type === ITEM_TYPE.BUILDING_CHEST) return { name: "보물상자" };
        if (type === ITEM_TYPE.BUILDING_CAMP) return { name: "막사" };
    }
    if (type >= 10 && type < 20) {
        const code = getCode(type, level);
        const stat = UNIT_STATS[code];
        if (stat) return { name: stat.name, class: type === 10 ? "보병" : (type === 11 ? "궁병" : "기병"), hp: stat.hp, atk: stat.atk, def: stat.def, spd: stat.spd, rng: stat.rng, mov: stat.mov, sell: stat.sell };
    }
    return { name: "Unknown", earn: 0, sell: 0 };
}

// --- DUMMY DATA FOR SOCIAL ---
const DUMMY_CHAT_MESSAGES = [
    "[시스템] 환영합니다! 공지: 매너 채팅 부탁드립니다.",
    "[월드] 라그나로크: 드래곤 잡으실 분 구해요 (3/4)",
    "[월드] 뉴비가이드: 5성 유닛 어디서 얻나요?",
    "[길드] 왕국수호대: 오늘 길드전 20시 필참입니다.",
    "[시스템] '전설의 기사'님이 '다이아 상자'에서 [신궁]을 획득하셨습니다!",
    "[월드] 상인조합: 골드 대량 매입합니다 귓 주세요.",
    "[월드] 즐겜유저: 아... 강화 또 터졌네 ㅠㅠ",
    "[시스템] 핫타임 이벤트가 시작되었습니다! (경험치 +50%)"
];

const USER_TITLES = ["견습 기사", "왕국 수호자", "드래곤 슬레이어", "부호", "전략의 신"];

// --- CLASSES ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true; this.bgmStarted = false;
        const BASE = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/audio/`;
        this.files = { bgm: new Audio(BASE + 'bgm.mp3'), merge: new Audio(BASE + 'merge.mp3'), coin: new Audio(BASE + 'coin.mp3'), pop: new Audio(BASE + 'pop.mp3') };
        this.files.bgm.loop = true; this.files.bgm.volume = 0.5;
    }
    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); if (this.enabled && !this.bgmStarted) { this.files.bgm.play().then(() => this.bgmStarted = true).catch(() => { }); } }
    playFile(n, v = 1.0) { if (!this.enabled || !this.files[n]) return; const s = this.files[n].cloneNode(); s.crossOrigin = "anonymous"; s.volume = v; s.play().catch(() => { }); }
    playTone(f, t, d) { if (!this.enabled) return; const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.type = t; o.frequency.value = f; g.gain.setValueAtTime(0.1, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d); o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + d); }
    playClick() { this.playFile('pop', 0.6); }
    playError() { this.playTone(150, 'sawtooth', 0.3); }
    playSpawn() { this.playFile('pop', 0.5); }
    playMerge() { this.playFile('merge', 0.8); }
    playCollect() { this.playFile('coin', 0.6); }
    playUnlock() { this.playFile('merge', 0.8); }
    playLevelUp() { [440, 554, 659, 880].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.3), i * 100)); }
}

class AssetLoader {
    constructor() { this.images = {}; }
    loadAll(cb) {
        let loaded = 0;
        ASSET_KEYS.forEach(key => {
            const img = new Image(); img.crossOrigin = "Anonymous";
            img.onload = () => { this.images[key] = img; loaded++; if (loaded === ASSET_KEYS.length) cb(); };
            img.onerror = () => {
                const ext = key === 'field_bg' ? '.jpg' : '.png';
                img.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/img/${key}${ext}`;
                loaded++; if (loaded === ASSET_KEYS.length) cb();
            };
            img.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/img/${key}.png`;
        });
        setTimeout(cb, 2000);
    }
    getImage(type, level) {
        if (typeof type === 'string') return this.images[type];
        const code = getCode(type, level);
        return this.images[code] || (level > 1 ? this.getImage(type, level - 1) : null);
    }
}

class Particle {
    constructor(x, y, color, type) {
        this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8;
        this.life = 1.0; this.decay = Math.random() * 0.03 + 0.02; this.color = color; this.size = Math.random() * 6 + 4; this.type = type;
        if (type === 'smoke') { this.vy = -Math.abs(this.vy) * 0.5; this.decay = 0.015; }
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; if (this.type === 'smoke') this.size += 0.3; else this.vy += 0.2; }
    draw(ctx) { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; if (this.type === 'confetti') { ctx.translate(this.x, this.y); ctx.rotate(this.life * 5); ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size); ctx.resetTransform(); const s = ctx.canvas.width / 1080; ctx.scale(s, s); } else if (this.type === 'smoke') { ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } else ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1.0; }
}

class AStar {
    static findPath(start, end, mapData, occupiedTiles, isBlockedFn) {
        const rows = MAP_SIZE, cols = MAP_SIZE;
        const openSet = [], closedSet = new Set();
        const startNode = { r: start.r, c: start.c, g: 0, h: 0, f: 0, parent: null };
        openSet.push(startNode);

        while (openSet.length > 0) {
            let lowInd = 0;
            for (let i = 0; i < openSet.length; i++) if (openSet[i].f < openSet[lowInd].f) lowInd = i;
            const current = openSet[lowInd];

            if (current.r === end.r && current.c === end.c) {
                const path = []; let temp = current;
                while (temp) { path.push({ r: temp.r, c: temp.c }); temp = temp.parent; }
                return path.reverse();
            }

            openSet.splice(lowInd, 1);
            closedSet.add(`${current.r},${current.c}`);

            const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (let i = 0; i < neighbors.length; i++) {
                const nr = current.r + neighbors[i][0], nc = current.c + neighbors[i][1];
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    if (closedSet.has(`${nr},${nc}`)) continue;

                    const type = mapData[nr][nc];
                    const isTarget = (nr === end.r && nc === end.c);
                    const isOccupied = occupiedTiles.has(`${nr},${nc}`);

                    let isWalkable = true;
                    if (isBlockedFn) {
                        if (isBlockedFn(current, nr, nc, type, isOccupied, isTarget)) isWalkable = false;
                    } else if (isBlockingField(type) && !isOccupied && !isTarget) {
                        isWalkable = false;
                    }

                    if (!isWalkable) continue;

                    const gScore = current.g + 1;
                    let neighbor = openSet.find(n => n.r === nr && n.c === nc);

                    if (!neighbor) {
                        neighbor = { r: nr, c: nc, g: gScore, h: Math.abs(nr - end.r) + Math.abs(nc - end.c), f: 0, parent: current };
                        neighbor.f = neighbor.g + neighbor.h;
                        openSet.push(neighbor);
                    } else if (gScore < neighbor.g) {
                        neighbor.g = gScore; neighbor.f = neighbor.g + neighbor.h; neighbor.parent = current;
                    }
                }
            }
        }
        return null;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        this.width = 1080; this.height = 1920; this.assets = new AssetLoader(); this.sound = new SoundManager();
        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null); this.squad2 = Array(9).fill(null); this.squad3 = Array(9).fill(null);
        this.particles = [];
        this.lordLevel = 1; this.currentXp = 0;
        this.energy = 50; this.gold = 3000; this.gems = 100; this.points = 0; // Gem/Point Added
        this.cp = 20;

        // Phase 4: Social & BM State
        this.userProfile = {
            name: "전설의 유저",
            title: "견습 기사",
            avatar: 1, // 1~5
            vip: 0,
            winRate: 0,
            totalPVP: 0,
            totalCP: 0
        };
        this.chatLog = [];
        this.adWatchCount = 0;
        this.isChatOpen = false;
        this.baseMaxCp = 20; this.baseCpRegen = 1;
        this.cpBonus = 0; this.cpRegenBonus = 0;
        this.maxCp = this.baseMaxCp; this.cpRegen = this.baseCpRegen;

        this.occupiedTiles = new Set();
        this.fieldEvents = {}; // key: "r,c", value: { type, data }
        this.initFieldMap();
        this.populateFieldEvents(); // Generate Random Events
        this.occupiedTiles.add(`${PLAYER_START.r},${PLAYER_START.c}`);
        this.income = 0;

        this.selectedArmyId = null;
        this.lastSelectedArmyId = null;
        this.currentFieldTargetKey = null;
        this.currentFieldTargetType = null;
        this.fieldResourceState = {};
        this.fieldShopState = {};
        this.currentShopContext = null;
        this.shopTimer = null;
        this.fieldObjectState = {};
        this.fieldBuffs = { atk: 0, def: 0, hp: 0, spd: 0 };
        this.citadelCount = 0;
        this.thirdSquadUnlocked = false;
        this.moveTargetMode = null;
        this.previewPath = null;
        this.movePreviewText = "";
        this.isResetting = false;
        this.effectLog = [];
        this.openBorderTiles = new Set();
        this.fieldRegions = null;

        this.visibilityMap = new Set();
        this.revealFog(PLAYER_START.r, PLAYER_START.c, FOG_RADIUS);

        this.grassTexture = this.createGrassPattern();

        this.settings = { bgm: true, sfx: true };

        this.drag = null; this.hover = null; this.selectedItem = null; this.potentialDrag = null; this.dpr = window.devicePixelRatio || 1;

        this.armies = [
            { id: 0, name: "제1부대", color: "#4caf50", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 },
            { id: 1, name: "제2부대", color: "#2196f3", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 },
            { id: 2, name: "제3부대", color: "#f59e0b", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 }
        ];

        this.calcLayout();
        const resetFlag = localStorage.getItem('kov_force_reset') === '1';
        if (resetFlag) {
            try {
                localStorage.removeItem('kov_force_reset');
                localStorage.removeItem('kov_save_v1');
                localStorage.removeItem('kov_field_object_prob_v1');
                localStorage.removeItem('kov_uid');
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('kov_')) localStorage.removeItem(key);
                }
            } catch (e) { }
        }
        if (!resetFlag && this.loadGame()) { this.updateLevelStats(); }
        else { this.initGame(); }
        this.recalcFieldBonuses();
        this.buildFieldRegions();
        this.updateOpenBorders();
        this.updateUI();

        setInterval(() => this.regenEnergy(), 1000);
        setInterval(() => this.regenCp(), 1000);
        setInterval(() => this.collectTerritoryIncome(), 3000);
        setInterval(() => this.collectTerritoryIncome(), 3000);
        this.initObjectRegen();
        this.initSocialUI(); // Phase 4 Injection
        window.addEventListener('resize', () => { this.resize(); this.requestRender(); });
        this.resize(); this.setupInput();
        this.assets.loadAll(() => { this.requestRender(); });
        this.loop(); this.updateUI();

        if (!localStorage.getItem('kov_uid')) localStorage.setItem('kov_uid', 'U' + Math.floor(Math.random() * 1000000));
        document.getElementById('settings-uid').innerText = localStorage.getItem('kov_uid');
    }

    closeAllModals() {
        console.log("Force closing all modals");
        document.querySelectorAll('.modal-overlay').forEach(el => {
            el.classList.remove('open');
            el.style.display = 'none';
        });
        this.battleContext = null;
    }

    createGrassPattern() {
        const c = document.createElement('canvas');
        c.width = 32; c.height = 32;
        const x = c.getContext('2d');
        x.fillStyle = '#4a6e3a';
        x.fillRect(0, 0, 32, 32);
        for (let i = 0; i < 30; i++) {
            x.fillStyle = Math.random() > 0.5 ? '#567d46' : '#3e5c30';
            const px = Math.floor(Math.random() * 32);
            const py = Math.floor(Math.random() * 32);
            x.fillRect(px, py, 1, 1);
        }
        return c.toDataURL();
    }

    saveGame() {
        try {
            if (this.isResetting || localStorage.getItem('kov_force_reset') === '1') return;
            const data = {
                grid: this.grid, gridState: this.gridState, squad1: this.squad1, squad2: this.squad2, squad3: this.squad3,
                lordLevel: this.lordLevel, currentXp: this.currentXp, energy: this.energy, gold: this.gold, gem: this.gem,
                cp: this.cp, maxCp: this.maxCp,
                occupiedTiles: Array.from(this.occupiedTiles), settings: this.settings,
                visibilityMap: Array.from(this.visibilityMap),
                lastSelectedArmyId: this.lastSelectedArmyId,
                fieldResourceState: this.fieldResourceState,
                fieldShopState: this.fieldShopState,
                fieldObjectState: this.fieldObjectState,
                fieldBuffs: this.fieldBuffs,
                armies: this.armies
            };
            localStorage.setItem('kov_save_v1', JSON.stringify(data));
        } catch (e) { }
    }
    loadGame() {
        try {
            const saved = localStorage.getItem('kov_save_v1'); if (!saved) return false;
            const data = JSON.parse(saved);
            const isValidGrid = (grid) => Array.isArray(grid) && grid.length === CONFIG.gridRows && grid.every(row => Array.isArray(row) && row.length === CONFIG.gridCols);
            const isValidSquad = (squad) => Array.isArray(squad) && squad.length === 9;
            const validGrid = isValidGrid(data.grid);
            const validGridState = isValidGrid(data.gridState);
            if (!validGrid) {
                try { localStorage.removeItem('kov_save_v1'); } catch (e) { }
                return false;
            }
            this.grid = data.grid;
            this.gridState = validGridState ? data.gridState : this.gridState;
            this.squad1 = isValidSquad(data.squad1) ? data.squad1 : this.squad1;
            this.squad2 = isValidSquad(data.squad2) ? data.squad2 : this.squad2;
            this.squad3 = isValidSquad(data.squad3) ? data.squad3 : this.squad3;
            this.lordLevel = data.lordLevel || 1; this.currentXp = data.currentXp || 0;
            this.energy = data.energy ?? 50; this.gold = data.gold ?? 3000; this.gem = data.gem ?? 50;
            this.cp = data.cp ?? 20; this.maxCp = data.maxCp ?? 20;
            if (data.occupiedTiles) this.occupiedTiles = new Set(data.occupiedTiles);
            if (data.visibilityMap) this.visibilityMap = new Set(data.visibilityMap);
            if (data.lastSelectedArmyId !== undefined) this.lastSelectedArmyId = data.lastSelectedArmyId;
            if (data.fieldResourceState) this.fieldResourceState = data.fieldResourceState;
            if (data.fieldShopState) this.fieldShopState = data.fieldShopState;
            if (data.fieldObjectState) this.fieldObjectState = data.fieldObjectState;
            if (data.fieldBuffs) this.fieldBuffs = data.fieldBuffs;
            if (data.settings) { this.settings = data.settings; this.applySettings(); }
            if (data.armies) {
                this.armies = data.armies;
                if (this.armies.length < 3) {
                    this.armies.push({ id: 2, name: "제3부대", color: "#f59e0b", state: 'IDLE', r: PLAYER_START.r, c: PLAYER_START.c, path: [], nextStepIndex: 0, target: null, lastMoveTime: 0, moveInterval: 0 });
                }
            }
            if (!validGridState) this.refreshLockState();
            if (!this.occupiedTiles || this.occupiedTiles.size === 0) this.occupiedTiles = new Set([`${PLAYER_START.r},${PLAYER_START.c}`]);
            else this.occupiedTiles.add(`${PLAYER_START.r},${PLAYER_START.c}`);
            this.revealFog(PLAYER_START.r, PLAYER_START.c, FOG_RADIUS);
            return true;
        } catch (e) {
            try { localStorage.removeItem('kov_save_v1'); } catch (err) { }
            return false;
        }
    }
    resetGame() {
        if (confirm("정말 게임을 초기화 하시겠습니까?")) {
            this.isResetting = true;
            try {
                localStorage.setItem('kov_force_reset', '1');
                localStorage.removeItem('kov_save_v1');
                localStorage.removeItem('kov_field_object_prob_v1');
                localStorage.removeItem('kov_uid');
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('kov_')) localStorage.removeItem(key);
                }
                if (localStorage.getItem('kov_save_v1')) {
                    localStorage.clear();
                }
            } catch (e) { }
            window.location.reload();
        }
    }

    openSettings() { document.getElementById('modal-settings').classList.add('open'); }
    toggleSetting(key, el) {
        this.settings[key] = !this.settings[key]; el.classList.toggle('on');
        const knob = el.querySelector('.toggle-knob'); knob.style.left = this.settings[key] ? '22px' : '2px';
        if (key === 'bgm') { if (this.settings.bgm) this.sound.files.bgm.play().catch(() => { }); else this.sound.files.bgm.pause(); }
        this.sound.enabled = this.settings.sfx; this.saveGame();
    }
    applySettings() { this.sound.enabled = this.settings.sfx; }
    openRefill(type) {
        const modal = document.getElementById('modal-refill'); const content = document.getElementById('refill-options'); const title = document.getElementById('refill-title');
        content.innerHTML = ""; modal.classList.add('open');
        let data = REFILL_DATA[type];
        title.innerText = type === 'energy' ? "에너지 충전" : (type === 'gold' ? "골드 구매" : (type === 'cp' ? "지휘력 충전" : "크리스탈 상점"));
        data.forEach(item => {
            const btn = document.createElement('button'); btn.className = "bg-gray-700 hover:bg-gray-600 p-4 rounded-lg flex justify-between items-center text-white border border-gray-600";
            btn.innerHTML = `<span class="font-bold">${item.name}</span><span class="bg-blue-600 px-3 py-1 rounded text-sm">${item.currency === 'usd' ? '$' + item.cost : '💎 ' + item.cost}</span>`;
            btn.onclick = () => {
                if (item.currency === 'crystal') {
                    if (this.gem >= item.cost) {
                        this.gem -= item.cost;
                        if (type === 'energy') this.energy += item.amount;
                        else if (type === 'cp') this.cp += item.amount;
                        else this.gold += item.amount;
                        this.sound.playCollect(); this.updateUI(); modal.classList.remove('open');
                    }
                    else { this.showToast("💎 크리스탈이 부족합니다."); this.sound.playError(); }
                } else this.showToast("인앱 결제 준비 중입니다.");
            }; content.appendChild(btn);
        });
    }
    showLevelUpModal(prevLv, prevEn) {
        document.getElementById('lv-old').innerText = prevLv; document.getElementById('lv-new').innerText = this.lordLevel;
        document.getElementById('en-old').innerText = prevEn; const d = LEVEL_DATA.find(d => d.level === this.lordLevel); document.getElementById('en-new').innerText = d ? d.maxEnergy : 50;
        document.getElementById('modal-levelup').classList.add('open'); const banner = document.getElementById('levelup-banner'); banner.classList.remove('show'); void banner.offsetWidth; banner.classList.add('show'); setTimeout(() => banner.classList.remove('show'), 2500);
    }

    requestRender() { this.isDirty = true; }
    spawnParticles(x, y, color, count, type) { for (let i = 0; i < count; i++) this.particles.push(new Particle(x, y, color, type)); this.isDirty = true; }
    regenEnergy() {
        // Logic for Energy Fountain (Type 6)
        let regenBonus = 1;
        this.occupiedTiles.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            if (isFountainTile(FIELD_MAP_DATA[r][c])) regenBonus += 1;
        });

        if (this.energy < this.maxEnergy) {
            this.energyRegenAcc = (this.energyRegenAcc || 0) + regenBonus;
            if (this.energyRegenAcc >= 5) {
                this.energy++; this.energyRegenAcc = 0; this.updateUI();
            }
        }
    }
    regenCp() {
        if (this.cp < this.maxCp) {
            this.cpRegenAcc = (this.cpRegenAcc || 0) + this.cpRegen;
            if (this.cpRegenAcc >= 5) {
                this.cp++; this.cpRegenAcc = 0; this.updateUI();
            }
        }
    }
    initObjectRegen() {
        if (!this.fieldObjectState) this.fieldObjectState = {};
        if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
        if (!this.fieldObjectState.regenTargetByCode) this.fieldObjectState.regenTargetByCode = {};
        const now = Date.now();
        FIELD_OBJECT_REGEN.forEach(entry => {
            if ((entry.max || 0) <= 0) return;
            if (this.fieldObjectState.regenByCode[entry.code] === undefined) {
                this.fieldObjectState.regenByCode[entry.code] = now;
            }
            if (this.fieldObjectState.regenTargetByCode[entry.code] === undefined) {
                const min = entry.min || 0;
                const max = entry.max || 0;
                const span = Math.max(0, max - min);
                this.fieldObjectState.regenTargetByCode[entry.code] = min + (span > 0 ? Math.floor(Math.random() * (span + 1)) : 0);
            }
        });
        if (this.objectRegenTimer) clearInterval(this.objectRegenTimer);
        this.objectRegenTimer = setInterval(() => this.runObjectRegen(), 1000);
    }
    runObjectRegen() {
        const now = Date.now();
        if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
        if (!this.fieldObjectState.regenTargetByCode) this.fieldObjectState.regenTargetByCode = {};
        const placements = applyObjectRegenCycle(this.fieldObjectState.regenByCode, this.fieldObjectState.regenTargetByCode, now);
        if (placements.length > 0) {
            if (document.getElementById('field-modal').classList.contains('open') && !this.moveTargetMode) {
                this.renderFieldMap();
            } else {
                this.requestRender();
            }
        }
        this.saveGame();
    }
    getTaxRate(type) {
        const data = this.getFieldObjectData(type);
        if (!data) return 1; // Default
        // Assuming TAX is ability code 200 (or similar, check ABILITY_CODES if available, otherwise heuristic)
        // ACTUALLY: Let's use getAbilityValue with ABILITY_CODES.TAX if it exists, otherwise fallback to known structure
        // Since ABILITY_CODES might not be fully populated in game.js context yet (loaded from window), let's use the helper.
        // We need to know the code for TAX. If ABILITY_CODES is loaded, use it.
        // Based on previous files, ABILITY_CODES was initialized.
        const tax = this.getAbilityValue(data, ABILITY_CODES.TAX);
        return tax > 0 ? tax : 1;
    }

    getUpkeepCost(type) {
        const data = this.getFieldObjectData(type);
        if (!data) return 0;
        const upkeep = this.getAbilityValue(data, ABILITY_CODES.UPKEEP);
        return upkeep || 0;
    }
    getTileMoveTime(type, r, c) {
        // 타입: 기본 FIELD_MAP_DATA(0~6) + 지형 기본 코드(100~501)
        if (isGateTile(type) || isCitadelTile(type)) return 5;
        if (isDragonTile(type)) return 6;
        if (type === 4) return 1; // 도로

        let evalType = type;
        if (!isTerrainCode(type) && typeof r === "number" && typeof c === "number") {
            const base = FIELD_TERRAIN_DATA?.[r]?.[c];
            if (isTerrainCode(base)) evalType = base;
        }
        if (isTerrainCode(evalType)) {
            const base = getTerrainBase(evalType);
            if (base === 100) return 3; // 평원
            if (base === 200) return 5; // 숲
            if (base === 300) return 4; // 고원
            if (base === 400) return 5; // 산악
            if (base === 500) return 6; // 화산
            return 3;
        }
        return 3; // 기본 지형
    }
    getTileMoveMeta(type, r, c) {
        let name = "지형";
        if (type === 4) name = "도로";
        else if (isGateTile(type)) name = "관문";
        else if (isCitadelTile(type)) name = "성채";
        else if (isDragonTile(type)) name = "드래곤";
        else {
            let evalType = type;
            if (!isTerrainCode(type) && typeof r === "number" && typeof c === "number") {
                const base = FIELD_TERRAIN_DATA?.[r]?.[c];
                if (isTerrainCode(base)) evalType = base;
            }
            if (isTerrainCode(evalType)) name = getTerrainBaseName(evalType);
        }
        return { name, min: this.getTileMoveTime(type, r, c) };
    }
    getPathTimeMin(path, speedFactor = 1) {
        if (!path || path.length <= 1) return 0;
        let total = 0;
        for (let i = 1; i < path.length; i++) {
            const step = path[i];
            const tileType = FIELD_MAP_DATA[step.r][step.c];
            total += this.getTileMoveTime(tileType, step.r, step.c);
        }
        return total * speedFactor;
    }
    getPathSummary(path, speedFactor = 1) {
        if (!path || path.length <= 1) return { dist: 0, baseMin: 0, finalMin: 0, breakdown: "" };
        const counts = {};
        let total = 0;
        for (let i = 1; i < path.length; i++) {
            const step = path[i];
            const tileType = FIELD_MAP_DATA[step.r][step.c];
            const meta = this.getTileMoveMeta(tileType, step.r, step.c);
            total += meta.min;
            counts[meta.name] = (counts[meta.name] || 0) + 1;
        }
        const breakdown = Object.keys(counts).map(k => `${k}${counts[k]}`).join(" ");
        return { dist: path.length - 1, baseMin: total, finalMin: total * speedFactor, breakdown };
    }
    buildStepTimes(path, speedFactor = 1) {
        if (!path || path.length <= 1) return [];
        const times = [0];
        for (let i = 1; i < path.length; i++) {
            const step = path[i];
            const tileType = FIELD_MAP_DATA[step.r][step.c];
            const mins = this.getTileMoveTime(tileType, step.r, step.c) * speedFactor;
            times[i] = Math.max(30, Math.floor(mins * MOVE_MS_PER_MIN));
        }
        return times;
    }
    collectTerritoryIncome() {
        if (this.occupiedTiles.size > 0) {
            let totalTax = 0;
            let totalUpkeep = 0;
            this.occupiedTiles.forEach(key => {
                const [r, c] = key.split(',').map(Number);
                const type = FIELD_MAP_DATA[r][c];
                totalTax += this.getTaxRate(type);
                totalUpkeep += this.getUpkeepCost(type);
            });
            const net = totalTax - totalUpkeep;
            this.income = net; this.gold += net;
            this.updateUI();
            if (document.getElementById('field-modal').classList.contains('open')) {
                const sign = net >= 0 ? "+" : "";
                this.showFloatingText(`${sign}${net} G (Tax)`, this.width / 2, this.height / 4, net >= 0 ? '#ffd700' : '#f87171');
            }
        } else {
            this.income = 0;
        }
    }
    calcLayout() {
        const gw = this.width - (CONFIG.gridPadding * 2); this.gridTileSize = Math.floor(gw / CONFIG.gridCols);
        this.gridStartX = CONFIG.gridPadding; this.gridStartY = CONFIG.gridTopY;
        const useThird = this.thirdSquadUnlocked;
        const squadSize = useThird ? CONFIG.squadCellSize3 : CONFIG.squadCellSize;
        const squadGap = useThird ? CONFIG.squadGap3 : CONFIG.squadGap;
        this.squadCellSize = squadSize;
        const sw = this.squadCellSize * 3;
        const squadCount = useThird ? 3 : 2;
        const totalSw = (sw * squadCount) + (squadGap * (squadCount - 1));
        const sx = Math.floor((this.width - totalSw) / 2);
        this.squad1Rect = { x: sx, y: CONFIG.squadTopY, w: sw, h: sw };
        this.squad2Rect = { x: sx + sw + squadGap, y: CONFIG.squadTopY, w: sw, h: sw };
        if (useThird) {
            this.squad3Rect = { x: sx + (sw + squadGap) * 2, y: CONFIG.squadTopY, w: sw, h: sw };
        } else {
            this.squad3Rect = null;
        }
    }
    initGame() {
        this.refreshLockState(); this.grid[3][3] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1, usage: 5 };
        this.grid[5][5] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnits: [] }; // Added storedUnits
        this.grid[5][5] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnits: [] }; // Added storedUnits
        this.updateLevelStats();
        this.updateInfoPanel(); // Ensure panel is visible on init
    }
    refreshLockState() {
        for (let r = 0; r < CONFIG.gridRows; r++) for (let c = 0; c < CONFIG.gridCols; c++) {
            if (this.gridState[r][c] && this.gridState[r][c].type === LOCK_TYPE.OPEN) continue;
            const lvlReq = UNLOCK_LEVEL_MAP[r][c], goldReq = UNLOCK_GOLD_MAP[r][c];
            if (this.lordLevel < lvlReq) this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: lvlReq };
            else if (goldReq > 0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: goldReq };
            else this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
        }
        this.requestRender();
    }
    openCaravanShop() {
        // Reuse Shop Modal logic but with Caravan data
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        title.innerText = "🐪 사막 카라반"; content.innerHTML = "";
        modal.dataset.mode = 'caravan'; modal.classList.add('open');

        const grid = document.createElement('div'); grid.className = 'shop-grid';
        // Mock Caravan Items (Randomize later)
        const CARAVAN_ITEMS = [
            { name: "식량 패키지", icon: "🍱", price: 100, type: 9001 },
            { name: "용병 고용", icon: "⚔️", price: 500, type: 9002 },
            { name: "지도 조각", icon: "🗺️", price: 1000, type: 9003 }
        ];

        CARAVAN_ITEMS.forEach(item => {
            const div = document.createElement('div'); div.className = 'shop-item';
            div.innerHTML = `<div class="text-2xl">${item.icon}</div><div class="font-bold text-sm text-white">${item.name}</div><button class="bg-yellow-600 text-white px-3 py-1 mt-2 rounded font-bold text-xs" onclick="game.buyCaravanItem(${item.type}, ${item.price})">💰 ${item.price}</button>`;
            grid.appendChild(div);
        });
        content.appendChild(grid);
    }

    buyCaravanItem(type, price) {
        if (this.gold < price) { this.showToast("골드가 부족합니다."); return; }
        this.gold -= price;
        this.showToast("구매 완료 (기능 미구현)");
        this.updateUI();
    }

    openPortalModal(r, c) {
        // Simple teleport to random location
        const confirm = window.confirm("🌀 포탈을 타시겠습니까? (랜덤 위치로 이동)");
        if (confirm) {
            // Find random safe tile
            let nr, nc;
            let attempts = 0;
            while (attempts < 100) {
                nr = Math.floor(Math.random() * MAP_SIZE);
                nc = Math.floor(Math.random() * MAP_SIZE);
                if (FIELD_MAP_DATA[nr][nc] !== 0 && !isBorderTerrain(FIELD_MAP_DATA[nr][nc])) break;
                attempts++;
            }
            // Move army instantly
            const army = this.armies.find(a => a.state === 'IDLE'); // Simplification: assume active army triggered it
            if (army) {
                army.r = nr; army.c = nc;
                this.revealFog(nr, nc, FOG_RADIUS);
                this.updateArmies();
                this.renderFieldMap();
                this.showToast("🌀 텔레포트 성공!");
            }
        }
    }

    showVictoryModal() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        title.innerText = "🏆 Victory!";
        modal.classList.add('open');
        modal.dataset.mode = 'victory';

        content.innerHTML = `
            <div class="flex flex-col items-center justify-center space-y-4 p-8">
                <div class="text-6xl animate-bounce">🐲</div>
                <div class="text-2xl font-bold text-yellow-300">월드 보스 '에인션트 드래곤' 토벌 성공!</div>
                <div class="text-white text-center">
                    왕국에 평화가 찾아왔습니다.<br>
                    하지만, 더 강력한 적들이 몰려올지도 모릅니다.
                </div>
                <div class="border border-yellow-600 bg-black bg-opacity-50 p-4 rounded text-center w-full">
                    <div class="text-yellow-500 font-bold mb-2">🎁 보상 획득</div>
                    <div class="text-sm">🪙 골드 10,000</div>
                    <div class="text-sm">✨ 모든 아군 스탯 +20% (영구 적용)</div>
                </div>
                <button class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-8 rounded shadow-lg transform hover:scale-105 transition" onclick="game.closeModal()">
                    계속 하기
                </button>
            </div>
        `;

        // Grant Rewards
        this.gold += 10000;
        Object.keys(this.fieldBuffs).forEach(k => this.fieldBuffs[k] += 0.2); // +20% Stats
        this.updateUI();
        this.saveGame();

        // Fireworks Loop
        let fireworks = 0;
        const interval = setInterval(() => {
            if (fireworks++ > 10 || !modal.classList.contains('open')) clearInterval(interval);
            const x = Math.random() * this.width;
            const y = Math.random() * this.height;
            this.spawnParticles(x, y, `hsl(${Math.random() * 360}, 100%, 50%)`, 30, "confetti");
        }, 500);
    }

    toggleShop() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        title.innerText = "건설 상점"; content.innerHTML = "";
        if (modal.classList.contains('open') && modal.dataset.mode === 'shop') { this.closeModal(); return; }
        modal.dataset.mode = 'shop'; modal.classList.add('open');
        const grid = document.createElement('div'); grid.className = 'shop-grid';
        SHOP_DATA.forEach(item => {
            const div = document.createElement('div'); div.className = 'shop-item';
            div.innerHTML = `<div class="text-2xl">${item.icon}</div><div class="font-bold text-sm text-white">${item.name}</div><button class="bg-yellow-600 text-white px-3 py-1 mt-2 rounded font-bold text-xs" onclick="game.buyBuilding(${item.type}, ${item.price})">💰 ${item.price}</button>`;
            grid.appendChild(div);
        });
        content.appendChild(grid);
    }
    toggleField() {
        const modal = document.getElementById('field-modal');
        if (modal.classList.contains('open') && modal.dataset.mode === 'field') { this.closeModal(); return; }
        this.camera = null; this.renderFieldMap();
    }

    initFieldMap() {
        // Initialize field specific data if needed
        // Currently FIELD_MAP_DATA is static, but we might want to deep copy if we modify it
        console.log("Field Map Initialized");
    }

    populateFieldEvents() {
        // Simple random spawner
        // Skip if already populated (e.g. load game) - TODO: Check save data
        if (Object.keys(this.fieldEvents).length > 0) return;

        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const terrain = FIELD_MAP_DATA[r][c];
                // Skip non-walkable or already occupied logic
                if (terrain === 0) continue; // Explicit Wall Skip
                if (isBlockingField(terrain)) continue; // Skip Walls, Gates, etc.
                if (isBorderTerrain(terrain)) continue; // Skip Border
                // Skip Player Start area
                if (Math.abs(r - PLAYER_START.r) < 3 && Math.abs(c - PLAYER_START.c) < 3) continue;

                // Roll for events
                const rand = Math.random() * 1000;
                let cumulative = 0;

                for (const [type, rate] of Object.entries(FIELD_EVENT_RATES)) {
                    cumulative += rate;
                    if (rand < cumulative) {
                        this.fieldEvents[`${r},${c}`] = {
                            type: parseInt(type),
                            id: `evt_${r}_${c}`,
                            r, c
                        };
                        break;
                    }
                }
            }
        }
        console.log(`Generated ${Object.keys(this.fieldEvents).length} field events.`);
    }

    getFieldDefenders(type) {
        if (type === FIELD_EVENT_TYPES.DUNGEON) {
            return [
                { code: ITEM_TYPE.UNIT_CAVALRY, count: 30, slot: 4 },
                { code: ITEM_TYPE.UNIT_INFANTRY, count: 50, slot: 1 },
                { code: ITEM_TYPE.UNIT_ARCHER, count: 50, slot: 7 }
            ];
        }

        if (type === FIELD_EVENT_TYPES.BANDIT) {
            return [
                { code: ITEM_TYPE.UNIT_INFANTRY, count: 10, slot: 4 },
                { code: ITEM_TYPE.UNIT_ARCHER, count: 5, slot: 1 }
            ];
        }

        if (type === FIELD_EVENT_TYPES.BANDIT_LEADER) {
            return [
                { code: ITEM_TYPE.UNIT_CAVALRY, count: 10, slot: 4 },
                { code: ITEM_TYPE.UNIT_INFANTRY, count: 20, slot: 1 },
                { code: ITEM_TYPE.UNIT_ARCHER, count: 20, slot: 7 }
            ];
        }

        // --- BOSS ---
        if (isDragonTile(type)) {
            return [{ code: ITEM_TYPE.UNIT_DRAGON, count: 1, slot: 4 }];
        }

        // Legacy / Standard
        return [];
    }

    revealFog(r, c, radius = FOG_RADIUS) {
        for (let i = -radius; i <= radius; i++) {
            for (let j = -radius; j <= radius; j++) {
                const nr = r + i, nc = c + j;
                if (nr >= 0 && nr < MAP_SIZE && nc >= 0 && nc < MAP_SIZE) {
                    const key = `${nr},${nc}`;
                    if (!this.visibilityMap.has(key)) {
                        this.visibilityMap.add(key);
                        const cell = document.getElementById(`field-cell-${nr}-${nc}`);
                        if (cell) {
                            cell.classList.remove('field-fog');
                            if (!cell.classList.contains('field-occupied') && !cell.classList.contains('field-adjacent')) cell.style.opacity = 0.3;
                            else if (cell.classList.contains('field-adjacent')) cell.style.opacity = 0.6;
                        }
                    }
                }
            }
        }
    }

    setMovePreview(text) {
        this.movePreviewText = text || "";
        const el = document.getElementById('field-move-info');
        if (el) {
            if (this.movePreviewText) {
                el.style.display = 'flex';
                el.innerText = this.movePreviewText;
            } else {
                el.style.display = 'none';
            }
        }
        this.updateFloatingPanelPositionFromSelection();
    }

    openObjectModal(title, bodyHtml) {
        const modal = document.getElementById('modal-object');
        const t = document.getElementById('object-modal-title');
        const b = document.getElementById('object-modal-body');
        if (!modal || !t || !b) return;
        modal.querySelector('.modal-content')?.classList.add('wide');
        t.innerText = title;
        b.innerHTML = bodyHtml;
        modal.classList.add('open');
    }

    formatTimeLeft(ms) {
        if (ms <= 0) return "갱신됨";
        const totalMin = Math.ceil(ms / 60000);
        const h = Math.floor(totalMin / 60);
        const m = totalMin % 60;
        if (h <= 0) return `${m}분`;
        return `${h}시간 ${m}분`;
    }

    formatPercent(value) {
        return `${Math.round(value * 100)}%`;
    }

    getFieldObjectData(type) {
        // Priority Checks
        if (isDragonTile(type)) {
            return {
                name: "에인션트 드래곤",
                level: 99,
                defenders: [{ code: ITEM_TYPE.UNIT_DRAGON, count: 1, slot: 4 }],
                abilities: [{ code: 999, value: 0 }]
            };
        }

        // Field Events (Bandit, Dungeon, etc.)
        if (type === FIELD_EVENT_TYPES.BANDIT || type === FIELD_EVENT_TYPES.BANDIT_LEADER || type === FIELD_EVENT_TYPES.DUNGEON) {
            const defenders = this.getFieldDefenders(type);
            return {
                name: type === FIELD_EVENT_TYPES.BANDIT ? "도적" : (type === FIELD_EVENT_TYPES.BANDIT_LEADER ? "도적단" : "던전"),
                level: 1,
                defenders: defenders,
                abilities: []
            };
        }

        if (FIELD_OBJECT_DATA[type]) return FIELD_OBJECT_DATA[type];

        if (isGateTile(type)) {
            const level = getObjectLevelFromCode(type);
            const defenders = FIELD_DEFENDERS[Math.min(4, level)] || [];
            return { name: "관문", level, defenders, abilities: [] };
        }
        if (isCitadelTile(type)) {
            const level = getObjectLevelFromCode(type);
            const defenders = FIELD_DEFENDERS[Math.min(4, level + 1)] || FIELD_DEFENDERS[2] || [];
            return { name: "성채", level, defenders, abilities: [] };
        }

        return null;
    }

    getAbilityValue(data, abilityCode) {
        if (!data || !data.abilities) return 0;
        const found = data.abilities.find(a => a.code === abilityCode);
        return found ? Number(found.value) : 0;
    }

    getFieldLevel(type) {
        const data = this.getFieldObjectData(type);
        if (data && data.level) return data.level;
        return getObjectLevelFromCode(type);
    }

    getStatueBuff(type) {
        const data = this.getFieldObjectData(type);
        if (data?.statue) return data.statue;
        const kind = getStatueKind(type);
        if (!kind) return null;
        const level = this.getFieldLevel(type);
        const value = STATUE_BUFF_FALLBACK[level] || 0;
        return value ? { kind, value } : null;
    }

    getRuinsBonus(type) {
        if (!isRuinsTile(type)) return null;
        const data = this.getFieldObjectData(type);
        if (!data) return null;
        const cpCap = this.getAbilityValue(data, ABILITY_CODES.CP_CAP);
        const cpRegen = this.getAbilityValue(data, ABILITY_CODES.CP_REGEN);
        if (!cpCap && !cpRegen) return null;
        return { level: data.level || this.getFieldLevel(type), cpCap, cpRegen };
    }

    getFieldResourceConfig(type) {
        const data = this.getFieldObjectData(type);
        if (!data) return null;
        const goldCap = this.getAbilityValue(data, ABILITY_CODES.GOLD_CAP);
        const goldRegen = this.getAbilityValue(data, ABILITY_CODES.GOLD_REGEN);
        if (goldCap || goldRegen) return { kind: "gold", cap: goldCap, regen5: goldRegen };
        const energyCap = this.getAbilityValue(data, ABILITY_CODES.ENERGY_CAP);
        const energyRegen = this.getAbilityValue(data, ABILITY_CODES.ENERGY_REGEN);
        if (energyCap || energyRegen) return { kind: "energy", cap: energyCap, regen5: energyRegen };
        return null;
    }

    getFieldResourceState(type, r, c) {
        const cfg = this.getFieldResourceConfig(type);
        if (!cfg) return null;
        const key = `${r},${c}`;
        const now = Date.now();
        const state = this.fieldResourceState[key] || { last: now, stored: 0 };
        const regenMs = cfg.regen5 / (5 * 60 * 1000);
        if (regenMs > 0) {
            const elapsed = now - state.last;
            if (elapsed > 0) {
                const gained = Math.floor(elapsed * regenMs);
                if (gained > 0) {
                    state.stored = Math.min(cfg.cap, state.stored + gained);
                    const consumedMs = gained / regenMs;
                    state.last = Math.min(now, state.last + consumedMs);
                }
            }
        }
        if (state.stored >= cfg.cap) {
            if (!state.capNotified) {
                state.capNotified = true;
                if (document.getElementById('field-modal').classList.contains('open')) {
                    const kind = cfg.kind === "gold" ? "금광" : "분수";
                    this.showToast(`${kind} 최대치 도달`);
                }
            }
        } else {
            state.capNotified = false;
        }
        this.fieldResourceState[key] = state;
        return { key, state, cfg };
    }

    buildFieldRegions() {
        const regions = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(-1));
        let regionId = 0;
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const type = FIELD_MAP_DATA[r][c];
                if (isWallTile(type) || isBorderTerrain(type) || isGateTile(type) || isCitadelTile(type) || isDragonTile(type)) continue;
                if (regions[r][c] !== -1) continue;
                const stack = [{ r, c }];
                regions[r][c] = regionId;
                while (stack.length) {
                    const cur = stack.pop();
                    for (const d of dirs) {
                        const nr = cur.r + d[0];
                        const nc = cur.c + d[1];
                        if (nr < 0 || nr >= MAP_SIZE || nc < 0 || nc >= MAP_SIZE) continue;
                        const ntype = FIELD_MAP_DATA[nr][nc];
                        if (isWallTile(ntype) || isBorderTerrain(ntype) || isGateTile(ntype) || isCitadelTile(ntype) || isDragonTile(ntype)) continue;
                        if (regions[nr][nc] !== -1) continue;
                        regions[nr][nc] = regionId;
                        stack.push({ r: nr, c: nc });
                    }
                }
                regionId += 1;
            }
        }
        this.fieldRegions = regions;
    }

    getRegionIdAt(r, c) {
        if (!this.fieldRegions || r < 0 || c < 0 || r >= MAP_SIZE || c >= MAP_SIZE) return -1;
        return this.fieldRegions[r][c];
    }

    getAdjacentRegionIds(r, c) {
        const ids = new Set();
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const d of dirs) {
            const nr = r + d[0];
            const nc = c + d[1];
            const id = this.getRegionIdAt(nr, nc);
            if (id !== -1) ids.add(id);
        }
        return ids;
    }

    getAdjacentRegionKey(r, c) {
        const ids = Array.from(this.getAdjacentRegionIds(r, c));
        if (ids.length === 0) return "";
        ids.sort((a, b) => a - b);
        return ids.join(",");
    }

    getArmyRegionId(army) {
        if (!army) return -1;
        const type = FIELD_MAP_DATA?.[army.r]?.[army.c];
        if (!isBorderTerrain(type)) {
            const id = this.getRegionIdAt(army.r, army.c);
            if (id !== -1) army.regionId = id;
            return id;
        }
        if (army.regionId !== undefined && army.regionId !== null) return army.regionId;
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const d of dirs) {
            const nr = army.r + d[0];
            const nc = army.c + d[1];
            const id = this.getRegionIdAt(nr, nc);
            if (id !== -1) {
                army.regionId = id;
                return id;
            }
        }
        return -1;
    }

    updateOpenBorders() {
        const open = new Set();
        const visited = new Set();
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

        const bfs = (sr, sc, adjKey) => {
            const stack = [{ r: sr, c: sc }];
            visited.add(`${sr},${sc}`);
            while (stack.length) {
                const cur = stack.pop();
                open.add(`${cur.r},${cur.c}`);
                for (const d of dirs) {
                    const nr = cur.r + d[0];
                    const nc = cur.c + d[1];
                    if (nr < 0 || nr >= MAP_SIZE || nc < 0 || nc >= MAP_SIZE) continue;
                    const nkey = `${nr},${nc}`;
                    if (visited.has(nkey)) continue;
                    if (!isBorderTerrain(FIELD_MAP_DATA[nr][nc])) continue;
                    const nAdjKey = this.getAdjacentRegionKey(nr, nc);
                    if (!nAdjKey || nAdjKey !== adjKey) continue;
                    visited.add(nkey);
                    stack.push({ r: nr, c: nc });
                }
            }
        };

        this.occupiedTiles.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            const type = FIELD_MAP_DATA[r]?.[c];
            if (!isGateTile(type)) return;
            for (const d of dirs) {
                const nr = r + d[0];
                const nc = c + d[1];
                if (nr < 0 || nr >= MAP_SIZE || nc < 0 || nc >= MAP_SIZE) continue;
                if (!isBorderTerrain(FIELD_MAP_DATA[nr][nc])) continue;
                const nkey = `${nr},${nc}`;
                const adjKey = this.getAdjacentRegionKey(nr, nc);
                if (!adjKey) continue;
                if (!visited.has(nkey)) bfs(nr, nc, adjKey);
            }
        });

        this.openBorderTiles = open;
    }

    isBorderOpen(r, c) {
        return this.openBorderTiles?.has(`${r},${c}`);
    }

    isTileBlocked(current, r, c, type, isOccupied, isTarget, regionId) {
        if (isWallTile(type)) return true;
        if (isBorderTerrain(type)) {
            if (this.isBorderOpen(r, c)) return false;
            return true;
        }
        if (isOccupied || isTarget) return false;
        if (current && isBorderTerrain(FIELD_MAP_DATA[current.r][current.c])) {
            if (!this.isBorderOpen(current.r, current.c)) {
                const targetRegion = this.getRegionIdAt(r, c);
                if (regionId !== -1 && targetRegion !== -1 && targetRegion !== regionId) return true;
            }
        }
        return isGateTile(type) || isCitadelTile(type) || isDragonTile(type);
    }

    collectFieldResource(type, r, c) {
        const key = `${r},${c}`;
        if (!this.occupiedTiles.has(key)) { this.showToast("점령 후 수령 가능"); return; }
        const info = this.getFieldResourceState(type, r, c);
        if (!info || info.state.stored <= 0) { this.showToast("생산 중"); return; }
        if (info.cfg.kind === "gold") {
            this.gold += info.state.stored;
            this.showToast(`+${info.state.stored}G`);
        } else if (info.cfg.kind === "energy") {
            this.energy = Math.min(this.maxEnergy, this.energy + info.state.stored);
            this.showToast(`+${info.state.stored}⚡`);
        }
        info.state.stored = 0;
        info.state.capNotified = false;
        info.state.last = Date.now();
        this.fieldResourceState[key] = info.state;
        this.updateUI();
    }

    getCollectibleFieldItemInfo(type) {
        if (isTerrainCode(type)) return null;
        return getInfoFromCode(type);
    }

    createMergeItemFromInfo(info) {
        const item = { type: info.type, level: info.level, scale: 0 };
        if (item.type === ITEM_TYPE.BUILDING_CHEST) item.usage = 5;
        if (item.type === ITEM_TYPE.BUILDING_CAMP) item.storedUnits = [];
        return item;
    }

    removeObjectProbPlacement(r, c) {
        if (typeof window === 'undefined') return;
        const key = 'kov_field_object_prob_v1';
        let placements = null;
        try {
            const raw = localStorage.getItem(key);
            if (raw) placements = JSON.parse(raw);
        } catch (e) { }
        if (!Array.isArray(placements)) return;
        const next = placements.filter(p => !(p.r === r && p.c === c));
        if (next.length === placements.length) return;
        try { localStorage.setItem(key, JSON.stringify(next)); } catch (e) { }
    }

    clearFieldObjectFromMap(r, c) {
        const base = FIELD_TERRAIN_DATA?.[r]?.[c];
        if (base !== undefined && base !== null) FIELD_MAP_DATA[r][c] = base;
        else FIELD_MAP_DATA[r][c] = 100;
        this.removeObjectProbPlacement(r, c);
    }

    isFieldReachable(r, c) {
        const targetKey = `${r},${c}`;
        if (this.occupiedTiles.has(targetKey)) return true;
        if (!this.occupiedTiles.size) return false;
        const queue = [];
        const visited = new Set();
        const regionByKey = {};
        this.occupiedTiles.forEach(key => {
            const [sr, sc] = key.split(',').map(Number);
            const startType = FIELD_MAP_DATA[sr][sc];
            let regionId = -1;
            if (!isBorderTerrain(startType)) {
                regionId = this.getRegionIdAt(sr, sc);
            } else {
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const d of dirs) {
                    const nr = sr + d[0];
                    const nc = sc + d[1];
                    const id = this.getRegionIdAt(nr, nc);
                    if (id !== -1) { regionId = id; break; }
                }
            }
            queue.push({ r: sr, c: sc, regionId });
            visited.add(key);
            regionByKey[key] = regionId;
        });
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        while (queue.length) {
            const cur = queue.shift();
            for (const d of dirs) {
                const nr = cur.r + d[0];
                const nc = cur.c + d[1];
                if (nr < 0 || nr >= MAP_SIZE || nc < 0 || nc >= MAP_SIZE) continue;
                const nkey = `${nr},${nc}`;
                if (visited.has(nkey)) continue;
                const type = FIELD_MAP_DATA[nr][nc];
                const isTarget = nkey === targetKey;
                const isOccupied = this.occupiedTiles.has(nkey);
                if (this.isTileBlocked(cur, nr, nc, type, isOccupied, isTarget, cur.regionId ?? -1)) continue;
                if (nkey === targetKey) return true;
                let nextRegion = cur.regionId ?? -1;
                if (!isBorderTerrain(type)) {
                    const rid = this.getRegionIdAt(nr, nc);
                    if (rid !== -1) nextRegion = rid;
                }
                visited.add(nkey);
                queue.push({ r: nr, c: nc, regionId: nextRegion });
            }
        }
        return false;
    }

    buildReachableTiles() {
        const reachable = new Set();
        if (!this.occupiedTiles.size) return reachable;
        const queue = [];
        this.occupiedTiles.forEach(key => {
            const [sr, sc] = key.split(',').map(Number);
            const startType = FIELD_MAP_DATA[sr][sc];
            let regionId = -1;
            if (!isBorderTerrain(startType)) {
                regionId = this.getRegionIdAt(sr, sc);
            } else {
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const d of dirs) {
                    const nr = sr + d[0];
                    const nc = sc + d[1];
                    const id = this.getRegionIdAt(nr, nc);
                    if (id !== -1) { regionId = id; break; }
                }
            }
            queue.push({ r: sr, c: sc, regionId });
            reachable.add(key);
        });
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        while (queue.length) {
            const cur = queue.shift();
            for (const d of dirs) {
                const nr = cur.r + d[0];
                const nc = cur.c + d[1];
                if (nr < 0 || nr >= MAP_SIZE || nc < 0 || nc >= MAP_SIZE) continue;
                const nkey = `${nr},${nc}`;
                if (reachable.has(nkey)) continue;
                const type = FIELD_MAP_DATA[nr][nc];
                const isOccupied = this.occupiedTiles.has(nkey);
                if (this.isTileBlocked(cur, nr, nc, type, isOccupied, false, cur.regionId ?? -1)) continue;
                let nextRegion = cur.regionId ?? -1;
                if (!isBorderTerrain(type)) {
                    const rid = this.getRegionIdAt(nr, nc);
                    if (rid !== -1) nextRegion = rid;
                }
                reachable.add(nkey);
                queue.push({ r: nr, c: nc, regionId: nextRegion });
            }
        }
        return reachable;
    }

    canCollectFieldObject(r, c) {
        return this.isFieldReachable(r, c);
    }

    collectFieldObjectToMerge(type, r, c) {
        if (!this.canCollectFieldObject(r, c)) { this.showToast("진입 후 획득 가능"); return; }
        const info = this.getCollectibleFieldItemInfo(type);
        if (!info) { this.showToast("획득 불가"); return; }
        const item = this.createMergeItemFromInfo(info);
        if (!this.spawnItem(item)) { this.showToast("머지 슬롯 공간 부족"); return; }

        this.clearFieldObjectFromMap(r, c);
        if (this.fieldObjectState) {
            if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
            this.fieldObjectState.regenByCode[type] = Date.now();
        }
        this.sound.playCollect();
        this.requestRender();
        this.updateUI();

        if (document.getElementById('field-modal').classList.contains('open')) {
            if (!this.refreshFieldMapVisuals()) {
                this.renderFieldMap();
            }
            this.setFieldInfo(FIELD_MAP_DATA[r][c], r, c);
        }
        this.showToast("획득 완료");
    }


    applyCpBonuses() {
        const baseMax = this.baseMaxCp ?? this.maxCp ?? 20;
        const baseRegen = this.baseCpRegen ?? this.cpRegen ?? 1;
        this.maxCp = baseMax + (this.cpBonus || 0);
        this.cpRegen = Math.max(0.2, baseRegen + (this.cpRegenBonus || 0));
        if (this.cp > this.maxCp) this.cp = this.maxCp;
    }

    recalcFieldBonuses() {
        const buffs = { atk: 0, def: 0, hp: 0, spd: 0 };
        let cpCapBonus = 0;
        let cpRegenBonus = 0;
        let citadelCount = 0;

        this.occupiedTiles.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            const type = FIELD_MAP_DATA[r][c];
            if (isStatueTile(type)) {
                const buff = this.getStatueBuff(type);
                if (buff && buff.value) buffs[buff.kind] += buff.value;
            }
            if (isRuinsTile(type)) {
                const bonus = this.getRuinsBonus(type);
                if (bonus) {
                    cpCapBonus += bonus.cpCap;
                    cpRegenBonus += bonus.cpRegen;
                }
            }
            if (isCitadelTile(type)) citadelCount += 1;
        });

        this.fieldBuffs = buffs;
        this.citadelCount = citadelCount;
        this.cpBonus = cpCapBonus + (citadelCount * CITADEL_CP_BONUS);
        this.cpRegenBonus = cpRegenBonus;
        const prevThird = this.thirdSquadUnlocked;
        this.thirdSquadUnlocked = citadelCount > 0;
        if (!this.thirdSquadUnlocked) {
            if (this.selectedArmyId === 2) this.selectedArmyId = null;
            if (this.lastSelectedArmyId === 2) this.lastSelectedArmyId = null;
        }
        if (prevThird !== this.thirdSquadUnlocked) {
            this.calcLayout();
            this.requestRender();
        }
        this.applyCpBonuses();
    }

    calcItemPrice(type, level) {
        const base = ITEM_VALUES[level] || 1;
        if (type === ITEM_TYPE.ITEM_GOLD) return base * 40;
        if (type === ITEM_TYPE.ITEM_ENERGY) return base * 50;
        if (type === ITEM_TYPE.ITEM_CRYSTAL) return base * 80;
        return base * 50;
    }

    getItemIcon(type) {
        if (type === ITEM_TYPE.ITEM_GOLD) return "💰";
        if (type === ITEM_TYPE.ITEM_ENERGY) return "⚡";
        if (type === ITEM_TYPE.ITEM_CRYSTAL) return "💎";
        return "📦";
    }

    getAssetSrc(type, level) {
        const img = this.assets.getImage(type, level);
        return img && img.src ? img.src : "";
    }

    placeUnitInSquad(item, squad) {
        for (let i = 0; i < squad.length; i++) {
            if (!squad[i]) { item.scale = 1.3; squad[i] = item; return i; }
        }
        return -1;
    }

    placeUnitPreferred(item) {
        let idx = this.placeUnitInSquad(item, this.squad1);
        if (idx !== -1) return { placed: true, zone: ZONES.SQUAD1, idx };
        idx = this.placeUnitInSquad(item, this.squad2);
        if (idx !== -1) return { placed: true, zone: ZONES.SQUAD2, idx };
        if (this.thirdSquadUnlocked) {
            idx = this.placeUnitInSquad(item, this.squad3);
            if (idx !== -1) return { placed: true, zone: ZONES.SQUAD3, idx };
        }
        if (this.spawnItem(item)) return { placed: true, zone: ZONES.GRID, idx: null };
        return { placed: false };
    }

    calcMercPrice(code) {
        const info = getInfoFromCode(code);
        const stats = UNIT_STATS[code];
        const lv = info.level || 1;
        if (!stats) return lv * 120;
        return Math.max(80, (stats.sell + 1) * 100);
    }

    getShopItemKey(item) {
        if (!item) return "";
        if (item.kind === "item") return `item:${item.code ?? `${item.type}:${item.level}`}`;
        return `unit:${item.code ?? `${item.name}:${item.level}`}`;
    }

    buildShopCatalog(type) {
        const level = this.getFieldLevel(type);
        if (isShopTile(type)) {
            const codes = Object.keys(ITEM_TABLE).map(n => parseInt(n, 10));
            codes.sort(() => Math.random() - 0.5);
            return codes.slice(0, 3).map(code => {
                const info = getInfoFromCode(code);
                const data = ITEM_TABLE[code];
                return {
                    kind: "item",
                    code,
                    name: data.name_kr || data.name,
                    icon: this.getItemIcon(info.type),
                    type: info.type,
                    level: info.level,
                    earn: data.earn,
                    price: this.calcItemPrice(info.type, info.level)
                };
            });
        }
        if (isTavernTile(type)) {
            const pool = Object.keys(UNIT_STATS).map(n => parseInt(n, 10))
                .filter(code => {
                    const info = getInfoFromCode(code);
                    return info.type >= 10 && info.level <= 5;
                });
            pool.sort(() => Math.random() - 0.5);
            return pool.slice(0, 3).map(code => {
                const info = getInfoFromCode(code);
                const stat = UNIT_STATS[code];
                return {
                    kind: "unit",
                    code,
                    name: stat ? stat.name : `용병 Lv.${info.level}`,
                    level: info.level,
                    price: this.calcMercPrice(code)
                };
            });
        }
        return [];
    }

    buyFieldItem(item) {
        if (item.sold) { this.showToast("품절"); return; }
        if (this.gold < item.price) { this.showToast("골드 부족"); return; }
        if (!this.spawnItem({ type: item.type, level: item.level, scale: 0 })) { this.showToast("공간 부족"); return; }
        this.gold -= item.price;
        this.sound.playCollect();
        this.updateUI();
        this.showToast("구매 완료");
        item.sold = true;
        this.refreshShopModal();
    }

    hireMercenary(item) {
        if (item.sold) { this.showToast("품절"); return; }
        if (this.gold < item.price) { this.showToast("골드 부족"); return; }
        const info = getInfoFromCode(item.code);
        const placed = this.placeUnitPreferred({ type: info.type, level: info.level, scale: 0 });
        if (!placed.placed) { this.showToast("공간 부족"); return; }
        this.gold -= item.price;
        this.sound.playSpawn();
        this.updateUI();
        if (placed.zone === ZONES.SQUAD1 || placed.zone === ZONES.SQUAD2) {
            this.playSquadJoinFx(placed.zone, placed.idx);
        }
        this.showToast("고용 완료");
        item.sold = true;
        this.refreshShopModal();
    }

    refreshShopModal() {
        if (!this.currentShopContext) return;
        const { type, r, c } = this.currentShopContext;
        const key = `${r},${c}`;
        const state = this.fieldShopState[key];
        if (!state) return;
        if (!document.getElementById('modal-object')?.classList.contains('open')) return;
        const now = Date.now();
        const interval = 3 * 60 * 60 * 1000;
        if (now - state.lastRefresh >= interval) {
            const prevSoldKeys = new Set((state.items || []).filter(i => i.sold).map(i => this.getShopItemKey(i)));
            state.lastRefresh = now;
            state.items = this.buildShopCatalog(type).map(item => ({
                ...item,
                sold: false,
                restock: prevSoldKeys.has(this.getShopItemKey(item))
            }));
            state.justRefreshed = true;
            this.fieldShopState[key] = state;
        }
        this.renderShopModal(type, r, c, state);
    }

    openShopOrTavern(type, r, c) {
        const key = `${r},${c}`;
        if (!this.occupiedTiles.has(key)) { this.showToast("점령 후 이용 가능"); return; }
        const state = this.fieldShopState[key] || { lastRefresh: Date.now(), items: [] };
        const interval = 3 * 60 * 60 * 1000;
        const now = Date.now();
        if (now - state.lastRefresh >= interval || !state.items || state.items.length === 0) {
            state.lastRefresh = now;
            state.items = this.buildShopCatalog(type).map(item => ({ ...item, sold: false, restock: false }));
        }
        this.fieldShopState[key] = state;
        this.currentShopContext = { type, r, c };
        this.renderShopModal(type, r, c, state);
    }

    renderShopModal(type, r, c, state) {
        const interval = 3 * 60 * 60 * 1000;
        const now = Date.now();
        const next = state.lastRefresh + interval;
        const remain = this.formatTimeLeft(next - now);
        const name = isShopTile(type) ? "상점" : "주점";
        const level = this.getFieldLevel(type);

        const modal = document.getElementById('modal-object');
        const t = document.getElementById('object-modal-title');
        const b = document.getElementById('object-modal-body');
        if (!modal || !t || !b) return;
        t.innerText = name;
        b.innerHTML = "";
        modal.querySelector('.modal-content')?.classList.add('wide');

        const header = document.createElement('div');
        header.className = "shop-header";
        header.innerHTML = `<div class="shop-title">${name} Lv.${level}</div><div class="shop-refresh">갱신까지: <span id="shop-refresh-timer">${remain}</span></div>`;
        b.appendChild(header);

        const list = document.createElement('div');
        list.className = "shop-list";

        state.items.forEach(item => {
            const row = document.createElement('div');
            row.className = "shop-card";
            if (item.restock) row.classList.add('restock');

            if (item.kind === "item") {
                const imgSrc = this.getAssetSrc(item.type, item.level);
                const iconHtml = imgSrc
                    ? `<div class="shop-icon"><img class="shop-icon-img" src="${imgSrc}" alt=""></div>`
                    : `<div class="shop-icon">${item.icon || this.getItemIcon(item.type)}</div>`;
                row.innerHTML = `
                    <div class="shop-row">${iconHtml}<div><div class="name">${item.name}</div><div class="level">Lv.${item.level}</div><div class="meta">획득량 +${item.earn}</div></div></div>
                    <button class="price-btn">${item.sold ? "SOLD OUT" : `💰 ${item.price}`}</button>
                `;
                const btn = row.querySelector('.price-btn');
                const affordable = this.gold >= item.price;
                if (item.sold || !affordable) row.classList.add('disabled');
                btn.onclick = () => {
                    if (item.sold) { this.showToast("품절"); return; }
                    if (!affordable) { this.showToast("골드 부족"); return; }
                    this.buyFieldItem(item);
                };
            } else {
                // Unit
                const info = getInfoFromCode(item.code);
                const imgSrc = this.getAssetSrc(info.type, info.level);
                const iconHtml = imgSrc
                    ? `<div class="shop-icon"><img class="shop-icon-img" src="${imgSrc}" alt=""></div>`
                    : `<div class="shop-icon">⚔</div>`;
                row.innerHTML = `
                    <div class="shop-row">${iconHtml}<div><div class="name">${item.name}</div><div class="level">Lv.${item.level}</div><div class="meta">용병 고용</div></div></div>
                    <button class="price-btn">${item.sold ? "SOLD OUT" : `💰 ${item.price}`}</button>
                `;
                const btn = row.querySelector('.price-btn');
                const affordable = this.gold >= item.price;
                if (item.sold || !affordable) row.classList.add('disabled');
                btn.onclick = () => {
                    if (item.sold) { this.showToast("품절"); return; }
                    if (!affordable) { this.showToast("골드 부족"); return; }
                    this.hireMercenary(item);
                };
            }
            list.appendChild(row);
        });

        state.items.forEach(item => { item.restock = false; });
        state.justRefreshed = false;
        b.appendChild(list);
        modal.classList.add('open');

        if (this.shopTimer) clearInterval(this.shopTimer);
        this.shopTimer = setInterval(() => {
            if (!modal.classList.contains('open')) { clearInterval(this.shopTimer); this.shopTimer = null; return; }
            const el = document.getElementById('shop-refresh-timer');
            if (el) el.innerText = this.formatTimeLeft(next - Date.now());
            // this.refreshShopModal(); // Avoid infinite loop or flicker if logic is recursive
        }, 1000);
    }

    // --- PHASE 4: SOCIAL UI ---
    initSocialUI() {
        // Chat Button is now in Footer (HTML), so we don't create it here.
        // We only verify drawer exists.

        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;

        // 2. Chat Drawer
        if (!document.getElementById('chat-drawer')) {
            const chatDrawer = document.createElement('div');
            chatDrawer.id = 'chat-drawer';
            chatDrawer.className = 'chat-drawer';
            chatDrawer.innerHTML = `
                <div class="chat-header">
                    <span>💬 World Chat</span>
                    <button onclick="game.toggleChat()">✖</button>
                </div>
                <div class="chat-tabs">
                    <button class="active">World</button>
                    <button>Guild</button>
                    <button>System</button>
                </div>
                <div id="chat-messages" class="chat-messages"></div>
                <div class="chat-input-area">
                    <input type="text" id="chat-input" placeholder="메시지를 입력하세요...">
                    <button onclick="game.sendChatMessage()">전송</button>
                </div>
            `;
            gameContainer.appendChild(chatDrawer);
        }

        // 3. Profile Modal
        if (!document.getElementById('modal-profile')) {
            const profileModal = document.createElement('div');
            profileModal.id = 'modal-profile';
            profileModal.className = 'modal-overlay';
            profileModal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal" onclick="document.getElementById('modal-profile').classList.remove('open')">&times;</span>
                    <div id="profile-body"></div>
                </div>
            `;
            document.body.appendChild(profileModal);
        }

        // Update Header
        this.updateHeaderForSocial();

        // Start Chat Simulation
        setInterval(() => this.simulateChat(), 5000 + Math.random() * 10000);
    }

    updateHeaderForSocial() {
        console.log("Updating Header for Social (v3)...");
        const header = document.getElementById('ui-header');
        // If header doesn't exist (it should, class is header-panel), try querySelector
        const headerPanel = document.querySelector('.header-panel');
        if (!headerPanel) return;

        // Check if already updated
        if (document.getElementById('header-profile')) return;

        // Inject Profile Icon at start
        const profileIcon = document.createElement('div');
        profileIcon.id = 'header-profile';
        profileIcon.className = 'header-profile';
        profileIcon.innerHTML = `<div class="avatar">🧙‍♂️</div><div class="level-badge">${this.lordLevel}</div>`;
        profileIcon.onclick = () => this.openProfile();
        headerPanel.insertBefore(profileIcon, headerPanel.firstChild);

        // Inject Point Counters (Gems are already in HTML)
        const resContainer = headerPanel.querySelector('.flex.justify-between.mb-1'); // The first row
        if (resContainer) {
            // Points (Inject only Points and Settings)

            // Points
            const pointDiv = document.createElement('div');
            pointDiv.className = 'res-pill';
            pointDiv.onclick = () => this.showToast('포인트 상점 준비 중');
            pointDiv.innerHTML = `
                <span class="res-icon">🅿️</span>
                <span id="res-point">${this.points}</span>
                <span class="text-gray-400 text-[10px] ml-1">+</span>
            `;
            resContainer.appendChild(pointDiv);

            // Settings Button (Top Right)
            const settingsDiv = document.createElement('div');
            settingsDiv.className = 'res-pill settings-icon';
            settingsDiv.onclick = () => document.getElementById('modal-settings').classList.add('open');
            settingsDiv.innerHTML = `<span class="res-icon">⚙️</span>`;
            resContainer.appendChild(settingsDiv);
        }
    }

    toggleChat() {
        this.isChatOpen = !this.isChatOpen;
        const drawer = document.getElementById('chat-drawer');
        if (this.isChatOpen) {
            drawer.classList.add('open');
            this.refreshChatUI();
        } else {
            drawer.classList.remove('open');
        }
    }

    sendChatMessage() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if (!text) return;

        this.chatLog.push({ sender: this.userProfile.name, text, type: 'me' });
        if (this.chatLog.length > 50) this.chatLog.shift();

        input.value = "";
        this.refreshChatUI();
        this.showToast("메시지 전송 완료");
    }

    simulateChat() {
        const msg = DUMMY_CHAT_MESSAGES[Math.floor(Math.random() * DUMMY_CHAT_MESSAGES.length)];
        const parts = msg.split(']');
        const sender = parts[0].replace('[', '');
        const text = parts[1].trim();

        this.chatLog.push({ sender, text, type: 'other' });
        if (this.chatLog.length > 50) this.chatLog.shift();
        if (this.isChatOpen) this.refreshChatUI();
    }

    refreshChatUI() {
        const container = document.getElementById('chat-messages');
        if (!container) return;
        container.innerHTML = this.chatLog.map(log => `
                <div class="chat-line ${log.type}">
                <span class="sender">${log.type === 'me' ? '' : `[${log.sender}]`}</span>
                <span class="text" style="color:white !important;">${log.text}</span>
            </div>
                `).join('');
        container.scrollTop = container.scrollHeight;
    }

    openProfile() {
        const modal = document.getElementById('modal-profile');
        const body = document.getElementById('profile-body');
        modal.classList.add('open');

        body.innerHTML = `
                < div class="profile-view" >
                <div class="profile-header">
                    <div class="profile-avatar-lg">🧙‍♂️</div>
                    <div class="profile-info">
                        <h3>${this.userProfile.name} <button class="edit-btn" onclick="game.editName()">✏️</button></h3>
                        <p>${this.userProfile.title}</p>
                    </div>
                </div>
                <div class="profile-stats">
                    <div class="stat-box"><div>승률</div><span>${this.userProfile.winRate}%</span></div>
                    <div class="stat-box"><div>전투력</div><span>${this.cp * 100}</span></div>
                    <div class="stat-box"><div>VIP</div><span>${this.userProfile.vip}</span></div>
                </div>
                <div class="profile-actions">
                    <button class="btn-action" onclick="game.showToast('준비 중')">친구 관리</button>
                    <button class="btn-action" onclick="game.showToast('로그아웃')">계정 연동</button>
                </div>
            </div >
                `;
    }

    editName() {
        const newName = prompt("변경할 닉네임을 입력하세요:", this.userProfile.name);
        if (newName && newName.length > 0) {
            this.userProfile.name = newName;
            this.openProfile(); // Refresh
            this.showToast("닉네임이 변경되었습니다.");
        }
    }

    playSquadJoinFx(zone, idx) {
        if (idx === null || idx === undefined) return;
        const rect = zone === ZONES.SQUAD1 ? this.squad1Rect : (zone === ZONES.SQUAD2 ? this.squad2Rect : this.squad3Rect);
        const size = this.squadCellSize;
        const x = rect.x + (idx % 3) * size + size / 2;
        const y = rect.y + Math.floor(idx / 3) * size + size / 2;
        this.spawnParticles(x, y, "#4ade80", 16, "spark");
        const name = zone === ZONES.SQUAD1 ? "제1부대 합류" : (zone === ZONES.SQUAD2 ? "제2부대 합류" : "제3부대 합류");
        this.showJoinNotice(name);
        this.requestRender();
    }

    getSquadByArmyId(armyId) {
        if (armyId === 0) return this.squad1;
        if (armyId === 1) return this.squad2;
        return this.squad3;
    }

    getAvailableArmies() {
        return this.thirdSquadUnlocked ? this.armies : this.armies.filter(a => a.id !== 2);
    }

    enterMoveTargetMode(armyId, opts = {}) {
        const army = this.armies[armyId];
        if (!army) return;
        if (!this.getAvailableArmies().some(a => a.id === armyId)) { this.showToast("성채 점령 필요"); return; }
        if (army.state !== 'IDLE') { this.showToast("부대가 이동 중입니다."); return; }

        const squadData = this.getSquadByArmyId(army.id);
        const stats = this.getSquadStats(squadData);
        if (stats.power < 10) { this.showToast("병력이 부족합니다."); return; }

        const { center = false } = opts;
        this.exitMoveTargetMode();
        this.selectedArmyId = army.id;
        this.lastSelectedArmyId = army.id;
        const times = this.buildMoveTimeMap(army, stats);
        this.moveTargetMode = { armyId: army.id, stats, times };
        this.setMovePreview("ETA 표시 중 (취소: 상단 메시지 탭)");
        if (center) this.centerCameraOnArmy(army.id);
        this.renderMoveTimeOverlay();
    }

    exitMoveTargetMode() {
        if (!this.moveTargetMode) return;
        this.moveTargetMode = null;
        this.clearMoveTimeOverlay();
        this.setMovePreview("");
    }

    buildMoveTimeMap(army, stats) {
        const times = new Map();
        const origin = { r: army.r, c: army.c };
        const regionId = this.getArmyRegionId(army);
        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const key = `${r},${c} `;
                if (!this.visibilityMap.has(key)) continue;
                if (r === origin.r && c === origin.c) continue;
                const path = AStar.findPath(
                    origin,
                    { r, c },
                    FIELD_MAP_DATA,
                    this.occupiedTiles,
                    (cur, nr, nc, type, isOcc, isTarget) => this.isTileBlocked(cur, nr, nc, type, isOcc, isTarget, regionId)
                );
                if (!path) continue;
                const dist = path.length - 1;
                if (dist <= 0 || dist > stats.range) continue;
                const summary = this.getPathSummary(path, stats.speedFactor);
                times.set(key, { timeMin: summary.finalMin, dist, cpCost: dist * CP_COST_PER_TILE });
            }
        }
        return times;
    }

    clearMoveTimeOverlay() {
        document.querySelectorAll('.field-time').forEach(el => el.remove());
        document.querySelectorAll('.field-move-eligible').forEach(el => el.classList.remove('field-move-eligible'));
        document.querySelectorAll('.field-move-source').forEach(el => el.classList.remove('field-move-source'));
    }

    renderMoveTimeOverlay() {
        this.clearMoveTimeOverlay();
        if (!this.moveTargetMode) return;
        const { times, armyId } = this.moveTargetMode;
        times.forEach((info, key) => {
            const [r, c] = key.split(',').map(Number);
            const cell = document.getElementById(`field - cell - ${r} -${c} `);
            if (!cell || cell.classList.contains('field-fog')) return;
            if (info.cpCost > this.cp) return;
            const label = document.createElement('div');
            label.className = 'field-time';
            const tileType = FIELD_MAP_DATA[r][c];
            const isBorderTile = this.occupiedTiles.has(key) || isGateTile(tileType);
            if (isBorderTile) label.classList.add('lower');
            const display = Math.max(1, Math.round(info.timeMin));
            label.innerText = `${display} m`;
            cell.appendChild(label);
            cell.classList.add('field-move-eligible');
        });
        const army = this.armies[armyId];
        if (army) {
            const startCell = document.getElementById(`field - cell - ${army.r} -${army.c} `);
            if (startCell) startCell.classList.add('field-move-source');
        }
    }

    handleMoveTargetClick(r, c, type) {
        if (!this.moveTargetMode) return;
        const { armyId, stats, times } = this.moveTargetMode;
        const info = times.get(`${r},${c} `);
        if (!info) { this.showToast("이동 불가"); this.sound.playError(); return; }

        const army = this.armies[armyId];
        if (!army || army.state !== 'IDLE') { this.showToast("부대가 이동 중입니다."); return; }
        const regionId = this.getArmyRegionId(army);

        const path = AStar.findPath(
            { r: army.r, c: army.c },
            { r, c },
            FIELD_MAP_DATA,
            this.occupiedTiles,
            (cur, nr, nc, type, isOcc, isTarget) => this.isTileBlocked(cur, nr, nc, type, isOcc, isTarget, regionId)
        );
        if (!path) { this.showToast("갈 수 없음"); this.sound.playError(); return; }
        const dist = path.length - 1;
        if (dist > stats.range) { this.showToast(`거리 초과(${dist} / ${stats.range})`); this.sound.playError(); return; }

        let energyCost = 1; let goldCost = 0;
        if (isGateTile(type)) { energyCost = 5; goldCost = 100; }
        const cpCost = dist * CP_COST_PER_TILE;

        if (this.energy < energyCost) { this.showToast(`에너지 부족(${energyCost})`); return; }
        if (this.gold < goldCost) { this.showToast(`골드 부족(${goldCost})`); return; }
        if (this.cp < cpCost) { this.showToast(`지휘력 부족(${cpCost})`); return; }

        this.exitMoveTargetMode();
        this.selectedArmyId = armyId;
        this.startMarch(armyId, r, c, type, energyCost, goldCost, cpCost, path, stats.speedFactor);
    }

    clearPathPreview() {
        if (!this.previewPath) return;
        this.previewPath.forEach(p => {
            const cell = document.getElementById(`field - cell - ${p.r} -${p.c} `);
            if (cell) cell.classList.remove('field-path');
        });
        this.previewPath = null;
        const overlay = this.pathOverlay || document.getElementById('path-overlay');
        if (overlay) overlay.innerHTML = "";
    }

    applyPathPreview(path) {
        this.clearPathPreview();
        if (!path || path.length === 0) return;
        this.previewPath = path;
        path.forEach(p => {
            const cell = document.getElementById(`field - cell - ${p.r} -${p.c} `);
            if (cell) cell.classList.add('field-path');
        });
        const overlay = this.pathOverlay || document.getElementById('path-overlay');
        if (!overlay) return;
        const points = path.map(p => `${50 + (p.c * 13) + 6.5},${50 + (p.r * 13) + 6.5} `).join(' ');
        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        bg.setAttribute('points', points);
        bg.setAttribute('class', 'path-line-bg');
        overlay.appendChild(bg);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        line.setAttribute('points', points);
        line.setAttribute('class', 'path-line');
        overlay.appendChild(line);
    }

    getFieldObjectInfo(type, r, c) {
        if (isWallTile(type)) {
            return { name: "장벽", level: "-", owner: "-", defenders: [] };
        }
        if (isTerrainCode(type)) {
            return { name: getTerrainName(type), level: "-", owner: "-", defenders: [] };
        }
        let name = "알 수 없음";
        let level = 1;
        let defenders = [];
        const data = this.getFieldObjectData(type);
        const overlay = data ? null : getInfoFromCode(type);
        if (data) {
            name = data.name || name;
            level = data.level || level;
            defenders = data.defenders || [];
        } else if (overlay) {
            const base = getData(overlay.type, overlay.level);
            if (base && base.name) {
                name = base.name;
                level = overlay.level ?? level;
            }
        } else if (isCastleTile(type)) { name = "성"; level = 1; }
        else if (isGateTile(type)) { name = "관문"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isCitadelTile(type)) { name = "성채"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level + 1)] || FIELD_DEFENDERS[2]; }
        else if (isDragonTile(type)) { name = "용"; level = 1; }
        else if (isGoldMineTile(type)) { name = "금광"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isFountainTile(type)) { name = "에너지 분수"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isShopTile(type)) { name = "상점"; level = 1; defenders = FIELD_DEFENDERS[1]; }
        else if (isTavernTile(type)) { name = "주점"; level = 1; defenders = FIELD_DEFENDERS[1]; }
        else if (isRuinsTile(type)) { name = "유적"; level = getObjectLevelFromCode(type); defenders = FIELD_DEFENDERS[Math.min(4, level)] || []; }
        else if (isStatueTile(type)) { name = "석상"; level = getObjectLevelFromCode(type); }
        else if (type === 4) { name = "길"; level = "-"; }

        // Field Events
        else if (typeof FIELD_EVENT_TYPES !== 'undefined') {
            if (type === FIELD_EVENT_TYPES.BANDIT) { name = "도적"; level = 1; defenders = [{ code: 10, count: 5 }]; }
            else if (type === FIELD_EVENT_TYPES.BANDIT_LEADER) { name = "도적단"; level = 3; defenders = [{ code: 12, count: 10 }]; }
            else if (type === FIELD_EVENT_TYPES.DUNGEON) { name = "던전"; level = 5; }
            else if (type === FIELD_EVENT_TYPES.PORTAL) { name = "포탈"; level = "-"; }
            else if (type === FIELD_EVENT_TYPES.CARAVAN) { name = "카라반"; level = "-"; }
        }

        const owner = this.occupiedTiles.has(`${r},${c} `) ? "점령" : "-";
        return { name, level, owner, defenders };
    }

    isCapturableFieldObject(type) {
        return isGateTile(type) || isCitadelTile(type) || isGoldMineTile(type) || isFountainTile(type)
            || isShopTile(type) || isTavernTile(type) || isRuinsTile(type) || isStatueTile(type) || isDragonTile(type);
    }



    formatDefenders(defenders) {
        if (!defenders || defenders.length === 0) return "-";
        return defenders.map(d => {
            const stat = UNIT_STATS[d.code];
            const nm = stat ? stat.name : d.code;
            return `${nm} x${d.count} `;
        }).join(" / ");
    }

    getCaptureEffectToast(type) {
        const data = this.getFieldObjectData(type);
        if (!data || !data.abilities) return "";

        const messages = [];
        data.abilities.forEach(ab => {
            const val = Number(ab.value);
            if (ab.code === ABILITY_CODES.GATE_OPEN) messages.push("관문 돌파: 이동로 개방");
            else if (ab.code === ABILITY_CODES.SQUAD_SLOT) messages.push("성채 효과: 추가 스쿼드 +1");
            else if (ab.code === ABILITY_CODES.CP_CAP) messages.push(`지휘력 최대 + ${val} `);
            else if (ab.code === ABILITY_CODES.CP_REGEN) messages.push(`지휘력 리젠 + ${val}/5분`);
            else if (ab.code === ABILITY_CODES.GOLD_CAP) messages.push(`골드 최대 +${val}`);
            else if (ab.code === ABILITY_CODES.GOLD_REGEN) messages.push(`골드 리젠 +${val}/5분`);
            else if (ab.code === ABILITY_CODES.ENERGY_CAP) messages.push(`에너지 최대 +${val}`);
            else if (ab.code === ABILITY_CODES.ENERGY_REGEN) messages.push(`에너지 리젠 +${val}/5분`);
            else if (ab.code === ABILITY_CODES.TAX) messages.push(`세금 징수 +${val}G`);
            // Add other codes as needed
        });

        // Fallback or specific handling for Statues if they don't use abilities array yet
        if (isStatueTile(type)) {
            const buff = this.getStatueBuff(type);
            if (buff) {
                const label = buff.kind === "atk" ? "공격" : (buff.kind === "def" ? "방어" : (buff.kind === "hp" ? "체력" : "속도"));
                messages.push(`${label} 석상 효과: +${this.formatPercent(buff.value)}`);
            }
        }

        return messages.join(", ");
    }

    pushEffectLog(message) {
        if (!message) return;
        const now = new Date();
        const time = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        this.effectLog.unshift({ time, message });
        if (this.effectLog.length > 5) this.effectLog.length = 5;
        this.renderEffectLog();
    }

    renderEffectLog() {
        const panel = document.getElementById('field-effect-log');
        if (!panel) return;
        if (!this.effectLog.length) {
            panel.style.display = 'none';
            panel.innerHTML = '';
            return;
        }
        panel.style.display = 'flex';
        panel.innerHTML = `<div class="title">효과 로그</div>` + this.effectLog
            .map(entry => `<div class="entry">${entry.time} · ${entry.message}</div>`)
            .join("");
    }

    getFieldIconEmoji(type) {
        if (isWallTile(type)) return "🧱";
        if (isCastleTile(type)) return "🏰";
        if (isGateTile(type)) return "🚪";
        if (isCitadelTile(type)) return "🏯";
        if (isDragonTile(type)) return "🐉";
        if (isGoldMineTile(type)) return "⛏️";
        if (isFountainTile(type)) return "⛲";
        if (isShopTile(type)) return "🏪";
        if (isTavernTile(type)) return "🍺";
        if (isRuinsTile(type)) return "🏛️";
        if (isStatueTile(type)) return "🗿";
        if (isTerrainCode(type)) return "🗺️";
        return "❓";
    }

    updateFieldBottomBar(type, r, c, info) {
        const bar = document.getElementById('field-bottom-bar');
        if (!bar) return;
        const icon = bar.querySelector('.field-bottom-icon');
        const nameEl = bar.querySelector('.field-bottom-name');
        const metaEl = bar.querySelector('.field-bottom-meta');
        const detailsEl = bar.querySelector('#field-bottom-details');
        const moveWrap = bar.querySelector('#field-move-options');
        if (!nameEl || !metaEl || !icon) return;

        if (type === null || type === undefined) {
            icon.innerHTML = "❔";
            icon.style.backgroundImage = "";
            nameEl.textContent = "선택된 오브젝트 없음";
            metaEl.textContent = "오브젝트를 선택하세요.";
            if (detailsEl) detailsEl.innerHTML = "";
            if (moveWrap) moveWrap.innerHTML = "";
            return;
        }

        const data = info || this.getFieldObjectInfo(type, r, c);
        const title = `${data.name}${data.level !== "-" ? ` Lv.${data.level}` : ""}`;
        const metaParts = [];
        if (data.owner && data.owner !== "-") metaParts.push(`소유 ${data.owner}`);
        if (!metaParts.length && typeof r === "number" && typeof c === "number") metaParts.push(`좌표 ${r},${c}`);

        icon.innerHTML = this.getFieldIconEmoji(type);
        icon.style.backgroundImage = "";
        nameEl.textContent = title;
        metaEl.textContent = metaParts.join(" · ");
    }

    setFieldInfo(type, r, c) {
        const panel = document.getElementById('field-info-panel');
        if (!panel) return;
        if (type === null || type === undefined) {
            panel.classList.remove('open');
            panel.innerHTML = `<div class="field-info-title">선택 없음</div><div class="field-info-small">필드 오브젝트를 선택하세요.</div>`;
            const wrap = document.getElementById('field-floating-wrap');
            if (wrap) wrap.style.display = 'none';
            const prev = document.querySelector('.field-selected');
            if (prev) prev.classList.remove('field-selected');
            this.currentFieldTargetKey = null;
            this.currentFieldTargetType = null;
            this.updateFieldBottomBar(null);
            return;
        }
        panel.classList.remove('open');
        panel.innerHTML = "";
        const targetKey = `${r},${c}`;
        const isNewTarget = this.currentFieldTargetKey !== targetKey || this.currentFieldTargetType !== type;
        this.currentFieldTargetKey = targetKey;
        this.currentFieldTargetType = type;
        if (isNewTarget) {
            const prev = document.querySelector('.field-selected');
            if (prev) prev.classList.remove('field-selected');
            const cell = document.getElementById(`field-cell-${r}-${c}`);
            if (cell) cell.classList.add('field-selected');
        }
        const info = this.getFieldObjectInfo(type, r, c);
        let extraRows = "";
        if (isGoldMineTile(type) || isFountainTile(type)) {
            const res = this.getFieldResourceState(type, r, c);
            if (res) {
                const kind = isGoldMineTile(type) ? "골드" : "에너지";
                extraRows += `<div class="field-info-row"><span>누적 ${kind}</span><span>${res.state.stored}/${res.cfg.cap}</span></div>`;
                extraRows += `<div class="field-info-row"><span>리젠</span><span>5분당 ${res.cfg.regen5}</span></div>`;
                const ratio = res.cfg.cap > 0 ? Math.min(100, Math.round((res.state.stored / res.cfg.cap) * 100)) : 0;
                const barColor = isGoldMineTile(type) ? "#fbbf24" : "#38bdf8";
                extraRows += `<div class="field-info-bar"><div class="field-info-bar-fill" style="width:${ratio}%;background:${barColor};"></div></div>`;
            }
        }
        let effectRows = "";
        const objData = this.getFieldObjectData(type);
        if (objData && objData.abilities && objData.abilities.length > 0) {
            objData.abilities.forEach(ab => {
                const val = Number(ab.value);
                if (ab.code === ABILITY_CODES.CP_CAP) effectRows += `<div class="field-info-row"><span>지휘력 최대</span><span>+${val}</span></div>`;
                else if (ab.code === ABILITY_CODES.CP_REGEN) effectRows += `<div class="field-info-row"><span>지휘력 리젠</span><span>5분당 +${val}</span></div>`;
                else if (ab.code === ABILITY_CODES.GOLD_CAP) effectRows += `<div class="field-info-row"><span>골드 최대</span><span>+${val}</span></div>`;
                else if (ab.code === ABILITY_CODES.GOLD_REGEN) effectRows += `<div class="field-info-row"><span>골드 리젠</span><span>5분당 +${val}</span></div>`;
                else if (ab.code === ABILITY_CODES.ENERGY_CAP) effectRows += `<div class="field-info-row"><span>에너지 최대</span><span>+${val}</span></div>`;
                else if (ab.code === ABILITY_CODES.ENERGY_REGEN) effectRows += `<div class="field-info-row"><span>에너지 리젠</span><span>5분당 +${val}</span></div>`;
                else if (ab.code === ABILITY_CODES.TAX) effectRows += `<div class="field-info-row"><span>세금</span><span>+${val}G/3초</span></div>`;
                else if (ab.code === ABILITY_CODES.UPKEEP) effectRows += `<div class="field-info-row"><span>유지비</span><span>-${val}G/3초</span></div>`;
                // Add more mappings as needed (e.g. Buffs via generic logic or specific codes)
            });
        }

        // Keep hardcoded fallbacks ONLY if data is missing, but prefer data.
        if (effectRows === "") {
            if (isGateTile(type)) {
                effectRows += `<div class="field-info-row"><span>효과</span><span>통로 개방</span></div>`;
            }
            if (isCitadelTile(type)) {
                effectRows += `<div class="field-info-row"><span>효과</span><span>추가 스쿼드 +1</span></div>`;
            }
        }

        if (isStatueTile(type)) {
            const buff = this.getStatueBuff(type);
            if (buff) {
                const label = buff.kind === "atk" ? "공격" : (buff.kind === "def" ? "방어" : (buff.kind === "hp" ? "체력" : "속도"));
                effectRows += `<div class="field-info-row"><span>${label} 버프</span><span>+${this.formatPercent(buff.value)}</span></div>`;
            }
        }
        const bar = document.getElementById('field-bottom-bar');
        if (bar) {
            const details = bar.querySelector('#field-bottom-details');
            if (details) {
                details.innerHTML = `
                    <div class="field-bottom-section-title">오브젝트 정보</div>
                    <div class="field-info-row"><span>소유자</span><span>${info.owner}</span></div>
                    <div class="field-info-row"><span>수비병</span><span>${this.formatDefenders(info.defenders)}</span></div>
                    ${extraRows}
                    ${effectRows}
                    <div class="field-info-small">좌표: ${r},${c}</div>
                `;
            }
            this.renderFieldMoveOptions(bar, r, c, type, isNewTarget);
        }
        this.updateFloatingPanelPosition(r, c);
        this.updateFieldBottomBar(type, r, c, info);
    }

    updateFloatingPanelPosition(r, c) {
        const wrap = document.getElementById('field-floating-wrap');
        if (!wrap) return;
        if (!this.movePreviewText) {
            wrap.style.display = 'none';
            return;
        }
        if (typeof r !== "number" || typeof c !== "number") {
            wrap.style.display = 'none';
            return;
        }
        wrap.style.display = 'flex';
    }

    updateFloatingPanelPositionFromSelection() {
        if (!this.currentFieldTargetKey) {
            this.updateFloatingPanelPosition();
            return;
        }
        const parts = this.currentFieldTargetKey.split(',');
        if (parts.length < 2) return;
        const r = Number(parts[0]);
        const c = Number(parts[1]);
        if (Number.isNaN(r) || Number.isNaN(c)) return;
        this.updateFloatingPanelPosition(r, c);
    }

    getArmyMoveInfo(army, targetR, targetC) {
        const squadData = this.getSquadByArmyId(army.id);
        const stats = this.getSquadStats(squadData);
        if (stats.power < 10) return { armyId: army.id, canMove: false, reason: "병력 부족", stats };
        if (army.state !== 'IDLE') return { armyId: army.id, canMove: false, reason: "이동중", stats };
        const regionId = this.getArmyRegionId(army);

        const path = AStar.findPath(
            { r: army.r, c: army.c },
            { r: targetR, c: targetC },
            FIELD_MAP_DATA,
            this.occupiedTiles,
            (cur, nr, nc, type, isOcc, isTarget) => this.isTileBlocked(cur, nr, nc, type, isOcc, isTarget, regionId)
        );
        if (!path) return { armyId: army.id, canMove: false, reason: "갈 수 없음", stats };

        const dist = path.length - 1;
        const cpCost = dist * CP_COST_PER_TILE;
        const summary = this.getPathSummary(path, stats.speedFactor);
        const timeMin = summary ? summary.finalMin : 0;

        if (dist > stats.range) return { armyId: army.id, canMove: false, reason: `거리 ${dist}/${stats.range}`, dist, cpCost, timeMin, stats };
        if (this.cp < cpCost) return { armyId: army.id, canMove: false, reason: `CP ${cpCost}`, dist, cpCost, timeMin, stats };

        return { armyId: army.id, canMove: true, dist, cpCost, timeMin, stats };
    }

    renderFieldMoveOptions(panel, r, c, type, isNewTarget) {
        const wrap = panel.querySelector('#field-move-options');
        if (!wrap) return;
        wrap.innerHTML = "";


        const infos = this.getAvailableArmies().map(army => this.getArmyMoveInfo(army, r, c, type));

        if (isNewTarget) {
            let preferred = this.lastSelectedArmyId;
            const preferredInfo = infos.find(i => i.armyId === preferred);
            if (!preferredInfo || !preferredInfo.canMove) preferred = null;
            if (preferred === null || preferred === undefined) {
                const viable = infos.filter(i => i.canMove);
                if (viable.length > 0) {
                    viable.sort((a, b) => a.timeMin - b.timeMin || a.cpCost - b.cpCost);
                    preferred = viable[0].armyId;
                }
            }
            if (preferred !== null && preferred !== undefined) {
                this.selectedArmyId = preferred;
                this.lastSelectedArmyId = preferred;
                this.enterMoveTargetMode(preferred, { center: false });
            }
        }

        let summaryInfo = null;
        const summaryId = (this.selectedArmyId !== null && this.selectedArmyId !== undefined)
            ? this.selectedArmyId
            : this.lastSelectedArmyId;
        if (summaryId !== null && summaryId !== undefined) {
            summaryInfo = infos.find(i => i.armyId === summaryId && i.canMove);
        }
        if (!summaryInfo) summaryInfo = infos.find(i => i.canMove);
        const summaryRow = document.createElement('div');
        summaryRow.className = 'field-info-row';
        if (summaryInfo) {
            const etaMin = Math.max(1, Math.round(summaryInfo.timeMin));
            summaryRow.innerHTML = `<span>ETA</span><span>S${summaryInfo.armyId + 1} ${etaMin}m / CP ${summaryInfo.cpCost}</span>`;
        } else {
            summaryRow.innerHTML = `<span>ETA</span><span>-</span>`;
        }
        wrap.appendChild(summaryRow);
        if (summaryInfo && summaryInfo.stats) {
            const rangeRow = document.createElement('div');
            rangeRow.className = 'field-info-row';
            rangeRow.innerHTML = `<span>이동 범위</span><span>${summaryInfo.stats.range}칸</span>`;
            wrap.appendChild(rangeRow);
        }

        const divider = document.createElement('div');
        divider.className = 'field-bottom-divider';
        wrap.appendChild(divider);

        infos.forEach(info => {
            const btn = document.createElement('button');
            btn.className = 'field-eta-btn field-info-row';
            if (info.armyId === this.selectedArmyId) btn.classList.add('active');
            if (!info.canMove) btn.classList.add('disabled');

            const etaText = info.canMove
                ? `${Math.max(1, Math.round(info.timeMin))}m / CP ${info.cpCost}`
                : `불가 · ${info.reason}`;
            btn.innerHTML = `<span>S${info.armyId + 1}</span><span>${etaText}</span>`;

            btn.onclick = (e) => {
                e.stopPropagation();
                if (!info.canMove) { this.showToast(info.reason); return; }
                this.selectedArmyId = info.armyId;
                this.lastSelectedArmyId = info.armyId;
                this.enterMoveTargetMode(info.armyId, { center: false });
                wrap.querySelectorAll('.field-eta-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };

            wrap.appendChild(btn);
        });
    }

    applyFieldBuffsToStats(stats) {
        if (!stats) return stats;
        const buffs = this.fieldBuffs || { atk: 0, def: 0, hp: 0, spd: 0 };
        return {
            ...stats,
            hp: stats.hp ? Math.round(stats.hp * (1 + buffs.hp)) : stats.hp,
            atk: stats.atk ? Math.round(stats.atk * (1 + buffs.atk)) : stats.atk,
            def: stats.def ? Math.round(stats.def * (1 + buffs.def)) : stats.def,
            spd: stats.spd ? Math.round(stats.spd * (1 + buffs.spd)) : stats.spd
        };
    }

    getSquadInfo(squadData) {
        let count = 0, totalLevel = 0, power = 0;
        let totalHp = 0, totalAtk = 0, totalDef = 0;
        let totalSpd = 0, totalRng = 0;
        let minMov = 99, maxMov = 0;
        const units = [];
        squadData.forEach(u => {
            if (!u) return;
            count++;
            totalLevel += u.level;
            const base = getData(u.type, u.level);
            const data = this.applyFieldBuffsToStats(base);
            if (data && data.hp) {
                power += data.hp + data.atk + data.def;
                totalHp += data.hp; totalAtk += data.atk; totalDef += data.def;
            }
            if (data && data.spd) totalSpd += data.spd;
            if (data && data.rng) totalRng += data.rng;
            if (base && base.mov) { minMov = Math.min(minMov, base.mov); maxMov = Math.max(maxMov, base.mov); }
            units.push({
                name: base.name, level: u.level,
                hp: data?.hp || 0, atk: data?.atk || 0, def: data?.def || 0,
                spd: data?.spd || 0, rng: data?.rng || 0, mov: base?.mov || 0
            });
        });
        if (minMov === 99) minMov = 0;
        const avgSpd = count ? (totalSpd / count) : 0;
        const avgRng = count ? (totalRng / count) : 0;
        return { count, totalLevel, power, totalHp, totalAtk, totalDef, avgSpd, avgRng, minMov, maxMov, units };
    }

    setSquadInfoPanel(army) {
        const panel = document.getElementById('field-info-panel');
        if (!panel) return;
        const squadData = this.getSquadByArmyId(army.id);
        const info = this.getSquadInfo(squadData);
        const stats = this.getSquadStats(squadData);
        const moveText = info.minMov ? `${info.minMov}~${info.maxMov}` : "-";
        const avgSpd = info.avgSpd ? info.avgSpd.toFixed(1) : "0.0";
        const avgRng = info.avgRng ? info.avgRng.toFixed(1) : "0.0";
        const speedFactorText = `x${stats.speedFactor.toFixed(2)}`;
        const buffParts = [];
        if (this.fieldBuffs?.atk) buffParts.push(`ATK +${this.formatPercent(this.fieldBuffs.atk)}`);
        if (this.fieldBuffs?.def) buffParts.push(`DEF +${this.formatPercent(this.fieldBuffs.def)}`);
        if (this.fieldBuffs?.hp) buffParts.push(`HP +${this.formatPercent(this.fieldBuffs.hp)}`);
        if (this.fieldBuffs?.spd) buffParts.push(`SPD +${this.formatPercent(this.fieldBuffs.spd)}`);
        const buffText = buffParts.length ? buffParts.join(" / ") : "-";
        const unitHtml = info.units.length
            ? info.units.map(u => `<div>${u.name} Lv.${u.level} · HP ${u.hp} ATK ${u.atk} DEF ${u.def} SPD ${u.spd} RNG ${u.rng} MOV ${u.mov}</div>`).join("")
            : "<div>없음</div>";
        panel.innerHTML = `
            <div class="field-info-title">${army.name} 정보</div>
            <div class="field-info-row"><span>멤버</span><span>${info.count}/9</span></div>
            <div class="field-info-row"><span>총 레벨</span><span>${info.totalLevel}</span></div>
            <div class="field-info-row"><span>전투력</span><span>${info.power}</span></div>
            <div class="field-info-row"><span>총 HP/ATK/DEF</span><span>${info.totalHp}/${info.totalAtk}/${info.totalDef}</span></div>
            <div class="field-info-row"><span>평균 속도/사거리</span><span>${avgSpd}/${avgRng}</span></div>
            <div class="field-info-row"><span>이동력(최소~최대)</span><span>${moveText}</span></div>
            <div class="field-info-row"><span>이동 범위</span><span>${stats.range}</span></div>
            <div class="field-info-row"><span>속도 보정</span><span>${speedFactorText}</span></div>
            <div class="field-info-row"><span>필드 버프</span><span>${buffText}</span></div>
            <div class="field-info-small">${unitHtml}</div>
        `;
    }

    hideFieldActionMenu() {
        const menu = document.getElementById('field-action-menu');
        if (menu) menu.remove();
    }

    showFieldActionMenu(r, c, type, clientX, clientY) {
        this.hideFieldActionMenu();
        const viewport = document.getElementById('map-viewport');
        if (!viewport) return;

        const menu = document.createElement('div');
        menu.id = 'field-action-menu';
        menu.className = 'field-action-menu';

        const moveBtn = document.createElement('button');
        moveBtn.className = 'field-action-btn';
        moveBtn.innerText = '부대 이동';
        moveBtn.onclick = (e) => {
            e.stopPropagation();
            this.hideFieldActionMenu();
            if (this.selectedArmyId !== null) {
                this.exitMoveTargetMode();
                this.commandArmy(this.selectedArmyId, r, c, type);
            } else {
                this.openSquadSelector(r, c, type, false);
            }
        };

        const infoBtn = document.createElement('button');
        infoBtn.className = 'field-action-btn';
        infoBtn.innerText = '부대 정보';
        infoBtn.onclick = (e) => {
            e.stopPropagation();
            this.hideFieldActionMenu();
            this.openSquadSelector(r, c, type, true);
        };

        menu.appendChild(moveBtn);
        menu.appendChild(infoBtn);

        const key = `${r},${c}`;
        if (isGoldMineTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '골드 수령';
            btn.onclick = (e) => { e.stopPropagation(); this.collectFieldResource(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        if (isFountainTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '에너지 수령';
            btn.onclick = (e) => { e.stopPropagation(); this.collectFieldResource(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        if (isShopTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '상점 이용';
            btn.onclick = (e) => { e.stopPropagation(); this.openShopOrTavern(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }
        if (isTavernTile(type)) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '주점 이용';
            btn.onclick = (e) => { e.stopPropagation(); this.openShopOrTavern(type, r, c); };
            if (!this.occupiedTiles.has(key)) btn.classList.add('disabled');
            menu.appendChild(btn);
        }

        if (type === FIELD_EVENT_TYPES.CARAVAN) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '상점 열기';
            btn.onclick = (e) => { e.stopPropagation(); this.openCaravanShop(); };
            menu.appendChild(btn);
        }
        if (type === FIELD_EVENT_TYPES.PORTAL) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '이동';
            btn.onclick = (e) => { e.stopPropagation(); this.openPortalModal(r, c); };
            menu.appendChild(btn);
        }
        // Attack Button for Bandits AND Hostile Static Objects
        const isHostile = (type === FIELD_EVENT_TYPES.BANDIT || type === FIELD_EVENT_TYPES.BANDIT_LEADER || type === FIELD_EVENT_TYPES.DUNGEON);
        const isUnoccupiedCapturable = this.isCapturableFieldObject(type) && !this.occupiedTiles.has(key);

        if (isHostile || isUnoccupiedCapturable) {
            const btn = document.createElement('button');
            btn.className = 'field-action-btn';
            btn.innerText = '공격';
            btn.onclick = (e) => {
                e.stopPropagation();
                this.hideFieldActionMenu();

                // If no army selected, try to select the nearest available army? 
                // Currently prompts user to select.
                if (this.selectedArmyId !== null) {
                    const army = this.armies[this.selectedArmyId];
                    const dr = Math.abs(army.r - r);
                    const dc = Math.abs(army.c - c);
                    // CHANGED: Allow diagonal attack (Chebyshev distance <= 1)
                    if (dr <= 1 && dc <= 1) {
                        this.openBattlePrepModal(type, r, c);
                    } else {
                        this.showToast("거리가 멉니다. (1칸 이내 접근 필요)");
                    }
                } else {
                    this.showToast("공격할 부대를 먼저 선택하세요.");
                }
            };
            menu.appendChild(btn);
        }
        viewport.appendChild(menu);

        const rect = viewport.getBoundingClientRect();
        let x = clientX - rect.left;
        let y = clientY - rect.top;
        const menuW = 110, menuH = 80;
        const clampPos = (pos) => ({
            x: Math.min(rect.width - menuW - 8, Math.max(8, pos.x)),
            y: Math.min(rect.height - menuH - 8, Math.max(8, pos.y))
        });

        const candidates = [
            { x: x + 8, y: y - 8 },
            { x: x - menuW - 8, y: y - 8 },
            { x: x - menuW / 2, y: y + 10 },
            { x: x - menuW / 2, y: y - menuH - 10 }
        ];

        let finalPos = clampPos(candidates[0]);
        const wrap = document.getElementById('field-floating-wrap');
        if (wrap && wrap.style.display !== 'none') {
            const wrapRect = wrap.getBoundingClientRect();
            const wr = {
                left: wrapRect.left - rect.left,
                top: wrapRect.top - rect.top,
                right: wrapRect.right - rect.left,
                bottom: wrapRect.bottom - rect.top
            };
            const intersects = (a, b) => a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
            for (const cand of candidates) {
                const pos = clampPos(cand);
                const mr = { left: pos.x, top: pos.y, right: pos.x + menuW, bottom: pos.y + menuH };
                if (!intersects(mr, wr)) { finalPos = pos; break; }
            }
        }

        menu.style.left = `${finalPos.x}px`;
        menu.style.top = `${finalPos.y}px`;
    }

    refreshFieldMapVisuals() {
        const mapLayer = document.getElementById('map-layer');
        if (!mapLayer) return false;
        const reachable = this.buildReachableTiles();
        const appendCloudLayer = (cell, r, c, type) => {
            if (isGateTile(type) || isCitadelTile(type) || isWallTile(type)) return;
            const layer = document.createElement('div');
            layer.className = 'field-cloud-layer';
            cell.appendChild(layer);
        };

        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const cell = document.getElementById(`field-cell-${r}-${c}`);
                if (!cell) continue;
                const type = FIELD_MAP_DATA[r][c];
                const key = `${r},${c}`;
                const isOccupied = this.occupiedTiles.has(key);
                const isVisible = this.visibilityMap.has(key);
                const isReachable = reachable.has(key);
                let isAdjacent = false;
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                if (!isOccupied) {
                    for (let d of dirs) {
                        const nr = r + d[0], nc = c + d[1];
                        if (this.occupiedTiles.has(`${nr},${nc}`)) { isAdjacent = true; break; }
                    }
                }

                cell.className = 'field-cell';
                cell.innerHTML = '';
                cell.style.backgroundImage = '';
                cell.style.backgroundSize = '';
                cell.style.backgroundRepeat = '';
                cell.style.backgroundPosition = '';
                cell.style.opacity = '';

                if (!isVisible) {
                    cell.classList.add('field-fog');
                    appendCloudLayer(cell, r, c, type);
                    continue;
                }

                let color = 'rgba(0, 0, 0, 0)';
                if (isWallTile(type)) { color = '#2b2b2b'; cell.classList.add('field-wall'); }
                else if (isCastleTile(type)) { color = '#4285f4'; cell.classList.add('field-castle'); }
                else if (isGateTile(type)) { color = '#ea4335'; cell.classList.add('field-gate'); if (isOccupied) cell.classList.add('unlocked'); else cell.classList.add('locked'); }
                else if (isCitadelTile(type)) { color = '#fbbc05'; cell.classList.add('field-citadel'); }
                else if (isDragonTile(type)) { color = '#b71c1c'; cell.classList.add('field-dragon'); }
                else if (isGoldMineTile(type)) { color = '#6d4c41'; cell.classList.add('field-goldmine'); }
                else if (isFountainTile(type)) { color = '#0ea5e9'; cell.classList.add('field-fountain'); }
                else if (isShopTile(type)) { color = '#2563eb'; cell.classList.add('field-shop'); }
                else if (isTavernTile(type)) { color = '#7c3aed'; cell.classList.add('field-tavern'); }
                else if (isRuinsTile(type)) { color = '#9ca3af'; cell.classList.add('field-ruins'); }
                else if (isStatueTile(type)) { color = '#94a3b8'; cell.classList.add('field-statue'); }
                else if (isTerrainCode(type)) {
                    const base = getTerrainBase(type);
                    const isBorder = type % 100 === 1;
                    color = (isBorder ? TERRAIN_COLORS_BORDER[base] : TERRAIN_COLORS[base]) || '#2e3b23';
                } else if (type === 4) {
                    color = 'rgba(139, 69, 19, 0.4)';
                } else {
                    const base = FIELD_TERRAIN_DATA?.[r]?.[c];
                    if (isTerrainCode(base)) {
                        const baseType = getTerrainBase(base);
                        const isBorder = base % 100 === 1;
                        color = (isBorder ? TERRAIN_COLORS_BORDER[baseType] : TERRAIN_COLORS[baseType]) || '#2e3b23';
                    } else {
                        color = 'transparent';
                    }
                }

                cell.style.backgroundColor = color;

                const isKnownObject = isWallTile(type) || isCastleTile(type) || isGateTile(type) || isCitadelTile(type) || isDragonTile(type)
                    || isGoldMineTile(type) || isFountainTile(type) || isShopTile(type) || isTavernTile(type)
                    || isRuinsTile(type) || isStatueTile(type);
                if (!isTerrainCode(type) && !isKnownObject) {
                    const icon = this.assets.getImage(String(type));
                    if (icon && icon.src) {
                        cell.style.backgroundImage = `url(${icon.src})`;
                        cell.style.backgroundSize = 'contain';
                        cell.style.backgroundRepeat = 'no-repeat';
                        cell.style.backgroundPosition = 'center';
                    }
                }

                if (isOccupied) {
                    cell.classList.add('field-occupied');
                    cell.style.opacity = 1.0;
                } else if (isAdjacent) {
                    cell.classList.add('field-adjacent');
                    cell.style.opacity = 0.6;
                } else {
                    cell.style.opacity = 1.0;
                }

                if (!isReachable && !isOccupied) {
                    cell.classList.add('field-cloud-blocked');
                    appendCloudLayer(cell, r, c, type);
                }

                if (this.currentFieldTargetKey === key) cell.classList.add('field-selected');

                if (isGateTile(type) || isCitadelTile(type) || isRuinsTile(type) || isStatueTile(type)) {
                    const badge = document.createElement('div');
                    badge.className = 'field-badge';
                    badge.classList.add(isOccupied ? 'active' : 'inactive');
                    if (isGateTile(type)) badge.innerText = 'GT';
                    else if (isCitadelTile(type)) badge.innerText = 'SQ';
                    else if (isRuinsTile(type)) badge.innerText = 'CP';
                    else if (isStatueTile(type)) {
                        const buff = this.getStatueBuff(type);
                        const kind = buff ? buff.kind.toUpperCase() : 'BF';
                        if (kind === 'ATK') badge.innerText = 'AT';
                        else if (kind === 'DEF') badge.innerText = 'DF';
                        else if (kind === 'HP') badge.innerText = 'HP';
                        else if (kind === 'SPD') badge.innerText = 'SP';
                        else badge.innerText = kind.slice(0, 2);
                    }
                    cell.appendChild(badge);
                }
            }
        }

        if (this.previewPath) this.applyPathPreview(this.previewPath);
        if (this.moveTargetMode) this.renderMoveTimeOverlay();
        this.updateFloatingPanelPositionFromSelection();
        return true;
    }
    renderFieldMap() {
        const modal = document.getElementById('field-modal'); const content = document.getElementById('modal-content'); const title = document.getElementById('modal-title');
        modal.dataset.mode = 'field'; modal.classList.add('open'); title.innerText = "월드 맵 (Field)"; content.innerHTML = ""; content.style.overflow = "hidden";
        content.style.position = "relative";
        content.style.display = "block";
        content.style.height = "100%";

        if (this.selectedArmyId !== null) {
            const existingHud = document.querySelector('.selected-army-hud');
            if (existingHud) existingHud.remove();

            const armyName = this.armies[this.selectedArmyId].name;
            const hud = document.createElement('div');
            hud.className = 'selected-army-hud';
            hud.innerHTML = `<span class="hud-name">${armyName} 선택됨</span><button class="hud-btn" onclick="game.deselectArmy()">선택 해제</button>`;
            content.appendChild(hud);
        }

        const viewport = document.createElement('div'); viewport.id = 'map-viewport'; viewport.style.position = 'absolute'; viewport.style.inset = '0'; viewport.style.width = '100%'; viewport.style.height = '100%'; viewport.style.overflow = 'hidden';
        viewport.style.backgroundColor = '#2e3b23';
        viewport.style.touchAction = 'none';
        viewport.onclick = (e) => { if (e.target === viewport) this.hideFieldActionMenu(); };
        content.appendChild(viewport);

        const overlay = document.createElement('div');
        overlay.className = 'field-overlay';

        const headerDiv = document.createElement('div'); headerDiv.className = "flex justify-between items-center bg-gray-700 px-2 py-1 rounded text-[11px] shadow-md";
        const incomeSign = this.income >= 0 ? "+" : "";
        headerDiv.innerHTML = `<div>점령: <span class="text-white font-bold">${this.occupiedTiles.size}</span></div><div>세금: <span class="text-yellow-400 font-bold">${incomeSign}${this.income}/3sec</span></div><div>CP: <span id="field-cp-display" class="text-white font-bold">${this.cp}/${this.maxCp}</span></div>`;
        overlay.appendChild(headerDiv);

        const effectLog = document.createElement('div');
        effectLog.id = 'field-effect-log';
        effectLog.className = 'field-effect-log';
        overlay.appendChild(effectLog);

        const floatingWrap = document.createElement('div');
        floatingWrap.id = 'field-floating-wrap';
        floatingWrap.className = 'field-floating-wrap';

        const moveInfo = document.createElement('div'); moveInfo.id = 'field-move-info'; moveInfo.className = 'field-move-info';
        moveInfo.style.display = 'none';
        moveInfo.onclick = () => { if (this.moveTargetMode) this.exitMoveTargetMode(); };
        floatingWrap.appendChild(moveInfo);

        const infoPanel = document.createElement('div'); infoPanel.id = 'field-info-panel'; infoPanel.className = 'field-info-panel';
        infoPanel.style.display = 'none';
        floatingWrap.appendChild(infoPanel);

        overlay.appendChild(floatingWrap);
        content.appendChild(overlay);

        const mapLayer = document.createElement('div'); mapLayer.id = 'map-layer'; mapLayer.style.position = 'absolute'; mapLayer.style.transformOrigin = '0 0'; mapLayer.style.display = 'grid'; mapLayer.style.gridTemplateColumns = `repeat(${MAP_SIZE}, 12px)`; mapLayer.style.gap = '1px'; mapLayer.style.padding = '50px';
        const mapSizePx = (MAP_SIZE * 13 - 1) + 100;
        const pathOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        pathOverlay.setAttribute('id', 'path-overlay');
        pathOverlay.setAttribute('width', mapSizePx);
        pathOverlay.setAttribute('height', mapSizePx);
        pathOverlay.setAttribute('viewBox', `0 0 ${mapSizePx} ${mapSizePx}`);
        mapLayer.appendChild(pathOverlay);
        this.pathOverlay = pathOverlay;

        const bgImg = this.assets.getImage('field_bg');
        if (bgImg && bgImg.src) {
            mapLayer.style.backgroundImage = `url(${bgImg.src})`;
        } else {
            mapLayer.style.backgroundImage = `url(${this.grassTexture})`;
        }
        mapLayer.style.backgroundRepeat = 'repeat';

        const armyLayer = document.createElement('div'); armyLayer.id = 'army-layer'; armyLayer.style.position = 'absolute'; armyLayer.style.top = '0'; armyLayer.style.left = '0'; armyLayer.style.width = '100%'; armyLayer.style.height = '100%'; armyLayer.style.pointerEvents = 'none'; armyLayer.style.zIndex = '50'; mapLayer.appendChild(armyLayer);

        // --- RENDER FIELD EVENTS ---
        Object.values(this.fieldEvents).forEach(evt => {
            const marker = document.createElement('div');
            marker.className = 'event-marker';
            marker.style.position = 'absolute';
            marker.style.left = `${50 + evt.c * 13}px`; // Fix: Add 50px padding offset + 13px pitch
            marker.style.top = `${50 + evt.r * 13}px`;
            marker.style.width = '12px';
            marker.style.height = '12px';
            marker.style.fontSize = '10px';
            marker.style.display = 'flex';
            marker.style.alignItems = 'center';
            marker.style.justifyContent = 'center';
            marker.style.lineHeight = '1';
            marker.style.padding = '0';
            marker.style.margin = '0';
            marker.style.zIndex = '40';
            marker.style.pointerEvents = 'none';

            if (evt.type === FIELD_EVENT_TYPES.BANDIT) marker.innerText = '🗡️';
            else if (evt.type === FIELD_EVENT_TYPES.BANDIT_LEADER) marker.innerText = '💀';
            else if (evt.type === FIELD_EVENT_TYPES.DUNGEON) marker.innerText = '🏰';
            else if (evt.type === FIELD_EVENT_TYPES.PORTAL) marker.innerText = '🌀';
            else if (evt.type === FIELD_EVENT_TYPES.CARAVAN) marker.innerText = '🐪';

            mapLayer.appendChild(marker);
        });

        this.getAvailableArmies().forEach(army => {
            const marker = document.createElement('div');
            marker.className = 'army-marker';
            if (this.selectedArmyId === army.id) marker.classList.add('selected');
            marker.id = `army-marker-${army.id}`;

            const squadData = this.getSquadByArmyId(army.id);
            let maxLevel = -1;
            let bestUnit = null;

            squadData.forEach(u => {
                if (u && u.level > maxLevel) {
                    maxLevel = u.level;
                    bestUnit = u;
                }
            });

            if (bestUnit) {
                const img = this.assets.getImage(bestUnit.type, bestUnit.level);
                if (img && img.src) {
                    marker.style.backgroundImage = `url(${img.src})`;
                    marker.innerText = "";
                } else {
                    marker.style.backgroundColor = army.color;
                    marker.innerText = army.id + 1;
                }
            } else {
                marker.style.backgroundColor = army.color;
                marker.innerText = army.id + 1;
            }

            const TILE_SIZE = 13, x = 50 + (army.c * TILE_SIZE), y = 50 + (army.r * TILE_SIZE); marker.style.transform = `translate(${x}px, ${y}px)`; armyLayer.appendChild(marker);
        });

        const reachable = this.buildReachableTiles();

        const appendCloudLayer = (cell, r, c, type) => {
            const evt = this.fieldEvents[`${r},${c}`];
            if (isGateTile(type) || isCitadelTile(type) || isWallTile(type) || isDragonTile(type)) return; // Fix: Dragon is static, explicit check needed
            if (evt) return; // VISIBILITY FIX: Reveal all known events through cloud.

            const layer = document.createElement('div');
            layer.className = 'field-cloud-layer';
            cell.appendChild(layer);
        };

        for (let r = 0; r < MAP_SIZE; r++) {
            for (let c = 0; c < MAP_SIZE; c++) {
                const cell = document.createElement('div'); cell.className = 'field-cell'; cell.id = `field-cell-${r}-${c}`;
                const type = FIELD_MAP_DATA[r][c], key = `${r},${c}`, isOccupied = this.occupiedTiles.has(key);
                // Fix: Events and Dragon are always visible
                const isVisible = this.visibilityMap.has(key) || !!this.fieldEvents[key] || isDragonTile(type);

                const isReachable = reachable.has(key);
                let isAdjacent = false; const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                if (!isOccupied) { for (let d of dirs) { const nr = r + d[0], nc = c + d[1]; if (this.occupiedTiles.has(`${nr},${nc}`)) { isAdjacent = true; break; } } }

                if (!isVisible) {
                    cell.classList.add('field-fog');
                    appendCloudLayer(cell, r, c, type);
                    mapLayer.appendChild(cell);
                    continue;
                }

                let color = 'rgba(0, 0, 0, 0)';
                if (isWallTile(type)) { color = '#2b2b2b'; cell.classList.add('field-wall'); }
                else if (isCastleTile(type)) { color = '#4285f4'; cell.classList.add('field-castle'); }
                else if (isGateTile(type)) { color = '#ea4335'; cell.classList.add('field-gate'); if (isOccupied) cell.classList.add('unlocked'); else cell.classList.add('locked'); }
                else if (isCitadelTile(type)) { color = '#fbbc05'; cell.classList.add('field-citadel'); }
                else if (isDragonTile(type)) { color = '#b71c1c'; cell.classList.add('field-dragon'); }
                else if (isGoldMineTile(type)) { color = '#6d4c41'; cell.classList.add('field-goldmine'); }
                else if (isFountainTile(type)) { color = '#0ea5e9'; cell.classList.add('field-fountain'); }
                else if (isShopTile(type)) { color = '#2563eb'; cell.classList.add('field-shop'); }
                else if (isTavernTile(type)) { color = '#7c3aed'; cell.classList.add('field-tavern'); }
                else if (isRuinsTile(type)) { color = '#9ca3af'; cell.classList.add('field-ruins'); }
                else if (isStatueTile(type)) { color = '#94a3b8'; cell.classList.add('field-statue'); }
                else if (isTerrainCode(type)) {
                    const base = getTerrainBase(type);
                    const isBorder = type % 100 === 1;
                    color = (isBorder ? TERRAIN_COLORS_BORDER[base] : TERRAIN_COLORS[base]) || '#2e3b23';
                } else if (type === 4) { color = 'rgba(139, 69, 19, 0.4)'; }
                else {
                    const base = FIELD_TERRAIN_DATA?.[r]?.[c];
                    if (isTerrainCode(base)) {
                        const baseType = getTerrainBase(base);
                        const isBorder = base % 100 === 1;
                        color = (isBorder ? TERRAIN_COLORS_BORDER[baseType] : TERRAIN_COLORS[baseType]) || '#2e3b23';
                    } else {
                        color = 'transparent';
                    }
                }

                cell.style.backgroundColor = color;

                const isKnownObject = isWallTile(type) || isCastleTile(type) || isGateTile(type) || isCitadelTile(type) || isDragonTile(type)
                    || isGoldMineTile(type) || isFountainTile(type) || isShopTile(type) || isTavernTile(type)
                    || isRuinsTile(type) || isStatueTile(type);
                if (!isTerrainCode(type) && !isKnownObject) {
                    const icon = this.assets.getImage(String(type));
                    if (icon && icon.src) {
                        cell.style.backgroundImage = `url(${icon.src})`;
                        cell.style.backgroundSize = 'contain';
                        cell.style.backgroundRepeat = 'no-repeat';
                        cell.style.backgroundPosition = 'center';
                    }
                }

                if (isOccupied) {
                    cell.classList.add('field-occupied');
                    cell.style.opacity = 1.0;
                } else if (isAdjacent) {
                    cell.classList.add('field-adjacent');
                    cell.style.opacity = 0.6;
                } else {
                    cell.style.opacity = 1.0;
                }

                if (!isReachable && !isOccupied) {
                    cell.classList.add('field-cloud-blocked');
                    appendCloudLayer(cell, r, c, type);
                }

                if (this.currentFieldTargetKey === key) cell.classList.add('field-selected');

                if (isGateTile(type) || isCitadelTile(type) || isRuinsTile(type) || isStatueTile(type)) {
                    const badge = document.createElement('div');
                    badge.className = 'field-badge';
                    badge.classList.add(isOccupied ? 'active' : 'inactive');
                    if (isGateTile(type)) badge.innerText = 'GT';
                    else if (isCitadelTile(type)) badge.innerText = 'SQ';
                    else if (isRuinsTile(type)) badge.innerText = 'CP';
                    else if (isStatueTile(type)) {
                        const buff = this.getStatueBuff(type);
                        const kind = buff ? buff.kind.toUpperCase() : 'BF';
                        if (kind === 'ATK') badge.innerText = 'AT';
                        else if (kind === 'DEF') badge.innerText = 'DF';
                        else if (kind === 'HP') badge.innerText = 'HP';
                        else if (kind === 'SPD') badge.innerText = 'SP';
                        else badge.innerText = kind.slice(0, 2);
                    }
                    cell.appendChild(badge);
                }

                // Additional marker classes handled above

                cell.onclick = (e) => {
                    e.stopPropagation();
                    if (!this.isDraggingMap) {
                        const evt = this.fieldEvents[`${r},${c}`];
                        const displayType = evt ? evt.type : type;
                        this.setFieldInfo(displayType, r, c);
                        this.showFieldActionMenu(r, c, displayType, e.clientX, e.clientY);
                    }
                };

                mapLayer.appendChild(cell);
            }
        }
        viewport.appendChild(mapLayer);

        const bottomBar = document.createElement('div');
        bottomBar.id = 'field-bottom-bar';
        bottomBar.className = 'field-bottom-bar';
        bottomBar.innerHTML = `
            <div class="field-bottom-icon">❔</div>
            <div class="field-bottom-text">
                <div class="field-bottom-header">
                    <div class="field-bottom-header-left">
                        <div class="field-bottom-name">선택된 오브젝트 없음</div>
                        <div class="field-bottom-meta">오브젝트를 선택하세요.</div>
                    </div>
                    <div class="field-bottom-header-right">
                        <div class="field-bottom-section-title">부대 이동</div>
                        <div class="field-bottom-meta">행동력/소요</div>
                    </div>
                </div>
                <div class="field-bottom-grid">
                    <div id="field-bottom-details" class="field-bottom-details"></div>
                    <div id="field-move-options" class="field-bottom-details"></div>
                </div>
            </div>
        `;
        viewport.appendChild(bottomBar);
        this.setMovePreview(this.movePreviewText);
        this.renderEffectLog();
        if (this.currentFieldTargetKey) {
            const [tr, tc] = this.currentFieldTargetKey.split(',').map(Number);
            if (!Number.isNaN(tr) && !Number.isNaN(tc) && FIELD_MAP_DATA?.[tr]?.[tc] !== undefined) {
                this.setFieldInfo(FIELD_MAP_DATA[tr][tc], tr, tc);
            } else {
                this.setFieldInfo(null);
            }
        } else {
            this.setFieldInfo(null);
        }
        if (this.previewPath) this.applyPathPreview(this.previewPath);
        if (this.moveTargetMode) this.renderMoveTimeOverlay();
        this.initFieldCamera(viewport, mapLayer);
    }

    deselectArmy() {
        this.selectedArmyId = null;
        this.exitMoveTargetMode();
        this.renderFieldMap();
    }

    commandArmy(armyId, targetR, targetC, tileType) {
        const army = this.armies[armyId];
        if (army.state !== 'IDLE') { this.showToast("부대가 이동 중입니다."); return; }
        const regionId = this.getArmyRegionId(army);
        this.lastSelectedArmyId = armyId;

        let energyCost = 1; let goldCost = 0;
        if (isGateTile(tileType)) { energyCost = 5; goldCost = 100; }

        const squadData = this.getSquadByArmyId(army.id);
        const stats = this.getSquadStats(squadData);

        if (stats.power < 10) { this.showToast("병력이 부족합니다."); return; }

        const path = AStar.findPath(
            { r: army.r, c: army.c },
            { r: targetR, c: targetC },
            FIELD_MAP_DATA,
            this.occupiedTiles,
            (cur, nr, nc, type, isOcc, isTarget) => this.isTileBlocked(cur, nr, nc, type, isOcc, isTarget, regionId)
        );

        if (!path) { this.showToast("갈 수 없는 지역입니다."); return; }
        const dist = path.length - 1;
        if (dist > stats.range) { this.showToast(`거리 초과 (${dist}/${stats.range})`); return; }
        const cpCost = dist * CP_COST_PER_TILE;
        if (this.cp < cpCost) { this.showToast(`지휘력 부족 (${cpCost})`); return; }

        this.startMarch(armyId, targetR, targetC, tileType, energyCost, goldCost, cpCost, path, stats.speedFactor);
    }

    getSquadStats(squadData) {
        let count = 0, totalMov = 0, minMov = 99;
        squadData.forEach(u => {
            if (u) {
                count++;
                const stats = getData(u.type, u.level);
                if (stats.mov) {
                    totalMov += stats.mov;
                    minMov = Math.min(minMov, stats.mov);
                }
            }
        });
        if (count === 0) return { power: 0, range: 0, speedFactor: 1 };

        const baseRange = 4;
        const range = baseRange + (minMov * 2);
        const baseSpeedFactor = Math.max(0.5, 1 - (minMov - 1) * 0.2);
        const spdBuff = this.fieldBuffs?.spd || 0;
        const speedFactor = Math.max(0.3, baseSpeedFactor * (1 - spdBuff));

        return { power: this.getSquadPower(squadData), range, speedFactor };
    }

    getHighestBuildingLevel(unitType) {
        let buildingType = -1;
        if (unitType === ITEM_TYPE.UNIT_INFANTRY) buildingType = ITEM_TYPE.BUILDING_BARRACKS;
        else if (unitType === ITEM_TYPE.UNIT_ARCHER) buildingType = ITEM_TYPE.BUILDING_RANGE;
        else if (unitType === ITEM_TYPE.UNIT_CAVALRY) buildingType = ITEM_TYPE.BUILDING_STABLE;

        if (buildingType === -1) return 10;

        let maxLvl = 0;
        for (let r = 0; r < CONFIG.gridRows; r++) {
            for (let c = 0; c < CONFIG.gridCols; c++) {
                const item = this.grid[r][c];
                if (item && item.type === buildingType) {
                    maxLvl = Math.max(maxLvl, item.level);
                }
            }
        }
        return maxLvl || 1;
    }

    openMoveSquadSelector() {
        const existing = document.querySelector('.squad-selector'); if (existing) existing.remove();
        this.hideFieldActionMenu();
        this.exitMoveTargetMode();
        const viewport = document.getElementById('map-viewport');
        if (!viewport) return;
        const selector = document.createElement('div'); selector.className = 'squad-selector';
        this.setMovePreview("이동할 부대를 선택하세요.");

        this.getAvailableArmies().forEach(army => {
            const card = document.createElement('div'); card.className = 'squad-card';
            const isIdle = army.state === 'IDLE';
            const squadData = this.getSquadByArmyId(army.id);
            const stats = this.getSquadStats(squadData);

            let statusHtml = "";
            if (!isIdle) statusHtml = `<div class="squad-status">이동중...</div>`;
            else if (stats.power < 10) statusHtml = `<div class="squad-status text-red-400">병력 부족</div>`;
            else statusHtml = `<div class="squad-status text-green-400">이동 범위 ${stats.range}</div>`;

            if (!isIdle || stats.power < 10) card.classList.add('disabled');
            card.innerHTML = `<div class="font-bold text-white">${army.name}</div>${statusHtml}`;

            if (!card.classList.contains('disabled')) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    this.selectedArmyId = army.id;
                    selector.remove();
                    this.enterMoveTargetMode(army.id, { center: false });
                };
            }
            selector.appendChild(card);
        });

        const closeBtn = document.createElement('div'); closeBtn.className = 'squad-card bg-red-900 border-red-700'; closeBtn.innerHTML = '<div class="font-bold text-red-200">취소</div>';
        closeBtn.onclick = (e) => { e.stopPropagation(); selector.remove(); this.setMovePreview(""); }; selector.appendChild(closeBtn);
        viewport.appendChild(selector);
    }

    openSquadSelector(targetR, targetC, tileType, infoOnly = false) {
        const existing = document.querySelector('.squad-selector'); if (existing) existing.remove();
        this.hideFieldActionMenu();
        const prevTarget = document.querySelector('.field-target'); if (prevTarget) prevTarget.classList.remove('field-target');
        const targetCell = document.getElementById(`field-cell-${targetR}-${targetC}`); if (targetCell) targetCell.classList.add('field-target');
        const viewport = document.getElementById('map-viewport'); const selector = document.createElement('div'); selector.className = 'squad-selector';
        let previewPath = null; let previewText = "";
        let defaultInfoSet = false;

        this.getAvailableArmies().forEach(army => {
            const card = document.createElement('div'); card.className = 'squad-card';
            const isIdle = army.state === 'IDLE';
            const squadData = this.getSquadByArmyId(army.id);
            const stats = this.getSquadStats(squadData);
            const squadInfo = this.getSquadInfo(squadData);
            const regionId = this.getArmyRegionId(army);

            const path = AStar.findPath(
                { r: army.r, c: army.c },
                { r: targetR, c: targetC },
                FIELD_MAP_DATA,
                this.occupiedTiles,
                (cur, nr, nc, type, isOcc, isTarget) => this.isTileBlocked(cur, nr, nc, type, isOcc, isTarget, regionId)
            );
            const dist = path ? path.length - 1 : 999;
            const reachable = path && dist <= stats.range;
            const cpCost = path ? dist * CP_COST_PER_TILE : 0;
            const summary = path ? this.getPathSummary(path, stats.speedFactor) : null;
            const timeMin = summary ? summary.finalMin : 0;
            const breakdown = summary ? summary.breakdown : "";
            const cpEnough = this.cp >= cpCost;

            if (!infoOnly && !previewPath && path && isIdle && stats.power >= 10 && reachable && cpEnough) {
                previewPath = path;
                const terrainText = breakdown ? ` · 지형 ${breakdown}` : "";
                previewText = `ETA ${timeMin.toFixed(1)}분 · 거리 ${dist}칸 · 지휘력 ${cpCost}${terrainText}`;
            }

            let statusHtml = "";
            if (infoOnly) {
                statusHtml = `<div class="squad-status">멤버: ${squadInfo.count}/9 · 총Lv: ${squadInfo.totalLevel}</div>` +
                    `<div class="squad-status text-[9px] text-gray-300">전투력 ${squadInfo.power} · 이동범위 ${stats.range}</div>`;
            } else {
                if (!isIdle) statusHtml = `<div class="squad-status">이동중...</div>`;
                else if (stats.power < 10) statusHtml = `<div class="squad-status text-red-400">병력 부족</div>`;
                else if (!path) statusHtml = `<div class="squad-status text-red-400">갈 수 없음</div>`;
                else if (!reachable) statusHtml = `<div class="squad-status text-orange-400">거리 초과 (${dist}/${stats.range})</div>`;
                else if (!cpEnough) statusHtml = `<div class="squad-status text-red-400">지휘력 부족 (필요 ${cpCost})</div>`;
                else statusHtml = `<div class="squad-status text-green-400">거리: ${dist} / ETA ${timeMin.toFixed(1)}분 / 지휘력 ${cpCost}</div>` +
                    (breakdown ? `<div class="squad-status text-[9px] text-gray-300">지형: ${breakdown}</div>` : "");
            }

            if (!infoOnly && (!isIdle || stats.power < 10 || !reachable || !path || !cpEnough)) card.classList.add('disabled');
            card.innerHTML = `<div class="font-bold text-white">${army.name}</div>${statusHtml}`;

            if (infoOnly) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    this.setSquadInfoPanel(army);
                    this.centerCameraOnArmy(army.id);
                    this.lastSelectedArmyId = army.id;
                };
                if (!defaultInfoSet) { this.setSquadInfoPanel(army); this.centerCameraOnArmy(army.id); defaultInfoSet = true; }
            } else if (!card.classList.contains('disabled')) {
                card.onclick = (e) => {
                    e.stopPropagation();
                    let energyCost = 1; let goldCost = 0;
                    if (isGateTile(tileType)) { energyCost = 5; goldCost = 100; }

                    this.selectedArmyId = army.id;
                    this.lastSelectedArmyId = army.id;
                    this.startMarch(army.id, targetR, targetC, tileType, energyCost, goldCost, cpCost, path, stats.speedFactor);
                    selector.remove();
                    if (targetCell) targetCell.classList.remove('field-target');
                    this.clearPathPreview();
                    this.renderFieldMap();
                };
            }
            selector.appendChild(card);
        });

        const closeBtn = document.createElement('div'); closeBtn.className = 'squad-card bg-red-900 border-red-700'; closeBtn.innerHTML = '<div class="font-bold text-red-200">취소</div>';
        closeBtn.onclick = (e) => { e.stopPropagation(); selector.remove(); if (targetCell) targetCell.classList.remove('field-target'); this.clearPathPreview(); this.setMovePreview(""); }; selector.appendChild(closeBtn);
        viewport.appendChild(selector);

        const TILE_SIZE = 13; const tx = 50 + (targetC * TILE_SIZE) + 6.5; const ty = 50 + (targetR * TILE_SIZE) + 6.5;
        this.moveCameraTo(tx, ty, viewport, document.getElementById('map-layer'));
        if (infoOnly) {
            this.setMovePreview("부대 정보를 선택하세요.");
        } else if (previewPath) {
            this.applyPathPreview(previewPath); this.setMovePreview(previewText);
        } else {
            this.setMovePreview("이동 불가 또는 지휘력 부족");
        }
    }

    isHostileTarget(type, r, c) {
        // Events
        if (type === FIELD_EVENT_TYPES.BANDIT || type === FIELD_EVENT_TYPES.BANDIT_LEADER || type === FIELD_EVENT_TYPES.DUNGEON) return true;
        // Capturable (Gates, Citadels, Dragon) if not occupied
        // Note: isCapturableFieldObject is likely available, but using raw checks to be safe
        const isCapturable = isGateTile(type) || isCitadelTile(type) || isDragonTile(type);
        if (isCapturable && !this.occupiedTiles.has(`${r},${c}`)) return true;
        return false;
    }

    startMarch(armyId, r, c, type, energyCost, goldCost, cpCost, path, speedFactor) {
        if (this.energy < energyCost) { this.showToast(`에너지 부족 (${energyCost})`); return; }
        if (this.gold < goldCost) { this.showToast(`골드 부족 (${goldCost})`); return; }
        if (this.cp < cpCost) { this.showToast(`지휘력 부족 (${cpCost})`); return; }

        this.energy -= energyCost; this.gold -= goldCost; this.cp -= cpCost; this.updateUI();
        this.clearPathPreview();
        this.setMovePreview("");

        const army = this.armies[armyId];
        army.state = 'MOVING_TO';

        // Attack Move Logic: If hostile, stop 1 tile short
        if (this.isHostileTarget(type, r, c) && path.length > 1) {
            // Keep the full path in a temp prop if needed, or just pop
            // army.target still holds the real destination
            path.pop();
        }

        army.path = path;
        army.stepTimes = this.buildStepTimes(path, speedFactor);
        army.nextStepIndex = 1; // Start from 1 (0 is current pos)
        army.moveInterval = Math.max(30, Math.floor(3 * MOVE_MS_PER_MIN));
        army.lastMoveTime = Date.now();
        army.target = { r, c, type };

        this.showToast(`${army.name} 행군 시작!`);
        this.sound.playSpawn();
    }

    updateArmies() {
        const now = Date.now();
        const TILE_SIZE = 13;

        this.armies.forEach(army => {
            const el = document.getElementById(`army-marker-${army.id}`);
            if (el) {
                const x = 50 + (army.c * TILE_SIZE);
                const y = 50 + (army.r * TILE_SIZE);
                el.style.transform = `translate(${x}px, ${y}px)`;
            }

            if (army.state === 'IDLE') return;

            if (army.state === 'MOVING_TO') {
                const stepTime = (army.stepTimes && army.stepTimes[army.nextStepIndex]) ? army.stepTimes[army.nextStepIndex] : army.moveInterval;
                if (now - army.lastMoveTime >= stepTime) {
                    army.lastMoveTime = now;
                    if (army.nextStepIndex < army.path.length) {
                        const nextPos = army.path[army.nextStepIndex];
                        army.r = nextPos.r;
                        army.c = nextPos.c;
                        army.nextStepIndex++;
                        this.revealFog(army.r, army.c, FOG_RADIUS);
                    } else {
                        this.handleArrival(army);
                    }
                }
            }
        });
    }

    handleArrival(army) {
        if (!army || !army.target) return;
        const { r, c, type } = army.target;

        // Check if we stopped at adjacent tile for attack
        // REMOVED: Auto-battle triggering. Instead, we let it fall through to open the Menu.

        // --- FIELD EVENT INTERACTION ---
        const eventKey = `${r},${c}`;
        const event = this.fieldEvents[eventKey];
        if (event) {
            army.state = 'IDLE';
            this.saveGame();

            if (event.type === FIELD_EVENT_TYPES.BANDIT || event.type === FIELD_EVENT_TYPES.BANDIT_LEADER || event.type === FIELD_EVENT_TYPES.DUNGEON) {
                // Open Menu instead of auto-battle
                setTimeout(() => {
                    const cell = document.getElementById(`field-cell-${r}-${c}`);
                    if (cell) {
                        const rect = cell.getBoundingClientRect();
                        this.setFieldInfo(event.type, r, c);
                        this.showFieldActionMenu(r, c, event.type, rect.left + rect.width / 2, rect.top + rect.height / 2);
                    }
                }, 100);
                return;
            } else if (event.type === FIELD_EVENT_TYPES.PORTAL) {
                this.openPortalModal(r, c);
                return;
            } else if (event.type === FIELD_EVENT_TYPES.CARAVAN) {
                this.openCaravanShop();
                return;
            }
            // Caravan opens menu via click usually, but if arrival triggers it?
            // Only auto-trigger for Hostile.
        }

        let mapChanged = false;
        if (isBorderTerrain(type)) {
            this.showToast("경계 타일은 점령 불가");
        } else if ((this.isCapturableFieldObject(type) && !this.occupiedTiles.has(`${r},${c}`)) || this.isHostileTarget(type, r, c)) {
            army.state = 'IDLE'; // Stop moving
            this.saveGame();

            // Open Floating Menu at cell position
            setTimeout(() => {
                const cell = document.getElementById(`field-cell-${r}-${c}`);
                if (cell) {
                    const rect = cell.getBoundingClientRect();
                    this.setFieldInfo(type, r, c);
                    this.showFieldActionMenu(r, c, type, rect.left + rect.width / 2, rect.top + rect.height / 2);
                }
            }, 100);
            return;
        } else if (this.isCapturableFieldObject(type)) {
            this.showToast(`${army.name} 도착 완료`);
        } else {
            this.showToast(`${army.name} 도착 완료`);
        }

        const collectibleInfo = this.getCollectibleFieldItemInfo(type);
        if (collectibleInfo && this.canCollectFieldObject(r, c)) {
            const item = this.createMergeItemFromInfo(collectibleInfo);
            if (this.spawnItem(item)) {
                this.clearFieldObjectFromMap(r, c);
                if (this.fieldObjectState) {
                    if (!this.fieldObjectState.regenByCode) this.fieldObjectState.regenByCode = {};
                    this.fieldObjectState.regenByCode[type] = Date.now();
                }
                mapChanged = true;
                this.sound.playCollect();
                this.showToast("획득 완료!");
            } else {
                this.showToast("머지 슬롯 공간 부족");
                this.setMovePreview("머지 슬롯이 가득 차서 획득 실패");
                setTimeout(() => {
                    if (!this.moveTargetMode) this.setMovePreview("");
                }, 1500);
            }
        }

        if (mapChanged) this.updateOpenBorders();
        if (mapChanged && document.getElementById('field-modal').classList.contains('open')) {
            if (!this.refreshFieldMapVisuals()) {
                this.renderFieldMap();
            } else if (this.currentFieldTargetKey === `${r},${c}`) {
                this.setFieldInfo(FIELD_MAP_DATA[r][c], r, c);
            }
        }
        army.state = 'IDLE';
        this.updateUI(); this.saveGame();
    }


    moveCameraTo(targetX, targetY, viewport, mapLayer) {
        const viewportWidth = viewport.clientWidth; const viewportHeight = viewport.clientHeight;
        const newX = (viewportWidth / 2) - (targetX * this.camera.scale); const newY = (viewportHeight / 2) - (targetY * this.camera.scale);
        mapLayer.style.transition = 'transform 0.3s ease-out';
        this.camera.x = newX; this.camera.y = newY;
        mapLayer.style.transform = `translate(${this.camera.x}px, ${this.camera.y}px) scale(${this.camera.scale})`;
        const labelScale = Math.max(0.5, Math.min(1.15, 1 / this.camera.scale));
        mapLayer.style.setProperty('--label-scale', labelScale.toFixed(3));
        this.updateFloatingPanelPositionFromSelection();
        setTimeout(() => { mapLayer.style.transition = 'none'; }, 300);
    }

    centerCameraOnArmy(armyId) {
        const army = this.armies[armyId];
        const viewport = document.getElementById('map-viewport');
        const mapLayer = document.getElementById('map-layer');
        if (!army || !viewport || !mapLayer || !this.camera) return;
        const TILE_SIZE = 13;
        const tx = 50 + (army.c * TILE_SIZE) + (TILE_SIZE / 2);
        const ty = 50 + (army.r * TILE_SIZE) + (TILE_SIZE / 2);
        this.moveCameraTo(tx, ty, viewport, mapLayer);
    }

    initFieldCamera(viewport, mapLayer) {
        const TILE_SIZE = 13; const VIEW_TILES = 9;
        const vw = viewport.clientWidth || 300; const vh = viewport.clientHeight || 300;
        let scale; if (this.camera && this.camera.scale) scale = this.camera.scale; else scale = vw / (TILE_SIZE * VIEW_TILES);
        let targetR, targetC; let shouldRecenter = false;
        if (!this.camera) {
            const army0 = this.armies && this.armies[0];
            targetR = army0 ? army0.r : PLAYER_START.r;
            targetC = army0 ? army0.c : PLAYER_START.c;
            shouldRecenter = true;
        }
        if (shouldRecenter) {
            const targetX = 50 + (targetC * TILE_SIZE) + (TILE_SIZE / 2); const targetY = 50 + (targetR * TILE_SIZE) + (TILE_SIZE / 2);
            const x = (vw / 2) - (targetX * scale); const y = (vh / 2) - (targetY * scale);
            this.camera = { x, y, scale };
        }
        const updateTransform = () => {
            mapLayer.style.transform = `translate(${this.camera.x}px, ${this.camera.y}px) scale(${this.camera.scale})`;
            const labelScale = Math.max(0.5, Math.min(1.15, 1 / this.camera.scale));
            mapLayer.style.setProperty('--label-scale', labelScale.toFixed(3));
            this.updateFloatingPanelPositionFromSelection();
        };
        setTimeout(updateTransform, 0);

        let isDragging = false, lastX = 0, lastY = 0, initialPinchDist = 0, initialPinchScale = 1;

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault(); const zoomSpeed = 0.1; const newScale = this.camera.scale + (e.deltaY > 0 ? -zoomSpeed : zoomSpeed) * this.camera.scale;
            if (newScale > 0.2 && newScale < 5) {
                const centerX = viewport.clientWidth / 2; const centerY = viewport.clientHeight / 2;
                const scaleRatio = newScale / this.camera.scale;
                this.camera.x = centerX - (centerX - this.camera.x) * scaleRatio; this.camera.y = centerY - (centerY - this.camera.y) * scaleRatio;
                this.camera.scale = newScale; updateTransform();
            }
        });
        viewport.addEventListener('mousedown', (e) => { isDragging = true; this.isDraggingMap = false; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            if (Math.abs(e.clientX - lastX) > 5 || Math.abs(e.clientY - lastY) > 5) this.isDraggingMap = true;
            this.camera.x += e.clientX - lastX; this.camera.y += e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; updateTransform();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { isDragging = true; this.isDraggingMap = false; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }
            else if (e.touches.length === 2) { isDragging = false; initialPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); initialPinchScale = this.camera.scale; }
        }, { passive: false });
        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                if (Math.abs(e.touches[0].clientX - lastX) > 5 || Math.abs(e.touches[0].clientY - lastY) > 5) this.isDraggingMap = true;
                this.camera.x += e.touches[0].clientX - lastX; this.camera.y += e.touches[0].clientY - lastY; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; updateTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const newScale = initialPinchScale * (dist / initialPinchDist);
                if (newScale > 0.2 && newScale < 5) {
                    const centerX = viewport.clientWidth / 2; const centerY = viewport.clientHeight / 2;
                    const scaleRatio = newScale / this.camera.scale;
                    this.camera.x = centerX - (centerX - this.camera.x) * scaleRatio; this.camera.y = centerY - (centerY - this.camera.y) * scaleRatio;
                    this.camera.scale = newScale; updateTransform();
                }
            }
        }, { passive: false });
        viewport.addEventListener('touchend', () => { isDragging = false; });
    }

    closeModal() {
        this.exitMoveTargetMode();
        document.getElementById('field-modal').classList.remove('open');
        document.getElementById('modal-refill').classList.remove('open');
        document.getElementById('modal-settings').classList.remove('open');
        document.getElementById('modal-object').classList.remove('open');
        if (this.shopTimer) { clearInterval(this.shopTimer); this.shopTimer = null; }
        this.currentShopContext = null;
        document.querySelector('#modal-object .modal-content')?.classList.remove('wide');
        this.clearPathPreview();
        this.setMovePreview("");
    }
    buyBuilding(type, price) {
        if (this.gold < price) { this.showToast("골드 부족!"); return; }
        const limit = BUILDING_LIMITS[type] || 999; const current = this.getBuildingCount(type);
        if (current >= limit) { this.showToast(`최대 개수 도달! (${limit})`); return; }
        for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
            if (this.gridState[r][c].type === LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.gold -= price; const newItem = { type: type, level: 1, scale: 0 };
                if (type === ITEM_TYPE.BUILDING_CHEST) newItem.usage = 5; if (type === ITEM_TYPE.BUILDING_CAMP) newItem.storedUnits = [];
                this.grid[r][c] = newItem; this.updateUI(); this.requestRender(); this.showToast("건설 완료!"); this.closeModal();
                const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize / 2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize / 2;
                this.spawnParticles(cx, cy, "#FFD700", 20, "confetti"); this.sound.playSpawn(); return;
            }
        }
        this.showToast("공간 부족!");
    }
    getBuildingCount(type) { let count = 0; for (let r = 0; r < CONFIG.gridRows; r++) for (let c = 0; c < CONFIG.gridCols; c++) { if (this.grid[r][c] && this.grid[r][c].type === type) count++; } return count; }
    getHighestBuildingLevel(unitType) {
        let bType = -1; if (unitType === ITEM_TYPE.UNIT_INFANTRY) bType = ITEM_TYPE.BUILDING_BARRACKS; else if (unitType === ITEM_TYPE.UNIT_ARCHER) bType = ITEM_TYPE.BUILDING_RANGE; else if (unitType === ITEM_TYPE.UNIT_CAVALRY) bType = ITEM_TYPE.BUILDING_STABLE;
        if (bType === -1) return 10; let maxLvl = 0; for (let r = 0; r < CONFIG.gridRows; r++) for (let c = 0; c < CONFIG.gridCols; c++) if (this.grid[r][c] && this.grid[r][c].type === bType) maxLvl = Math.max(maxLvl, this.grid[r][c].level); return maxLvl;
    }
    resize() {
        const wrap = document.getElementById('canvas-wrapper'); this.canvas.width = Math.floor(wrap.clientWidth * this.dpr); this.canvas.height = Math.floor(wrap.clientHeight * this.dpr);
        this.canvas.style.width = `${wrap.clientWidth}px`; this.canvas.style.height = `${wrap.clientHeight}px`; this.ctx.resetTransform(); this.ctx.scale(this.canvas.width / this.width, this.canvas.width / this.width); this.ctx.imageSmoothingEnabled = false; this.requestRender();
    }
    addXp(amount) { this.currentXp += amount; if (this.currentXp >= this.requiredXp) this.levelUp(); this.updateUI(); }
    levelUp() {
        if (this.lordLevel >= 15) return;
        const nextReq = this.requiredXp;
        if (this.currentXp >= nextReq) {
            const prevLv = this.lordLevel;
            const prevEn = this.maxEnergy;
            this.currentXp -= nextReq; this.lordLevel++; this.updateLevelStats(); this.energy = this.maxEnergy; this.refreshLockState();
            this.cp = this.maxCp;
            this.showLevelUpModal(prevLv, prevEn);
            this.sound.playLevelUp();
            if (this.currentXp >= this.requiredXp) this.levelUp();
        }
    }
    updateLevelStats() {
        const d = LEVEL_DATA.find(d => d.level === this.lordLevel);
        const nextD = LEVEL_DATA.find(d => d.level === this.lordLevel + 1);
        this.maxEnergy = d ? d.energy_max : 50; // Fixed key
        this.requiredXp = nextD ? (nextD.xp - d.xp) : 999999;
        this.baseMaxCp = d ? d.cp_max : 20;
        this.baseCpRegen = 1;
        this.applyCpBonuses();
    }
    selectItem(item, location) { if (this.selectedItem?.item !== item) this.sound.playClick(); this.selectedItem = item ? { item, location } : null; this.updateInfoPanel(); this.requestRender(); }
    updateInfoPanel() {
        const els = { name: document.getElementById('info-name'), desc: document.getElementById('info-desc'), cls: document.getElementById('info-class'), stats: document.getElementById('unit-stats-grid'), btn: document.getElementById('btn-action'), lbl: document.getElementById('action-label'), icon: document.getElementById('action-icon'), panel: document.getElementById('info-panel') };

        if (!this.selectedItem) {
            // Hide panel if nothing selected (or show default message?)
            // Design choice: Show panel with default "Select Object" text
            if (els.panel) els.panel.style.display = 'flex';
            els.stats.classList.add('hidden'); els.cls.innerText = ""; els.btn.style.opacity = 0.5; els.lbl.innerText = "-";
            els.name.innerText = "선택된 없음"; els.desc.innerText = "유닛이나 건물을 선택하세요.";
            return;
        }

        if (els.panel) els.panel.style.display = 'flex';
        els.stats.classList.add('hidden'); els.cls.innerText = ""; els.btn.style.opacity = 0.5; els.lbl.innerText = "-";

        const item = this.selectedItem.item; const data = getData(item.type, item.level); els.name.innerText = `${data.name} LV.${item.level}`;
        if (item.type < 10) {
            if (item.type === ITEM_TYPE.BUILDING_CHEST) els.desc.innerText = `남은 횟수: ${item.usage}회`;
            else if (item.type === ITEM_TYPE.BUILDING_CAMP) els.desc.innerText = `보관: ${item.storedUnits ? item.storedUnits.length : 0} / ${CAMP_CAPACITY[item.level]}`; // Modified here
            else { els.desc.innerText = "유닛 생산"; const cost = data.energy || 1; els.lbl.innerText = `-${cost}⚡`; els.btn.style.opacity = 1; els.icon.innerText = ""; }
        } else if (item.type >= 20) { els.desc.innerText = "클릭하여 획득"; els.lbl.innerText = "획득"; els.btn.style.opacity = 1; }
        else {
            els.cls.innerText = data.class; els.desc.innerText = ""; els.stats.classList.remove('hidden');
            document.getElementById('st-hp').innerText = data.hp; document.getElementById('st-atk').innerText = data.atk; document.getElementById('st-def').innerText = data.def;
            document.getElementById('st-spd').innerText = data.spd;
            document.getElementById('st-rng').innerText = data.range || data.rng || 0;
            document.getElementById('st-mov').innerText = data.move || data.mov || 0;
            els.lbl.innerText = `+${data.sell}`; els.icon.innerText = "💰"; els.btn.style.opacity = 1;
        }
    }

    // ... (rest of file)

    async confirmBattleStart() {
        try {
            console.log("Confirming Battle Start...");

            // Safety Check: If no context, check if we can recover or just close
            if (!this.battleContext) {
                console.error("No Battle Context found during confirm!");
                // Try to recover? No, just close to avoid stuck state
                alert("전투 데이터를 불러올 수 없습니다. 다시 시도해주세요.");
                this.closeBattlePrepModal();
                return;
            }

            // Close Prep, Open Battle
            const prep = document.getElementById('modal-battle-prep');
            if (prep) {
                prep.classList.remove('open');
                prep.style.display = 'none';
            }

            const modal = document.getElementById('modal-battle');
            if (modal) {
                modal.style.display = '';
                modal.classList.add('open');
            }

            // Need to regenerate 'allies' list from the updated squadRef
            this.battleContext.allies = this.getSquadUnits(this.battleContext.squadRef);

            // Start Sim
            this.startBattleSimulation();
        } catch (e) {
            console.error("Battle Start Error:", e);
            alert("전투 시작 중 오류 발생: " + e.message);
            this.closeAllModals();
        }
    }
    handleAction() {
        if (!this.selectedItem) return; const { item, location } = this.selectedItem;
        if (item.type >= 10 && item.type < 20) {
            if (location.zone === ZONES.GRID) this.grid[location.r][location.c] = null; else if (location.zone === ZONES.SQUAD1) this.squad1[location.idx] = null; else if (location.zone === ZONES.SQUAD2) this.squad2[location.idx] = null; else this.squad3[location.idx] = null;
            const val = getData(item.type, item.level).sell; this.gold += val; this.showToast(`+${val} G`); this.sound.playCollect(); this.selectItem(null); this.updateUI(); this.requestRender();
        } else if (item.type < 10 && item.type !== ITEM_TYPE.BUILDING_CHEST && item.type !== ITEM_TYPE.BUILDING_CAMP) this.produce(item);
    }
    setupInput() {
        const getPos = e => { const r = this.canvas.getBoundingClientRect(); return { x: ((e.touches ? e.touches[0].clientX : e.clientX) - r.left) * (this.width / r.width), y: ((e.touches ? e.touches[0].clientY : e.clientY) - r.top) * (this.width / r.width) }; };
        const start = e => {
            this.sound.resume(); const p = getPos(e); const hit = this.getZoneAt(p.x, p.y);
            if (hit) {
                if (hit.zone === ZONES.GRID && this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { this.tryUnlock(hit.r, hit.c); return; }
                let item = hit.zone === ZONES.GRID ? this.grid[hit.r][hit.c] : (hit.zone === ZONES.SQUAD1 ? this.squad1[hit.idx] : (hit.zone === ZONES.SQUAD2 ? this.squad2[hit.idx] : this.squad3[hit.idx]));
                this.potentialDrag = { startPos: p, item, hit };
            } else this.selectItem(null);
        };
        const move = e => {
            if (this.potentialDrag && !this.drag) { const p = getPos(e); if (Math.hypot(p.x - this.potentialDrag.startPos.x, p.y - this.potentialDrag.startPos.y) > 10 && this.potentialDrag.item) this.startDrag(this.potentialDrag.item, this.potentialDrag.hit, p); }
            if (this.drag) { this.drag.x = getPos(e).x; this.drag.y = getPos(e).y; this.hover = this.getZoneAt(this.drag.x, this.drag.y); this.requestRender(); }
        };
        const end = e => { if (this.drag) this.endDrag(); else if (this.potentialDrag) this.handleClick(this.potentialDrag.item, this.potentialDrag.hit); this.potentialDrag = null; this.drag = null; };
        this.canvas.onmousedown = start; window.onmousemove = move; window.onmouseup = end;
        this.canvas.ontouchstart = e => { start(e); e.preventDefault(); }; window.ontouchmove = e => { move(e); e.preventDefault(); }; window.ontouchend = end;
    }
    startDrag(item, hit, pos) {
        let cx, cy; if (hit.zone === ZONES.GRID) { cx = this.gridStartX + hit.c * this.gridTileSize; cy = this.gridStartY + hit.r * this.gridTileSize; } else if (hit.zone === ZONES.SQUAD1) { cx = this.squad1Rect.x + (hit.idx % 3) * this.squadCellSize; cy = this.squad1Rect.y + Math.floor(hit.idx / 3) * this.squadCellSize; } else if (hit.zone === ZONES.SQUAD2) { cx = this.squad2Rect.x + (hit.idx % 3) * this.squadCellSize; cy = this.squad2Rect.y + Math.floor(hit.idx / 3) * this.squadCellSize; } else { cx = this.squad3Rect.x + (hit.idx % 3) * this.squadCellSize; cy = this.squad3Rect.y + Math.floor(hit.idx / 3) * this.squadCellSize; }
        this.drag = { item, startZone: hit, x: pos.x, y: pos.y, offsetX: pos.x - cx, offsetY: pos.y - cy, size: hit.zone === ZONES.GRID ? this.gridTileSize : this.squadCellSize };
        if (hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = null; else if (hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = null; else if (hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = null; else this.squad3[hit.idx] = null;
        this.selectItem(item, hit); this.requestRender();
    }
    endDrag() {
        const hit = this.getZoneAt(this.drag.x, this.drag.y); let returned = false;
        if (hit) {
            let target = null; if (hit.zone === ZONES.GRID) { if (this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) returned = true; else target = this.grid[hit.r][hit.c]; } else if (hit.zone === ZONES.SQUAD1) target = this.squad1[hit.idx]; else if (hit.zone === ZONES.SQUAD2) target = this.squad2[hit.idx]; else target = this.squad3[hit.idx];
            if (!returned) {
                if (!target) { if (hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = this.drag.item; else if (hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = this.drag.item; else if (hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = this.drag.item; else this.squad3[hit.idx] = this.drag.item; this.selectItem(this.drag.item, hit); }
                else if (target.type === ITEM_TYPE.BUILDING_CAMP && this.drag.item.type >= 10 && this.drag.item.type < 20 && hit.zone === ZONES.GRID) {
                    if (!target.storedUnits) target.storedUnits = [];
                    const cap = CAMP_CAPACITY[target.level] || 4;
                    if (target.storedUnits.length < cap) {
                        target.storedUnits.push(this.drag.item);
                        this.showToast(`보관됨 (${target.storedUnits.length}/${cap})`);
                        this.sound.playClick();
                    } else {
                        this.showToast("보관함이 가득 찼습니다.");
                        returned = true;
                    }
                }
                else if (target.type === this.drag.item.type && target.level === this.drag.item.level) {
                    const isUnit = target.type >= 10 && target.type < 20; const maxLvl = isUnit ? 10 : 5; let canMerge = true;

                    if (isUnit) {
                        const bLvl = this.getHighestBuildingLevel(target.type);
                        if (target.level >= bLvl + 5) {
                            this.showToast(`합성 불가 (건물 Lv.${target.level - 4} 필요)`);
                            canMerge = false; returned = true;
                        }
                    }

                    if (canMerge && target.level < maxLvl) {
                        target.level++; target.scale = 1.3;
                        if (target.type === ITEM_TYPE.BUILDING_CHEST) {
                            target.usage = Math.floor((target.usage + this.drag.item.usage) * 0.5);
                        }
                        const xp = MERGE_XP_DATA[target.level - 1] || 1;
                        this.addXp(xp); this.showFloatingImage('xp', hit.zone === ZONES.GRID ? this.gridStartX + hit.c * this.gridTileSize : this.drag.x, this.drag.y);
                        this.spawnParticles(this.drag.x, this.drag.y, "#FFD700", 30, "spark"); this.sound.playMerge();
                    } else if (canMerge) { this.showToast("최대 레벨"); returned = true; }
                } else returned = true;
            }
        } else returned = true;
        if (returned) { const s = this.drag.startZone; if (s.zone === ZONES.GRID) this.grid[s.r][s.c] = this.drag.item; else if (s.zone === ZONES.SQUAD1) this.squad1[s.idx] = this.drag.item; else if (s.zone === ZONES.SQUAD2) this.squad2[s.idx] = this.drag.item; else this.squad3[s.idx] = this.drag.item; }
        this.hover = null; this.updateUI(); this.requestRender(); this.drag = null;
    }
    handleClick(item, hit) {
        if (!item) { this.selectItem(null); return; }
        this.selectItem(item, hit);
        if (item.type >= 20) this.collectResource(item, hit.r, hit.c);
        else if (item.type === ITEM_TYPE.BUILDING_CAMP) this.ejectCamp(item, hit.r, hit.c);
        else if (item.type < 10 && item.type !== ITEM_TYPE.BUILDING_CAMP) {
            if (item.type === ITEM_TYPE.BUILDING_CHEST) this.produceFromChest(item, hit.r, hit.c);
            else this.produce(item);
        }
    }
    getZoneAt(x, y) {
        const check = (rect, rows, cols, size) => { if (x >= rect.x && x < rect.x + rect.w && y >= rect.y && y < rect.y + rect.h) { const c = Math.floor((x - rect.x) / size), r = Math.floor((y - rect.y) / size); if (c >= 0 && c < cols && r >= 0 && r < rows) return { c, r, idx: r * 3 + c }; } return null; };
        let res = check(this.squad1Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if (res) return { zone: ZONES.SQUAD1, ...res };
        res = check(this.squad2Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if (res) return { zone: ZONES.SQUAD2, ...res };
        if (this.thirdSquadUnlocked && this.squad3Rect) { res = check(this.squad3Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize); if (res) return { zone: ZONES.SQUAD3, ...res }; }
        if (x >= this.gridStartX && x < this.gridStartX + this.gridTileSize * CONFIG.gridCols && y >= this.gridStartY && y < this.gridStartY + this.gridTileSize * CONFIG.gridRows) { const c = Math.floor((x - this.gridStartX) / this.gridTileSize), r = Math.floor((y - this.gridStartY) / this.gridTileSize); if (c >= 0 && c < CONFIG.gridCols && r >= 0 && r < CONFIG.gridRows) return { zone: ZONES.GRID, r, c, idx: r * 8 + c }; }
        return null;
    }
    produce(building) {
        const buildingData = BUILDING_DATA[building.type];
        const stats = buildingData ? buildingData[building.level] : BUILDING_DATA[ITEM_TYPE.BUILDING_BARRACKS][1]; // Default fallback

        if (this.energy < stats.energy) { this.showToast(`에너지 부족 (${stats.energy})`); return; }

        let unitType = ITEM_TYPE.UNIT_INFANTRY;
        if (building.type === ITEM_TYPE.BUILDING_RANGE) unitType = ITEM_TYPE.UNIT_ARCHER;
        else if (building.type === ITEM_TYPE.BUILDING_STABLE) unitType = ITEM_TYPE.UNIT_CAVALRY;

        let lvl = 1;
        const r = Math.random() * 100;
        let sum = 0;
        for (let i = 0; i < stats.probs.length; i++) {
            sum += stats.probs[i];
            if (r <= sum) { lvl = i + 1; break; }
        }

        if (this.spawnItem({ type: unitType, level: lvl, scale: 0 })) {
            this.energy -= stats.energy;
            this.updateUI();
            this.requestRender();
            this.sound.playSpawn();
        } else {
            this.showToast("공간 부족");
        }
    }
    produceFromChest(chest, r, c) {
        if (this.energy < 1) { this.showToast("에너지 부족"); return; }

        // Drop logic
        const table = CHEST_DROP_TABLE[chest.level] || CHEST_DROP_TABLE[1];
        let total = 0;
        table.forEach(e => total += e.prob);
        let rnd = Math.random() * total, code = table[0].code;
        for (let e of table) { if (rnd < e.prob) { code = e.code; break; } rnd -= e.prob; }
        const info = getInfoFromCode(code);

        if (this.spawnItem({ type: info.type, level: info.level, scale: 0 })) {
            this.energy--;
            chest.usage--;
            chest.scale = 1.2;

            // Check usage
            if (chest.usage <= 0) {
                this.grid[r][c] = null; // Remove from grid
                if (this.selectedItem && this.selectedItem.item === chest) {
                    this.selectItem(null); // Deselect
                }
                this.showToast("상자가 사라졌습니다.");
            }

            this.updateUI();
            this.requestRender();
            this.sound.playSpawn();
        } else {
            this.showToast("공간 부족");
        }
    }
    spawnItem(item) {
        for (let r = 0; r < CONFIG.gridRows; r++) for (let c = 0; c < CONFIG.gridCols; c++) if (this.gridState[r][c].type === LOCK_TYPE.OPEN && !this.grid[r][c]) { this.grid[r][c] = item; const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize / 2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize / 2; this.spawnParticles(cx, cy, "#EEE", 10, "smoke"); return true; }
        return false;
    }
    ejectCamp(camp, r, c) {
        if (!camp.storedUnits || camp.storedUnits.length === 0) { this.showToast("비어있음"); return; }
        const moves = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (let m of moves) {
            const nr = r + m[0], nc = c + m[1];
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && this.gridState[nr][nc].type === LOCK_TYPE.OPEN && !this.grid[nr][nc]) {
                const unit = camp.storedUnits.pop(); // Take last added unit (LIFO)
                this.grid[nr][nc] = unit;
                this.requestRender();
                this.sound.playClick();
                this.showToast(`꺼냄 (${camp.storedUnits.length} 남음)`);
                return;
            }
        }
        this.showToast("주변 공간 부족");
    }
    collectResource(item, r, c) {
        const val = ITEM_VALUES[item.level] || 1; let pColor = "#fff";
        if (item.type === ITEM_TYPE.ITEM_GOLD) { this.gold += val; this.showToast(`+${val}G`); pColor = "#FFD700"; } else if (item.type === ITEM_TYPE.ITEM_ENERGY) { this.energy = Math.min(this.energy + val, this.maxEnergy); this.showToast(`+${val}⚡`); pColor = "#00FFFF"; } else { this.gem += val; this.showToast(`+${val}💎`); pColor = "#FF00FF"; }
        const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize / 2, cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize / 2; this.spawnParticles(cx, cy, pColor, 15, "spark"); this.sound.playCollect(); this.grid[r][c] = null; this.updateUI(); this.requestRender();
    }
    tryUnlock(r, c) {
        const l = this.gridState[r][c];
        if (l.type === LOCK_TYPE.GOLD) { if (this.gold >= l.value) { this.gold -= l.value; this.gridState[r][c] = { type: LOCK_TYPE.OPEN }; this.showToast("해금!"); this.spawnParticles(this.gridStartX + c * this.gridTileSize + this.gridTileSize / 2, this.gridStartY + r * this.gridTileSize + this.gridTileSize / 2, "#FFF", 20, "confetti"); this.sound.playUnlock(); } else { this.showToast("골드 부족"); this.sound.playError(); } }
        else if (l.type === LOCK_TYPE.LEVEL) { if (this.lordLevel >= l.value) { this.gridState[r][c] = { type: LOCK_TYPE.OPEN }; this.showToast("해금!"); this.spawnParticles(this.gridStartX + c * this.gridTileSize + this.gridTileSize / 2, this.gridStartY + r * this.gridTileSize + this.gridTileSize / 2, "#FFF", 20, "confetti"); this.sound.playUnlock(); } else { this.showToast(`LV.${l.value} 필요`); this.sound.playError(); } }
        this.updateUI(); this.requestRender();
    }
    loop() {
        // 스쿼드 이동 업데이트 (매 프레임)
        this.updateArmies();

        if (this.isDirty || this.drag) {
            this.ctx.clearRect(0, 0, this.width, this.height);
            this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50", ZONES.SQUAD1); this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3", ZONES.SQUAD2);
            if (this.thirdSquadUnlocked && this.squad3Rect) this.drawSquad(this.squad3, this.squad3Rect, "SQUAD 3", "#f59e0b", ZONES.SQUAD3);
            for (let r = 0; r < CONFIG.gridRows; r++) for (let c = 0; c < CONFIG.gridCols; c++) {
                const x = this.gridStartX + c * this.gridTileSize, y = this.gridStartY + r * this.gridTileSize;
                const isHover = this.hover && this.hover.zone === ZONES.GRID && this.hover.r === r && this.hover.c === c, isSel = this.selectedItem && this.selectedItem.location.zone === ZONES.GRID && this.selectedItem.location.r === r && this.selectedItem.location.c === c;
                this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c], isHover, isSel);
            }
            if (this.drag) this.drawItem(this.drag.x - this.drag.size / 2, this.drag.y - this.drag.size / 2, this.drag.size, this.drag.item, true);
            for (let i = this.particles.length - 1; i >= 0; i--) { this.particles[i].update(); this.particles[i].draw(this.ctx); if (this.particles[i].life <= 0) this.particles.splice(i, 1); }
            let anim = false; this.grid.flat().concat(this.squad1).concat(this.squad2).concat(this.squad3).forEach(i => { if (i && i.scale !== 1) { i.scale += (i.scale < 1 ? 0.1 : -0.05); if (Math.abs(i.scale - 1) < 0.05) i.scale = 1; anim = true; } });
            this.isDirty = anim || !!this.drag || this.particles.length > 0;
        }
        requestAnimationFrame(() => this.loop());
    }
    getSquadPower(s) {
        let p = 0;
        for (let u of s) {
            if (!u || u.type < 10 || u.type >= 20) continue;
            const base = getData(u.type, u.level);
            const d = this.applyFieldBuffsToStats(base);
            if (d && d.hp) p += (d.hp + d.atk + d.def);
        }
        return p;
    }
    drawSquad(data, rect, label, color, zone) {
        const cp = this.getSquadPower(data);
        this.ctx.fillStyle = color; this.ctx.font = "bold 40px sans-serif"; this.ctx.textAlign = "center"; this.ctx.fillText(`${label}`, rect.x + rect.w / 2, rect.y - 22);
        this.ctx.fillStyle = color + "11"; this.ctx.fillRect(rect.x - 5, rect.y - 5, rect.w + 10, rect.h + 10);
        this.ctx.font = "bold 40px sans-serif"; this.ctx.fillStyle = "#fff"; this.ctx.fillText(`⚔️ ${cp}`, rect.x + rect.w / 2, rect.y + rect.h + 39);
        for (let i = 0; i < 9; i++) {
            const x = rect.x + (i % 3) * this.squadCellSize, y = rect.y + Math.floor(i / 3) * this.squadCellSize;
            const isHover = this.hover && this.hover.zone === zone && this.hover.idx === i, isSel = this.selectedItem && this.selectedItem.location.zone === zone && this.selectedItem.location.idx === i;
            this.drawCell(x, y, this.squadCellSize, data[i], { type: LOCK_TYPE.OPEN }, isHover, isSel);
        }
    }
    drawCell(x, y, s, item, lock, isHover, isSel) {
        const p = 2, size = s - p * 2;
        this.ctx.fillStyle = lock.type === LOCK_TYPE.OPEN ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.5)"; this.ctx.fillRect(x + p, y + p, size, size);
        if (isSel) { this.ctx.lineWidth = 6; this.ctx.strokeStyle = "#0f0"; this.ctx.strokeRect(x + p, y + p, size, size); }
        else if (isHover) { this.ctx.lineWidth = 4; this.ctx.strokeStyle = "#ff0"; this.ctx.strokeRect(x + p, y + p, size, size); }
        else { this.ctx.lineWidth = 2; this.ctx.strokeStyle = "rgba(0,0,0,0.3)"; this.ctx.strokeRect(x + p, y + p, size, size); }
        if (lock.type !== LOCK_TYPE.OPEN) {
            const img = this.assets.getImage(lock.type === LOCK_TYPE.GOLD ? '1804' : 'lock');
            if (img && img.complete && img.naturalWidth > 0) { const isz = size * 0.6; this.ctx.drawImage(img, x + (s - isz) / 2, y + (s - isz) / 2, isz, isz); this.ctx.fillStyle = lock.type === LOCK_TYPE.GOLD ? "#ffd700" : "#fff"; this.ctx.font = "bold 20px sans-serif"; this.ctx.textAlign = "center"; this.ctx.strokeStyle = "black"; this.ctx.lineWidth = 4; const txt = lock.type === LOCK_TYPE.GOLD ? `💰${lock.value}` : `LV.${lock.value}`; this.ctx.strokeText(txt, x + s / 2, y + s / 2); this.ctx.fillText(txt, x + s / 2, y + s / 2); }
        } else if (item && item !== this.drag?.item) this.drawItem(x, y, s, item);
    }
    drawItem(x, y, s, item, isDrag = false) {
        const sc = isDrag ? 1.1 : item.scale, p = 4, ds = (s - p * 2) * sc, offset = (s - ds) / 2; const img = this.assets.getImage(item.type, item.level);

        // --- ADDED: LEVEL COLOR BORDER ---
        const lvColor = LEVEL_COLORS[item.level] || "#fff";

        if (img && img.complete && img.naturalWidth > 0) {
            if (isDrag) { this.ctx.shadowColor = "black"; this.ctx.shadowBlur = 15; }
            const drawSize = ds * 1.2; const drawOffset = (s - drawSize) / 2;
            this.ctx.drawImage(img, x + drawOffset, y + drawOffset, drawSize, drawSize); this.ctx.shadowBlur = 0;
        } else {
            let c = "#cfd8dc"; let sym = "❓";
            if (item.type === ITEM_TYPE.BUILDING_BARRACKS) { c = "#795548"; sym = "🏠"; } else if (item.type === ITEM_TYPE.BUILDING_RANGE) { c = "#388e3c"; sym = "🎯"; } else if (item.type === ITEM_TYPE.BUILDING_STABLE) { c = "#1976d2"; sym = "🐴"; } else if (item.type === ITEM_TYPE.BUILDING_CHEST) { c = "#ffa000"; sym = "🎁"; } else if (item.type === ITEM_TYPE.BUILDING_CAMP) { c = "#5d4037"; sym = "⛺"; } else if (item.type === ITEM_TYPE.UNIT_INFANTRY) { c = "#eeeeee"; sym = "🛡️"; } else if (item.type === ITEM_TYPE.UNIT_ARCHER) { c = "#c8e6c9"; sym = "🏹"; } else if (item.type === ITEM_TYPE.UNIT_CAVALRY) { c = "#bbdefb"; sym = "🐎"; } else if (item.type === ITEM_TYPE.ITEM_GOLD) { c = "#fff176"; sym = "💰"; } else if (item.type === ITEM_TYPE.ITEM_ENERGY) { c = "#80deea"; sym = "⚡"; } else if (item.type === ITEM_TYPE.ITEM_CRYSTAL) { c = "#e1bee7"; sym = "💎"; }
            const drawSize = ds * 1.2; const drawOffset = (s - drawSize) / 2;
            this.ctx.fillStyle = c; this.roundRect(x + drawOffset, y + drawOffset, drawSize, drawSize, 12); this.ctx.fill(); this.ctx.strokeStyle = "rgba(0,0,0,0.4)"; this.ctx.lineWidth = 2; this.ctx.stroke(); this.ctx.fillStyle = "rgba(0,0,0,0.6)"; this.ctx.font = `${Math.floor(drawSize * 0.5)}px sans-serif`; this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle"; this.ctx.fillText(sym, x + s / 2, y + s / 2);
        }

        this.ctx.lineWidth = 3;
        this.ctx.strokeStyle = lvColor;
        this.ctx.strokeRect(x + p, y + p, ds, ds);

        const bx = x + s / 2, by = y + ds;
        if (item.type >= 10 || item.type < 10) {
            this.ctx.fillStyle = "rgba(0,0,0,0.8)"; this.ctx.beginPath(); this.ctx.arc(bx, by - 10, 10, 0, Math.PI * 2); this.ctx.fill(); this.ctx.strokeStyle = "#fff"; this.ctx.lineWidth = 1; this.ctx.stroke(); this.ctx.fillStyle = "#fff"; this.ctx.font = "bold 12px sans-serif"; this.ctx.textAlign = "center"; this.ctx.fillText(item.level, bx, by - 6);
        }

        // --- MODIFIED: Camp Storage Display ---
        if (item.type === ITEM_TYPE.BUILDING_CAMP) {
            const count = item.storedUnits ? item.storedUnits.length : 0;
            const cap = CAMP_CAPACITY[item.level] || 4;

            // Styled Text Box
            const text = `${count}/${cap}`;
            this.ctx.font = "bold 16px sans-serif";
            const textW = this.ctx.measureText(text).width + 8;

            this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; // Semi-transparent black bg
            this.ctx.beginPath();
            this.ctx.roundRect(bx - textW / 2, y + s / 2 - 10, textW, 20, 4);
            this.ctx.fill();

            this.ctx.fillStyle = "#fff"; // White text
            this.ctx.shadowColor = "black";
            this.ctx.shadowBlur = 2;
            this.ctx.fillText(text, bx, y + s / 2 + 6);
            this.ctx.shadowBlur = 0; // Reset shadow
        }
    }
    roundRect(x, y, w, h, r) { this.ctx.beginPath(); this.ctx.moveTo(x + r, y); this.ctx.arcTo(x + w, y, x + w, y + h, r); this.ctx.arcTo(x + w, y + h, x, y + h, r); this.ctx.arcTo(x, y + h, x, y, r); this.ctx.arcTo(x, y, x + w, y, r); this.ctx.closePath(); }
    showToast(msg) { if (msg.includes("부족") || msg.includes("불가")) this.sound.playError(); const t = document.getElementById('toast'); t.innerText = msg; t.style.opacity = 1; setTimeout(() => t.style.opacity = 0, 1000); }
    showFloatingImage(key, x, y) {
        const img = this.assets.getImage(key); if (!img) return; const el = document.createElement('img'); el.src = img.src; el.className = 'float-img';
        const r = this.canvas.getBoundingClientRect(); el.style.left = ((x / this.width) * r.width) + "px"; el.style.top = ((y / this.height) * r.height) + "px"; document.getElementById('canvas-wrapper').appendChild(el); setTimeout(() => el.remove(), 1000);
    }
    showFloatingText(text, x, y, color) {
        const el = document.createElement('div');
        el.innerText = text; el.id = 'income-float'; el.style.color = color;
        // Simple positioning relative to container
        el.style.left = '50%'; el.style.top = '20%'; el.style.transform = 'translate(-50%, 0)';
        document.getElementById('canvas-wrapper').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    showJoinNotice(text) {
        const el = document.createElement('div');
        el.className = 'join-float';
        el.innerText = text;
        document.getElementById('game-container').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }
    updateUI() {
        document.getElementById('energy-display').innerText = `${this.energy}/${this.maxEnergy}`;
        document.getElementById('cp-display').innerText = `${this.cp}/${this.maxCp}`;
        document.getElementById('gold-display').innerText = this.gold; document.getElementById('gem-display').innerText = this.gem; document.getElementById('level-display').innerText = `LORD LV.${this.lordLevel}`; document.getElementById('xp-text').innerText = `${this.currentXp} / ${this.requiredXp}`; document.getElementById('xp-bar').style.width = `${(this.currentXp / this.requiredXp) * 100}%`;
        const fieldCp = document.getElementById('field-cp-display'); if (fieldCp) fieldCp.innerText = `${this.cp}/${this.maxCp}`;
        this.saveGame();
    }
    // --- BATTLE SYSTEM ---


    // --- BATTLE PREP & SIMULATION ---

    openBattlePrepModal(targetType, r, c) {
        // ... (data fetching)
        const meta = this.getTileMoveMeta(targetType, r, c);
        const objData = this.getFieldObjectData(targetType);
        if (!objData || !objData.defenders || objData.defenders.length === 0) {
            this.handleBattleWin(r, c);
            return;
        }

        // ... (context setup)
        this.battleContext = {
            targetCode: targetType,
            r: r, c: c,
            defenders: this.parseDefenders(objData.defenders, objData.level),
            squadRef: this.lastSelectedArmyId !== null ? this.getSquadByArmyId(this.armies[this.lastSelectedArmyId].id) : this.squad1,
            allies: [],
            log: [],
            active: false
        };

        const modal = document.getElementById('modal-battle-prep');
        if (modal) {
            modal.style.display = ''; // Reset inline display: none
            modal.classList.add('open');
        }

        this.renderPrepGrid();
    }

    renderPrepGrid() {
        if (!this.battleContext) return;
        const ctx = this.battleContext;

        // Ally Grid (Draggable)
        const allyGrid = document.getElementById('prep-grid-ally');
        if (allyGrid) {
            allyGrid.innerHTML = '';
            // Render 9 slots
            const squad = ctx.squadRef; // Array(9)
            squad.forEach((unit, idx) => {
                const cell = document.createElement('div');
                cell.className = 'battle-cell ally prep';
                cell.dataset.idx = idx;

                // Drag Events
                cell.ondragover = (e) => e.preventDefault();
                cell.ondrop = (e) => this.handlePrepDrop(e, idx);

                if (unit) {
                    const data = getData(unit.type, unit.level);
                    cell.draggable = true;
                    cell.ondragstart = (e) => this.handlePrepDragStart(e, idx);
                    cell.innerHTML = `
                        <div class="battle-unit">
                            <div style="font-size:24px;">${this.getUnitIcon(unit.type)}</div>
                            <div class="text-[10px] text-white">${data.name}</div>
                        </div>
                    `;
                } else {
                    cell.classList.add('empty');
                }
                allyGrid.appendChild(cell);
            });
        }

        // Enemy Grid (Static)
        const enemyGrid = document.getElementById('prep-grid-enemy');
        if (enemyGrid) {
            enemyGrid.innerHTML = '';
            // Defenders are List of {slot, ...}. Create 9-slot array wrapper for rendering
            const enemySlots = Array(9).fill(null);
            ctx.defenders.forEach(u => {
                if (u.slot >= 0 && u.slot < 9) enemySlots[u.slot] = u;
            });

            enemySlots.forEach((unit, idx) => {
                const cell = document.createElement('div');
                cell.className = 'battle-cell enemy prep';
                if (unit) {
                    cell.innerHTML = `
                        <div class="battle-unit">
                            <div style="font-size:24px;">${this.getUnitIcon(unit.classType)}</div>
                            <div class="text-[10px] text-red-300">${unit.name}</div>
                        </div>
                    `;
                }
                enemyGrid.appendChild(cell);
            });
        }
    }

    handlePrepDragStart(e, idx) {
        e.dataTransfer.setData('text/plain', idx);
        e.dataTransfer.effectAllowed = 'move';
    }

    handlePrepDrop(e, targetIdx) {
        e.preventDefault();
        const sourceIdx = parseInt(e.dataTransfer.getData('text/plain'));
        if (isNaN(sourceIdx) || sourceIdx === targetIdx) return;

        // Swap in squadRef
        const squad = this.battleContext.squadRef;
        const temp = squad[sourceIdx];
        squad[sourceIdx] = squad[targetIdx];
        squad[targetIdx] = temp;

        this.renderPrepGrid();
        this.saveGame(); // Save formation changes immediately
    }

    async confirmBattleStart() {
        try {
            console.log("Confirming Battle Start...");

            // Safety Check: If no context, check if we can recover or just close
            if (!this.battleContext) {
                console.error("No Battle Context found during confirm!");
                // Try to recover? No, just close to avoid stuck state
                alert("전투 데이터를 불러올 수 없습니다. 다시 시도해주세요.");
                this.closeBattlePrepModal();
                return;
            }

            // Close Prep, Open Battle
            const prep = document.getElementById('modal-battle-prep');
            if (prep) {
                prep.classList.remove('open');
                prep.style.display = 'none';
            }

            const modal = document.getElementById('modal-battle');
            if (modal) {
                modal.style.display = '';
                modal.classList.add('open');
            }

            // Need to regenerate 'allies' list from the updated squadRef
            this.battleContext.allies = this.getSquadUnits(this.battleContext.squadRef);

            // Start Sim
            this.startBattleSimulation();
        } catch (e) {
            console.error("Battle Start Error:", e);
            alert("전투 시작 중 오류 발생: " + e.message);
            this.closeAllModals();
        }
    }

    startBattleSimulation() {
        if (!this.battleContext) return;
        this.battleContext.active = true;

        if (typeof BattleSimulator === 'undefined') {
            console.error("BattleSimulator module not loaded.");
            this.addBattleLog("Error: Battle Simulator missing.");
            return;
        }

        const controls = document.getElementById('battle-controls');
        if (controls) controls.style.display = 'none';

        const sim = new BattleSimulator();
        const result = sim.simulate(this.battleContext.allies, this.battleContext.defenders);

        this.battleSimulation = result;
        this.battleStepIndex = 0;
        this.battleContext.log = [];

        this.battleTimer = setInterval(() => this.battleTick(), 800);
    }

    closeBattleModal() {
        console.log("Closing Battle Modal (Inline)");
        const els = document.querySelectorAll('.modal-overlay');
        els.forEach(el => {
            el.classList.remove('open');
            el.style.display = 'none';
        });
        if (this.battleTimer) clearInterval(this.battleTimer);
        this.battleContext = null;
    }

    closeBattlePrepModal() {
        console.log("Closing Battle Prep Modal (Inline)");
        try {
            // Clear Army Targets to prevent loop
            this.armies.forEach(army => {
                if (army.state === 'IDLE' || army.state === 'MOVING_TO') {
                    army.target = null;
                    army.path = [];
                }
            });

            const els = document.querySelectorAll('.modal-overlay');
            els.forEach(el => {
                el.classList.remove('open');
                el.style.display = 'none';
            });
            this.battleContext = null;
            this.saveGame();
        } catch (e) {
            console.error("Critical Error closing prep:", e);
            // Absolute Emergency Fallback
            document.getElementById('modal-battle-prep').style.display = 'none';
            document.getElementById('modal-battle').style.display = 'none';
        }
    }

    parseDefenders(defenders, level) {
        const result = [];
        // Fixed slot assignment if provided, otherwise sequential filling?
        // Logic: if defender has 'slot', use it. Else fill 0..
        // But the input 'defenders' from FIELD_OBJECT_DATA is usually [{code, count, slot}, ...]
        // The slot in JSON is just 'slot': 0, 1, 2... 
        // We should map them.

        const slotsUsed = new Set();

        defenders.forEach(d => {
            for (let i = 0; i < d.count; i++) {
                let currentSlot = (d.slot !== undefined) ? (d.slot + i) : 0;
                // If collision, find next empty?
                while (slotsUsed.has(currentSlot) && currentSlot < 9) currentSlot++;
                if (currentSlot >= 9) break;

                slotsUsed.add(currentSlot);

                const code = 1100 + (Math.floor(d.code / 100) % 10) * 100 + level;
                const stats = UNIT_STATS[d.code] || UNIT_STATS[code] || { name: "Enemy", hp: 20, atk: 5, def: 2, spd: 5 };
                result.push({
                    id: `enemy-${currentSlot}`,
                    name: stats.name,
                    hp: stats.hp,
                    maxHp: stats.hp,
                    atk: stats.atk,
                    def: stats.def,
                    classType: d.code >= 1000 ? Math.floor(d.code / 100) : ITEM_TYPE.UNIT_INFANTRY,
                    slot: currentSlot,
                    isEnemy: true
                });
            }
        });
        return result;
    }

    // Note: unit keys might be strings in UNIT_STATS, so we handle that if needed, 
    // but usually they are accessed by code.
    // If UNIT_STATS is { '10': {...}, ... }
    getSquadUnits(squad) {
        const units = [];

        // Local helper for safe data retrieval including Dragon
        const getUnitDataSafe = (type, level) => {
            if (type === ITEM_TYPE.UNIT_DRAGON) {
                return { name: "Ancient Dragon", power: 9999, hp: 5000, atk: 300, def: 50, spd: 50, rng: 3, mov: 0 };
            }
            if (BUILDING_DATA[type] && BUILDING_DATA[type][level]) return BUILDING_DATA[type][level];

            // Fallback to UNIT_STATS (was incorrectly UNIT_DATA)
            if (UNIT_STATS[type]) return UNIT_STATS[type];

            return { name: "Unknown Unit", hp: 10, atk: 1, def: 1, spd: 1 };
        };

        squad.forEach((u, i) => {
            if (u && u.type >= 10 && (u.type < 20 || u.type === ITEM_TYPE.UNIT_DRAGON)) {
                const data = getUnitDataSafe(u.type, u.level);
                const stats = this.applyFieldBuffsToStats(data);
                units.push({
                    id: `ally-${i}`,
                    name: data.name,
                    hp: stats.hp,
                    maxHp: stats.hp,
                    atk: stats.atk,
                    def: stats.def,
                    spd: stats.spd || 5, // Ensure SPD exists
                    classType: u.type,
                    slot: i,
                    isEnemy: false
                });
            }
        });
        return units;
    }

    getSquadByArmyId(id) {
        if (id === 0) return this.squad1;
        if (id === 1) return this.squad2;
        return this.squad3;
    }

    renderBattleModal() {
        if (!this.battleContext) return;
        const ctx = this.battleContext;

        const allyGrid = document.getElementById('battle-grid-ally');
        // ... (Keep existing Battle Modal Logic, but ensure it handles 9 slots correctly)
        // Previous generic logic:
        // if (allyGrid) { ... loop 9 ... } 
        // We must preserve that.

        if (allyGrid) {
            allyGrid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'battle-cell ally';

                // Find unit by SLOT, not just push order
                const unit = ctx.allies.find(u => u.slot === i);

                if (unit) {
                    cell.innerHTML = `
                        <div class="battle-unit">
                            <div style="font-size:20px;">${this.isDead(unit) ? '💀' : this.getUnitIcon(unit.classType)}</div>
                            <div class="battle-hp-bar"><div class="battle-hp-fill" style="width:${(unit.hp / unit.maxHp) * 100}%"></div></div>
                        </div>
                    `;
                }
                allyGrid.appendChild(cell);
            }
        }

        const enemyGrid = document.getElementById('battle-grid-enemy');
        if (enemyGrid) {
            enemyGrid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'battle-cell enemy';
                const unit = ctx.defenders.find(u => u.slot === i);
                if (unit) {
                    cell.innerHTML = `
                        <div class="battle-unit">
                            <div style="font-size:20px;">${this.isDead(unit) ? '💀' : this.getUnitIcon(unit.classType)}</div>
                            <div class="battle-hp-bar"><div class="battle-hp-fill" style="width:${(unit.hp / unit.maxHp) * 100}%"></div></div>
                        </div>
                    `;
                }
                enemyGrid.appendChild(cell);
            }
        }

        const logDiv = document.getElementById('battle-log');
        if (logDiv) {
            logDiv.innerHTML = ctx.log.map(l => `<div>${l}</div>`).join('');
            logDiv.scrollTop = logDiv.scrollHeight;
        }
    }

    startBattleSimulation() {
        console.log("Starting Battle Simulation...");
        if (!this.battleContext) { console.error("No battle context starting sim"); return; }
        // Force Active
        this.battleContext.active = true;

        if (typeof BattleSimulator === 'undefined') {
            console.error("BattleSimulator module not loaded.");
            this.addBattleLog("Error: Battle Simulator missing.");
            return;
        }

        // Force Close Controls
        const controls = document.getElementById('battle-controls');
        if (controls) controls.style.display = 'none';

        try {
            const sim = new BattleSimulator();
            console.log("Simulating result...");
            const result = sim.simulate(this.battleContext.allies, this.battleContext.defenders);
            console.log("Simulation Result:", result);

            this.battleSimulation = result;
            this.battleStepIndex = 0;
            this.battleContext.log = [];

            console.log("Starting Battle Timer...");
            if (this.battleTimer) clearInterval(this.battleTimer);
            this.battleTick(); // Run first tick immediately
            this.battleTimer = setInterval(() => this.battleTick(), 800);
        } catch (e) {
            console.error("Simulation Initialization Error:", e);
            this.addBattleLog("Simulation Error: " + e.message);
        }
    }

    battleTick() {
        // console.log("Battle Tick", this.battleStepIndex);
        if (!this.battleContext || !this.battleContext.active || !this.battleSimulation) {
            // console.warn("Battle Tick skipped: Invalid State");
            return;
        }

        const steps = this.battleSimulation.steps;
        if (this.battleStepIndex >= steps.length) {
            console.log("Battle Ended via Steps");
            const winner = this.battleSimulation.winner;
            if (winner === 'allies') this.endBattle(true);
            else this.endBattle(false);
            return;
        }

        const step = steps[this.battleStepIndex];
        this.battleStepIndex++;

        if (step.type === 'log') {
            this.addBattleLog(step.msg);
        } else if (step.type === 'attack') {
            this.addBattleLog(step.msg);
            // Update HP
            const targetId = step.defenderId;
            let unit = this.battleContext.allies.find(u => u.id === targetId);
            if (!unit) unit = this.battleContext.defenders.find(u => u.id === targetId);

            if (unit) {
                unit.hp = step.targetHp;
                // Don't full re-render here if possible, but renderBattleModal does it safest.
            }
        }

        this.renderBattleModal();
    }

    addBattleLog(msg) {
        if (this.battleContext) {
            this.battleContext.log.push(msg);
            this.renderBattleModal();
        }
    }

    endBattle(isWin) {
        clearInterval(this.battleTimer);
        this.battleContext.active = false;

        const title = document.getElementById('battle-result-title');
        const overlay = document.getElementById('battle-result-overlay');
        if (overlay) overlay.style.display = 'flex';

        if (isWin) {
            if (title) {
                title.innerText = "VICTORY";
                title.className = "battle-result-text win";
            }
            this.sound.playLevelUp();
            this.addBattleLog("⭐ 전투 승리! 타일을 점령합니다.");
            setTimeout(() => {
                this.handleBattleWin(this.battleContext.r, this.battleContext.c);
                this.closeBattleModal();
            }, 1500);
        } else {
            if (title) {
                title.innerText = "DEFEAT";
                title.className = "battle-result-text lose";
            }
            this.sound.playError();
            this.addBattleLog("❌ 전투 패배... 부대가 후퇴합니다.");
            // Retreat logic if needed
        }
    }

    handleBattleWin(r, c) {
        // Move victorious army to target
        const army = this.armies[this.lastSelectedArmyId] || this.armies.find(a => this.battleContext && a.id === this.battleContext.armyId) || this.armies[0];
        // Note: lastSelectedArmyId should be reliable as battle prep sets it. Better: use battleContext army?
        // battleContext doesn't store armyId explicitly yet, but we can infer or add it. 
        // Providing fallback to lastSelectedArmyId which is set in openBattlePrep
        if (this.lastSelectedArmyId !== null && this.lastSelectedArmyId !== undefined) {
            const a = this.armies[this.lastSelectedArmyId];
            if (a) {
                a.r = r; a.c = c;
                this.revealFog(r, c, FOG_RADIUS);
                this.updateArmies();
            }
        }

        const key = `${r},${c}`;

        // --- EVENT BATTLE WIN ---
        if (this.fieldEvents[key]) {
            const evt = this.fieldEvents[key];
            const drop = EVENT_DROP_TABLE[evt.type];
            if (drop) {
                // Gold Reward
                const gMin = drop.gold[0], gMax = drop.gold[1];
                const gold = Math.floor(Math.random() * (gMax - gMin + 1)) + gMin;
                this.gold += gold;
                this.showToast(`💰 골드 획득: ${gold}`);

                // Item Reward
                drop.items.forEach(d => {
                    if (Math.random() * 100 < d.prob) {
                        // Assuming code fits ITEM_TABLE logic or simple resource
                        // TODO: Generalized Item Add
                        this.showToast(`🎁 아이템 획득 (Code ${d.code})`);
                        // Implementation of adding to inventory/grid needed here or existing spawnItem
                    }
                });
            }

            // Remove Event
            delete this.fieldEvents[key];
            const marker = document.querySelector(`.event-marker[style*="left: ${c * 13}px"][style*="top: ${r * 13}px"]`);
            if (marker) marker.remove();

            this.updateUI();
            this.saveGame();
            return; // Don't process tile capture for transient events
        }

        if (this.occupiedTiles.has(key)) return;
        this.occupiedTiles.add(key);
        const type = FIELD_MAP_DATA[r][c];

        if (isGateTile(type)) {
            this.showToast(`⚔️ 관문 점령!`);
            this.sound.playUnlock();
            this.spawnParticles(this.width / 2, this.height / 2, "#FF0000", 50, "confetti");
        } else if (isDragonTile(type)) {
            this.showToast(`🔥 드래곤 처치!`);
            this.sound.playUnlock();
            this.spawnParticles(this.width / 2, this.height / 2, "#ff6b6b", 50, "confetti");
            setTimeout(() => this.showVictoryModal(), 2000); // Trigger Victory after delay
        } else {
            this.showToast(`🚩 점령 성공!`);
            this.sound.playCollect();
        }

        const effectMsg = this.getCaptureEffectToast(type);
        if (effectMsg) this.pushEffectLog(effectMsg);

        this.updateOpenBorders();
        if (document.getElementById('field-modal').classList.contains('open')) {
            if (!this.refreshFieldMapVisuals()) {
                this.renderFieldMap();
            } else if (this.currentFieldTargetKey === key) {
                this.setFieldInfo(FIELD_MAP_DATA[r][c], r, c);
            }
        }
        this.updateUI(); this.saveGame();
    }

    isDead(unit) { return unit.hp <= 0; }
    getUnitIcon(type) {
        // Simplified icon logic
        if (type === ITEM_TYPE.UNIT_INFANTRY || (type >= 1100 && type < 1200)) return '🛡️';
        if (type === ITEM_TYPE.UNIT_ARCHER || (type >= 1200 && type < 1300)) return '🏹';
        if (type === ITEM_TYPE.UNIT_CAVALRY || (type >= 1300 && type < 1400)) return '🐎';
        return '❓';
    }
}
const game = new Game();
window.game = game;
</script>
</body>

</html>