<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KOV Prototype v90 - Field Interaction</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background-color: #000; touch-action: none; font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; width: 100vw; height: 100dvh; }
        #game-container { position: relative; background-color: #4e342e; box-shadow: 0 0 50px rgba(0,0,0,0.5); width: 100%; height: 100%; max-width: 56.25vh; display: flex; flex-direction: column; overflow: hidden; }
        .header-panel { flex: 0 0 auto; background: linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.0)); color: white; padding: 8px 12px; padding-top: max(8px, env(safe-area-inset-top)); z-index: 20; pointer-events: none; }
        .header-content { pointer-events: auto; }
        #canvas-wrapper { flex: 1; position: relative; overflow: hidden; background-color: #3e2723; width: 100%; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        .footer-panel { flex: 0 0 auto; background: #d7ccc8; border-top: 4px solid #8d6e63; padding: 8px 12px; padding-bottom: max(10px, env(safe-area-inset-bottom)); display: flex; align-items: center; justify-content: space-between; min-height: 90px; z-index: 20; }
        .res-pill { background: rgba(0,0,0,0.6); border: 1px solid #555; border-radius: 99px; padding: 2px 8px 2px 4px; display: flex; align-items: center; gap: 4px; font-weight: bold; font-size: 12px; color: #fff; }
        .res-icon { width: 20px; height: 20px; object-fit: contain; }
        .info-box { flex: 1; background: #f5f5f5; border: 1px solid #8d6e63; border-radius: 6px; padding: 4px 8px; height: 64px; display: flex; flex-direction: column; justify-content: center; color: #3e2723; margin: 0 6px; overflow: hidden; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; font-size: 10px; font-weight: bold; color: #444; margin-top: 2px; }
        .action-btn { width: 50px; height: 50px; background: linear-gradient(to bottom, #ffca28, #ff6f00); border: 1px solid #e65100; border-radius: 8px; color: white; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; box-shadow: 0 2px 0 #bf360c; }
        .world-btn { background: linear-gradient(to bottom, #42a5f5, #1565c0); border-color: #0d47a1; box-shadow: 0 2px 0 #0d47a1; }
        #field-modal { position: absolute; bottom: 0; left: 0; width: 100%; height: 60%; background: rgba(30, 20, 15, 0.98); border-top: 4px solid #8d6e63; border-radius: 20px 20px 0 0; z-index: 50; transform: translateY(100%); transition: transform 0.3s ease-out; display: flex; flex-direction: column; padding: 20px; color: white; }
        #field-modal.open { transform: translateY(0); }
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; overflow-y: auto; }
        .shop-item { background: #4e342e; border: 2px solid #8d6e63; border-radius: 10px; padding: 10px; display: flex; flex-direction: column; align-items: center; }
        #toast { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; opacity: 0; transition: opacity 0.3s; z-index: 100; border: 2px solid #ffd700; white-space: nowrap; pointer-events: none; }
        #levelup-banner { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) scale(0); z-index: 150; pointer-events: none; transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #levelup-banner.show { transform: translate(-50%, -50%) scale(1); }
        .float-text { position: absolute; font-weight: bold; font-size: 16px; text-shadow: 1px 1px 0 #000; pointer-events: none; animation: floatUp 1s ease-out forwards; z-index: 50; }
        .float-img { position: absolute; pointer-events: none; z-index: 60; animation: floatUpImg 1.2s ease-out forwards; width: 60px; height: auto; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-60px); opacity: 0; } }
        @keyframes floatUpImg { 0% { transform: translateY(0) scale(0.5); opacity: 0; } 20% { transform: translateY(-10px) scale(1.2); opacity: 1; } 100% { transform: translateY(-60px) scale(1); opacity: 0; } }
        
        #view-indicator { 
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 20px; 
            color: #fff; font-size: 12px; font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 30;
        }
        #view-indicator.show { opacity: 1; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="levelup-banner"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/levelup.png" onerror="this.style.display='none'"></div>
    <div id="view-indicator">WORLD MAP</div>

    <div class="header-panel">
        <div class="header-content">
            <div class="flex justify-between mb-1">
                <div class="res-pill"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/energy.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='‚ö°'+this.nextElementSibling.innerText"><span id="energy-display">50/50</span></div>
                <div class="res-pill"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/gold.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üí∞'+this.nextElementSibling.innerText"><span id="gold-display">3000</span></div>
                <div class="res-pill"><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/crystal.png" class="res-icon" onerror="this.style.display='none';this.nextElementSibling.innerText='üíé'+this.nextElementSibling.innerText"><span id="gem-display">50</span></div>
            </div>
            <div class="flex flex-col w-full">
                <div class="flex justify-between items-end px-1">
                    <span class="font-bold text-yellow-400 text-xs" id="level-display">LORD LV.1</span>
                    <span class="font-bold text-gray-300 text-xs flex items-center gap-1"><span id="xp-text">0 / 10</span><img src="https://raw.githubusercontent.com/nod-sean/bmo/main/img/xp.png" class="h-3 object-contain" onerror="this.style.display='none';this.previousElementSibling.innerText+=' XP'"></span>
                </div>
                <div class="w-full bg-gray-800 h-2 mt-1 rounded-full overflow-hidden border border-gray-600 relative">
                    <div id="xp-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
                </div>
            </div>
            <div class="flex gap-2 mt-1 opacity-30 hover:opacity-100 transition-opacity justify-end">
                <button onclick="game.cheatEnergy()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚ö°+30</button>
                <button onclick="game.spawnChest()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">üéÅÏÉÅÏûê</button>
                <button onclick="game.cheatLevelUp()" class="bg-gray-700 text-white px-2 py-1 rounded text-[10px]">‚¨ÜÔ∏èLvUP</button>
            </div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="footer-panel">
        <button class="action-btn chat-btn" onclick="game.toggleShopModal()"><span>üè†</span><span style="font-size: 8px;">Í±¥ÏÑ§</span></button>
        <div class="info-box" id="info-panel">
            <div class="flex justify-between items-center"><span class="font-bold text-sm truncate" id="info-name">ÏÑ†ÌÉù ÏóÜÏùå</span><span class="text-[10px] text-gray-500 font-bold" id="info-class"></span></div>
            <div class="stat-grid hidden" id="unit-stats-grid">
                <div class="stat-item">‚ù§<span id="st-hp">0</span></div>
                <div class="stat-item">‚öî<span id="st-atk">0</span></div>
                <div class="stat-item">üõ°Ô∏è<span id="st-def">0</span></div>
                <div class="stat-item">ü¶∂<span id="st-spd">0</span></div>
                <div class="stat-item">üéØ<span id="st-rng">0</span></div>
                <div class="stat-item">üèÉ<span id="st-mov">0</span></div>
            </div>
            <div class="text-[10px] text-gray-600 truncate mt-1" id="info-desc">Ïò§Î∏åÏ†ùÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>
        </div>
        <button class="action-btn" id="btn-action" onclick="game.handleAction()"><span id="action-icon">üí∞</span><span id="action-label" style="font-size: 9px;">Sell</span></button>
        <button class="action-btn world-btn" onclick="game.toggleViewMode()" style="margin-left:5px;"><span>üåç</span><span id="btn-field-label" style="font-size: 9px;">ÌïÑÎìú</span></button>
    </div>

    <div id="field-modal">
        <div class="flex justify-between items-center mb-2 border-b border-gray-600 pb-2">
            <h2 class="text-xl font-bold text-yellow-400">Í±¥ÏÑ§ ÏÉÅÏ†ê</h2>
            <button onclick="game.toggleShopModal()" class="w-8 h-8">‚úñ</button>
        </div>
        <div class="shop-grid" id="shop-list"></div>
    </div>
    <div id="toast">Î©îÏãúÏßÄ</div>
</div>

<script>
// --- CONFIGURATION ---
const GITHUB_REPO = "nod-sean/bmo";
const GITHUB_BRANCH = "main";
const LOCAL_BASE_PATH = "./"; 
const SEARCH_PATHS = ["", "img/", "assets/", "images/"];
const EXTENSIONS = [".png", ".PNG", ".jpg", ".jpeg"];

const ASSET_KEYS = [
    '1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110',
    '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210',
    '2101', '2102', '2103', '2104', '2105', '2201', '2204', '2205',
    '2301', '2302', '2303', '2304', '2801', '2802', '2803', '2804', '2805',
    '3101', '3102', '3103', '3104', '3105',
    '1801', '1802', '1803', '1804', '1805', '1811', '1812', '1813', '1814', '1815',
    '1821', '1822', '1823', '1824', '1825', 'lock', 'gold', 'energy', 'crystal', 'xp', 'levelup', '5xp', '10xp', 'x', 'LV'
];

const ITEM_TYPE = { EMPTY: 0, BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3, BUILDING_CHEST: 4, BUILDING_CAMP: 5, UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12, ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22 };
const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2' };
const BUILDING_LIMITS = { [ITEM_TYPE.BUILDING_BARRACKS]: 3, [ITEM_TYPE.BUILDING_RANGE]: 2, [ITEM_TYPE.BUILDING_STABLE]: 2, [ITEM_TYPE.BUILDING_CAMP]: 2, [ITEM_TYPE.BUILDING_CHEST]: 99 };
const SHOP_DATA = [ { type: ITEM_TYPE.BUILDING_BARRACKS, name: "Î≥ëÏòÅ", price: 100, icon: "üè†" }, { type: ITEM_TYPE.BUILDING_RANGE, name: "ÏÇ¨Í≤©Ïû•", price: 200, icon: "üéØ" }, { type: ITEM_TYPE.BUILDING_STABLE, name: "ÎßàÍµ¨Í∞Ñ", price: 500, icon: "üê¥" }, { type: ITEM_TYPE.BUILDING_CAMP, name: "Ï∫†ÌîÑ", price: 300, icon: "‚õ∫" }, { type: ITEM_TYPE.BUILDING_CHEST, name: "Î≥¥Î¨ºÏÉÅÏûê", price: 500, icon: "üéÅ" } ];

// Mapping Field Codes to Readable Data
const FIELD_TILES = {
    0: { name: "Îπà ÎïÖ", icon: "üå≤", color: "#5D4037", desc: "ÎπÑÏñ¥ ÏûàÎäî ÌÜ†ÏßÄÏûÖÎãàÎã§." },
    1: { name: "ÎÇ¥ ÏÑ±", icon: "üè∞", color: "#3498db", desc: "ÎÇòÏùò Î≥∏Í±∞ÏßÄÏûÖÎãàÎã§." },
    2: { name: "Í¥ÄÎ¨∏", icon: "‚õ©Ô∏è", color: "#e74c3c", desc: "Ï†ÑÎûµÏ†Å ÏöîÏ∂©ÏßÄÏûÖÎãàÎã§." },
    3: { name: "ÏÑ±Ï±Ñ", icon: "üèØ", color: "#e67e22", desc: "Í∞ïÎ†•Ìïú Î∞©Ïñ¥ ÏãúÏÑ§ÏûÖÎãàÎã§." },
    4: { name: "ÎèÑÎ°ú", icon: "üõ£Ô∏è", color: "#95a5a6", desc: "Ïù¥Îèô Í∞ÄÎä•Ìïú ÎèÑÎ°úÏûÖÎãàÎã§." },
    5: { name: "ÏÇ∞", icon: "‚õ∞Ô∏è", color: "#2c3e50", desc: "ÎÑòÏùÑ Ïàò ÏóÜÎäî ÏÇ∞ÏûÖÎãàÎã§." }
};

const CONFIG = { 
    gridCols: 8, gridRows: 8, gridTopY: 520, gridPadding: 20, 
    squadCols: 3, squadRows: 3, 
    squadTopY: 55, 
    squadGap: 80, 
    squadCellSize: 130 
};

// --- DATA HANDLING ---
// Embedded GAME_DATA to resolve CORS issues when running locally
const GAME_DATA = {
    level_xp: { "1": 10, "2": 22, "3": 37, "4": 55, "5": 77, "6": 103, "7": 134, "8": 169, "9": 209, "10": 254, "11": 304, "12": 359, "13": 420, "14": 486, "15": 558 },
    level_energy: { "1": 50, "2": 52, "3": 54, "4": 56, "5": 58, "6": 60, "7": 62, "8": 64, "9": 66, "10": 68, "11": 70, "12": 72, "13": 74, "14": 76, "15": 78 },
    merge_xp: { "1":1, "2":2, "3":4, "4":5, "5":6, "6":8, "7":10, "8":15, "9":20, "10":0 },
    localization: {
        en: { sell: "Sell", field: "Field" },
        ko: { 
            sell: "ÌåêÎß§", field: "ÌïÑÎìú",
            desc_11xx: "Î≥¥Î≥ë Ïú†ÎãõÏûÖÎãàÎã§.\nÎ∞©Ïñ¥Î†•Ïù¥ ÎÜíÍ≥† Í∏∞Î≥∏Ï†ÅÏù∏ Í≥µÍ≤©ÏùÑ Ìï©ÎãàÎã§.",
            desc_12xx: "Í∂ÅÏàò Ïú†ÎãõÏûÖÎãàÎã§.\nÏÇ¨Í±∞Î¶¨Í∞Ä Í∏∏ÏßÄÎßå Î∞©Ïñ¥Î†•Ïù¥ ÎÇÆÏäµÎãàÎã§.",
            desc_13xx: "Í∏∞Î≥ë Ïú†ÎãõÏûÖÎãàÎã§.\nÏù¥Îèô ÏÜçÎèÑÍ∞Ä Îπ†Î•¥Í≥† Í≥µÍ≤©Î†•Ïù¥ ÎÜíÏäµÎãàÎã§.",
            desc_2101: "Î≥ëÏòÅ.\nÎ≥¥Î≥ë Ïú†ÎãõÏùÑ ÏÉùÏÇ∞Ìï©ÎãàÎã§.",
            desc_2201: "ÏÇ¨Í≤©Ïû•.\nÍ∂ÅÏàò Ïú†ÎãõÏùÑ ÏÉùÏÇ∞Ìï©ÎãàÎã§.",
            desc_2301: "ÎßàÍµ¨Í∞Ñ.\nÍ∏∞Î≥ë Ïú†ÎãõÏùÑ ÏÉùÏÇ∞Ìï©ÎãàÎã§.",
            desc_3101: "ÎßâÏÇ¨.\nÏú†ÎãõÏùÑ Î≥¥Í¥ÄÌï©ÎãàÎã§.",
            desc_28xx: "Î≥¥Î¨ºÏÉÅÏûê.\nÎûúÎç§Ìïú ÏûêÏõêÍ≥º ÏïÑÏù¥ÌÖúÏù¥ Îì§Ïñ¥ÏûàÏäµÎãàÎã§."
        }
    },
    units: {
        "1101": { name: "Militia", name_kr: "ÎØºÎ≥ë", hp: 10, atk: 5, def: 10, spd: 5, range: 1, move: 1, sell: 0 },
        "1102": { name: "Infantry", name_kr: "Î≥¥Î≥ë", hp: 20, atk: 7, def: 15, spd: 7, range: 1, move: 1, sell: 1 },
        "1103": { name: "Swordsman", name_kr: "Í≤ÄÎ≥ë", hp: 30, atk: 9, def: 20, spd: 9, range: 1, move: 1, sell: 1 },
        "1104": { name: "Shieldman", name_kr: "Î∞©Ìå®Î≥ë", hp: 40, atk: 11, def: 25, spd: 11, range: 1, move: 1, sell: 2 },
        "1105": { name: "Heavy Infantry", name_kr: "Ï§ëÍ∞ëÎ≥ë", hp: 50, atk: 13, def: 30, spd: 13, range: 1, move: 1, sell: 3 },
        "1106": { name: "Elite", name_kr: "Ï†ïÏòàÎ≥ë", hp: 60, atk: 15, def: 35, spd: 15, range: 1, move: 1, sell: 6 },
        "1107": { name: "Guard", name_kr: "Í∑ºÏúÑÎ≥ë", hp: 70, atk: 17, def: 40, spd: 17, range: 1, move: 1, sell: 12 },
        "1108": { name: "Templar", name_kr: "ÌÖúÌîåÎü¨", hp: 80, atk: 19, def: 45, spd: 19, range: 1, move: 1, sell: 25 },
        "1109": { name: "Paladin", name_kr: "ÌåîÎùºÎîò", hp: 90, atk: 21, def: 50, spd: 21, range: 1, move: 1, sell: 50 },
        "1110": { name: "Hero", name_kr: "ÏòÅÏõÖ", hp: 100, atk: 23, def: 55, spd: 23, range: 1, move: 1, sell: 100 },
        "1201": { name: "Rookie Archer", name_kr: "Ï¥àÎ≥¥ Í∂ÅÏàò", hp: 8, atk: 8, def: 5, spd: 7, range: 3, move: 1, sell: 0 },
        "1202": { name: "Archer", name_kr: "Í∂ÅÏàò", hp: 16, atk: 11, def: 7, spd: 9, range: 3, move: 1, sell: 1 },
        "1203": { name: "Hunter", name_kr: "ÏÇ¨ÎÉ•Íæº", hp: 24, atk: 14, def: 9, spd: 11, range: 3, move: 1, sell: 1 },
        "1204": { name: "Marksman", name_kr: "Î™ÖÏÇ¨Ïàò", hp: 32, atk: 17, def: 11, spd: 13, range: 4, move: 1, sell: 2 },
        "1205": { name: "Sniper", name_kr: "Ï†ÄÍ≤©Ïàò", hp: 40, atk: 20, def: 13, spd: 15, range: 4, move: 1, sell: 3 },
        "1206": { name: "Elite Archer", name_kr: "Ï†ïÏòà Í∂ÅÏàò", hp: 48, atk: 23, def: 15, spd: 17, range: 4, move: 1, sell: 6 },
        "1207": { name: "Deadeye", name_kr: "Îç∞ÎìúÏïÑÏù¥", hp: 56, atk: 26, def: 17, spd: 19, range: 5, move: 1, sell: 12 },
        "1208": { name: "Pathfinder", name_kr: "Ìå®Ïä§ÌååÏù∏Îçî", hp: 64, atk: 29, def: 19, spd: 21, range: 5, move: 1, sell: 25 },
        "1209": { name: "Bowmaster", name_kr: "Î≥¥Ïö∞ÎßàÏä§ÌÑ∞", hp: 72, atk: 32, def: 21, spd: 23, range: 5, move: 1, sell: 50 },
        "1210": { name: "Divine Archer", name_kr: "Ïã†Í∂Å", hp: 80, atk: 35, def: 23, spd: 25, range: 6, move: 1, sell: 100 },
        "1301": { name: "Rider", name_kr: "Í∏∞Î≥ë", hp: 12, atk: 6, def: 8, spd: 10, range: 1, move: 2, sell: 0 },
        "1302": { name: "Light Cavalry", name_kr: "Í≤ΩÍ∏∞Î≥ë", hp: 24, atk: 9, def: 12, spd: 12, range: 1, move: 2, sell: 1 },
        "1303": { name: "Lancer", name_kr: "Ï∞ΩÍ∏∞Î≥ë", hp: 36, atk: 12, def: 16, spd: 14, range: 1, move: 2, sell: 1 },
        "1304": { name: "Knight", name_kr: "Í∏∞ÏÇ¨", hp: 48, atk: 15, def: 20, spd: 16, range: 1, move: 2, sell: 2 },
        "1305": { name: "Heavy Cavalry", name_kr: "Ï§ëÍ∏∞Î≥ë", hp: 60, atk: 18, def: 24, spd: 18, range: 1, move: 2, sell: 3 },
        "1306": { name: "Elite Cavalry", name_kr: "Ï†ïÏòà Í∏∞Î≥ë", hp: 72, atk: 21, def: 28, spd: 20, range: 1, move: 2, sell: 6 },
        "1307": { name: "Royal Knight", name_kr: "Î°úÏñÑ ÎÇòÏù¥Ìä∏", hp: 84, atk: 24, def: 32, spd: 22, range: 1, move: 2, sell: 12 },
        "1308": { name: "Dragon Knight", name_kr: "ÎìúÎûòÍ≥§ ÎÇòÏù¥Ìä∏", hp: 96, atk: 27, def: 36, spd: 24, range: 1, move: 2, sell: 25 },
        "1309": { name: "Valkyrie", name_kr: "Î∞úÌÇ§Î¶¨", hp: 108, atk: 30, def: 40, spd: 26, range: 1, move: 2, sell: 50 },
        "1310": { name: "Legendary Knight", name_kr: "Ï†ÑÏÑ§Ïùò Í∏∞ÏÇ¨", hp: 120, atk: 33, def: 44, spd: 28, range: 1, move: 2, sell: 100 }
    },
    items: {
        "1801": { name: "Gold", name_kr: "Í≥®Îìú", earn: 1 },
        "1802": { name: "Gold", name_kr: "Í≥®Îìú", earn: 2 },
        "1803": { name: "Gold", name_kr: "Í≥®Îìú", earn: 6 },
        "1804": { name: "Gold", name_kr: "Í≥®Îìú", earn: 14 },
        "1805": { name: "Gold", name_kr: "Í≥®Îìú", earn: 32 },
        "1811": { name: "Energy", name_kr: "ÏóêÎÑàÏßÄ", earn: 1 },
        "1812": { name: "Energy", name_kr: "ÏóêÎÑàÏßÄ", earn: 2 },
        "1813": { name: "Energy", name_kr: "ÏóêÎÑàÏßÄ", earn: 6 },
        "1814": { name: "Energy", name_kr: "ÏóêÎÑàÏßÄ", earn: 14 },
        "1815": { name: "Energy", name_kr: "ÏóêÎÑàÏßÄ", earn: 32 },
        "1821": { name: "Crystal", name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 1 },
        "1822": { name: "Crystal", name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 2 },
        "1823": { name: "Crystal", name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 6 },
        "1824": { name: "Crystal", name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 14 },
        "1825": { name: "Crystal", name_kr: "ÌÅ¨Î¶¨Ïä§ÌÉà", earn: 32 }
    },
    buildings: {
        "2101": { energy: 1, prob: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] }, "2102": { energy: 2, prob: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        "2103": { energy: 3, prob: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] }, "2104": { energy: 4, prob: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        "2105": { energy: 5, prob: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] },
        "2201": { energy: 1, prob: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] }, "2202": { energy: 2, prob: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        "2203": { energy: 3, prob: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] }, "2204": { energy: 4, prob: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        "2205": { energy: 5, prob: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] },
        "2301": { energy: 1, prob: [90, 10, 0, 0, 0, 0, 0, 0, 0, 0] }, "2302": { energy: 2, prob: [0, 90, 10, 0, 0, 0, 0, 0, 0, 0] },
        "2303": { energy: 3, prob: [0, 45, 55, 0, 0, 0, 0, 0, 0, 0] }, "2304": { energy: 4, prob: [0, 0, 90, 10, 0, 0, 0, 0, 0, 0] },
        "2305": { energy: 5, prob: [0, 0, 80, 10, 10, 0, 0, 0, 0, 0] },
        "2801": { min: 2, max: 3 }, "2802": { min: 2, max: 4 }, "2803": { min: 3, max: 4 },
        "2804": { min: 4, max: 5 }, "2805": { min: 4, max: 5 }
    },
    chests: {
        "2801": { drops: [ {code: 1801, prob: 50}, {code: 1811, prob: 50} ] },
        "2802": { drops: [ {code: 1801, prob: 25}, {code: 1802, prob: 25}, {code: 1811, prob: 25}, {code: 1812, prob: 25} ] },
        "2803": { drops: [ {code: 1801, prob: 20}, {code: 1802, prob: 20}, {code: 1803, prob: 10}, {code: 1811, prob: 20}, {code: 1812, prob: 20}, {code: 1813, prob: 10} ] },
        "2804": { drops: [ {code: 1802, prob: 20}, {code: 1803, prob: 20}, {code: 1804, prob: 5}, {code: 1812, prob: 20}, {code: 1813, prob: 20}, {code: 1814, prob: 5}, {code: 1821, prob: 10} ] },
        "2805": { drops: [ {code: 1802, prob: 15}, {code: 1803, prob: 20}, {code: 1804, prob: 10}, {code: 1812, prob: 15}, {code: 1813, prob: 20}, {code: 1814, prob: 10}, {code: 1821, prob: 5}, {code: 1825, prob: 5} ] }
    },
    camps: {
        "3101": {capacity:4}, "3102": {capacity:6}, "3103": {capacity:8}, "3104": {capacity:12}, "3105": {capacity:16}
    },
    unlock_conditions: {
        level: [[24, 20, 14, 10, 10, 14, 20, 24], [23, 18, 6,  2,  2,  6,  18, 21], [17, 8,  0,  0,  0,  0,  9,  15], [13, 5,  0,  0,  0,  0,  3,  11], [13, 5,  0,  0,  0,  0,  3,  11], [17, 8,  0,  0,  0,  0,  9,  15], [23, 19, 7,  4,  4,  7,  19, 21], [25, 22, 16, 12, 12, 16, 22, 25]],
        gold: [[100, 50, 30, 20, 20, 30, 50, 100], [50, 40, 10, 5,  5,  10, 40, 50], [30, 10, 0,  0,  0,  0,  10, 30], [20, 5,  0,  0,  0,  0,  5,  20], [20, 5,  0,  0,  0,  0,  5,  20], [30, 10, 0,  0,  0,  0,  10, 30], [50, 40, 10, 5,  5,  10, 40, 50], [100, 50, 30, 20, 20, 30, 50, 100]]
    },
    field_map: [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,3,4,2,4,4,1,4,4,2,4,3,4,2,4,4,1,4,4,2,0,3,0,0],
        [0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0],
        [0,0,2,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,2,0],
        [0,0,4,0,0,0,0,2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,4,0,0],
        [0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,4,0],
        [0,1,4,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,4,1],
        [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],
        [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],
        [0,2,4,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,2,0],
        [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0],
        [0,4,3,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,2,0,0,3,4,0],
        [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0],
        [0,2,4,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,2,0],
        [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0],
        [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0],
        [0,1,4,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,4,1],
        [0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,4,0],
        [0,0,4,0,0,0,0,2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,4,0,0],
        [0,0,2,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,2,0],
        [0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0],
        [0,0,3,4,2,4,4,1,4,4,2,4,3,4,2,4,4,1,4,4,2,0,3,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ]
};

function initGameData() {
    // Return a promise that resolves immediately since data is embedded
    return new Promise((resolve) => {
        console.log("Game Data Loaded Successfully (Embedded)");
        resolve(GAME_DATA);
    });
}

function getText(key) {
    if (GAME_DATA && GAME_DATA.localization && GAME_DATA.localization.ko) {
        return GAME_DATA.localization.ko[key] || key;
    }
    return key;
}

function getInfoFromCode(code) {
    if (code >= 1100 && code < 1200) return { type: ITEM_TYPE.UNIT_INFANTRY, level: code % 100 };
    if (code >= 1200 && code < 1300) return { type: ITEM_TYPE.UNIT_ARCHER, level: code % 100 };
    if (code >= 1300 && code < 1400) return { type: ITEM_TYPE.UNIT_CAVALRY, level: code % 100 };
    if (code >= 1800 && code < 1810) return { type: ITEM_TYPE.ITEM_GOLD, level: code - 1800 };
    if (code >= 1810 && code < 1820) return { type: ITEM_TYPE.ITEM_ENERGY, level: code - 1810 };
    if (code >= 1820 && code < 1830) return { type: ITEM_TYPE.ITEM_CRYSTAL, level: code - 1820 };
    return { type: ITEM_TYPE.ITEM_GOLD, level: 1 };
}

function getCode(type, level) {
    if (type === ITEM_TYPE.UNIT_INFANTRY) return 1100 + level;
    if (type === ITEM_TYPE.UNIT_ARCHER) return 1200 + level;
    if (type === ITEM_TYPE.UNIT_CAVALRY) return 1300 + level;
    if (type === ITEM_TYPE.BUILDING_BARRACKS) return 2100 + level;
    if (type === ITEM_TYPE.BUILDING_RANGE) return 2200 + level;
    if (type === ITEM_TYPE.BUILDING_STABLE) return 2300 + level;
    if (type === ITEM_TYPE.BUILDING_CHEST) return 2800 + level;
    if (type === ITEM_TYPE.BUILDING_CAMP) return 3100 + level;
    if (type === ITEM_TYPE.ITEM_GOLD) return 1800 + level;
    if (type === ITEM_TYPE.ITEM_ENERGY) return 1810 + level;
    if (type === ITEM_TYPE.ITEM_CRYSTAL) return 1820 + level;
    return 0;
}

function getData(type, level) {
    const code = getCode(type, level);
    if (!GAME_DATA) return { name: "Loading..." };

    if (type >= 20) { 
        const data = GAME_DATA.items[code];
        if (data) return { name: data.name_kr || data.name, earn: data.earn };
    }
    if (type < 10) { 
        const data = GAME_DATA.buildings[code];
        if (type === ITEM_TYPE.BUILDING_CHEST) return { name: "Î≥¥Î¨ºÏÉÅÏûê" }; 
        if (type === ITEM_TYPE.BUILDING_CAMP) return { name: "ÎßâÏÇ¨" };
        if (data) return { 
            name: (type === 1 ? "Î≥ëÏòÅ" : (type === 2 ? "ÏÇ¨Í≤©Ïû•" : "ÎßàÍµ¨Í∞Ñ")), 
            energy: data.energy 
        };
    }
    if (type >= 10 && type < 20) {
        const stat = GAME_DATA.units[code];
        if (stat) {
            return { 
                name: stat.name_kr || stat.name, 
                class: type === 10 ? "Î≥¥Î≥ë" : (type === 11 ? "Í∂ÅÎ≥ë" : "Í∏∞Î≥ë"),
                hp: stat.hp, atk: stat.atk, def: stat.def, 
                spd: stat.spd, rng: stat.range || stat.rng, mov: stat.move || stat.mov, sell: stat.sell 
            };
        }
    }
    return { name: "Unknown", earn: 0, sell: 0 };
}

class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
        this.bgmStarted = false;
        
        // Use GitHub Raw URL for Audio
        const BASE_AUDIO_URL = "https://raw.githubusercontent.com/nod-sean/bmo/main/audio/";
        
        this.files = {
            bgm: new Audio(BASE_AUDIO_URL + 'bgm.mp3'),
            merge: new Audio(BASE_AUDIO_URL + 'merge.mp3'),
            coin: new Audio(BASE_AUDIO_URL + 'coin.mp3'),
            pop: new Audio(BASE_AUDIO_URL + 'pop.mp3')
        };
        
        this.files.bgm.loop = true;
        this.files.bgm.volume = 0.5; // BGM Volume
    }

    resume() {
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        if (this.enabled && !this.bgmStarted) {
            this.files.bgm.play().then(() => {
                this.bgmStarted = true;
            }).catch(e => console.log("BGM requires interaction"));
        }
    }

    playFile(name, vol=1.0) {
        if (!this.enabled || !this.files[name]) return;
        const sound = this.files[name].cloneNode(); // Clone to allow overlapping
        sound.crossOrigin = "anonymous"; // Safe check
        sound.volume = vol;
        sound.play().catch(e => {});
    }

    // Fallback Oscillator for missing files or specific effects
    playTone(freq, type, duration, vol=0.1) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playClick() { this.playFile('pop', 0.6); }
    playError() { this.playTone(150, 'sawtooth', 0.3, 0.1); } // Keep oscillator for error
    playSpawn() { this.playFile('pop', 0.5); }
    playMerge() { this.playFile('merge', 0.8); }
    playCollect() { this.playFile('coin', 0.6); }
    playUnlock() { this.playFile('merge', 0.8); } // Reuse merge sound for unlock
    playLevelUp() {
        // Keep special tone for level up
        [440, 554, 659, 880].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.3), i*100));
    }
}

class AssetLoader {
    constructor() { this.images = {}; this.failedKeys = new Set(); }
    tryLoadImage(key, pathIndex, extIndex, useLocal) {
        return new Promise((resolve) => {
            if (!useLocal && pathIndex >= SEARCH_PATHS.length) { this.failedKeys.add(key); resolve(null); return; }
            const img = new Image();
            if (!useLocal) img.crossOrigin = "Anonymous";
            let url = useLocal ? `${LOCAL_BASE_PATH}${key}${EXTENSIONS[extIndex]}` : `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/${SEARCH_PATHS[pathIndex]}${key}${EXTENSIONS[extIndex]}`;
            img.onload = () => resolve(img);
            img.onerror = () => {
                if (extIndex + 1 < EXTENSIONS.length) this.tryLoadImage(key, pathIndex, extIndex + 1, useLocal).then(resolve);
                else if (!useLocal) this.tryLoadImage(key, pathIndex + 1, 0, false).then(resolve);
                else resolve(null);
            };
            img.src = url;
        });
    }
    async loadAll(callback) {
        await Promise.all(ASSET_KEYS.map(async (key) => {
            let img = await this.tryLoadImage(key, 0, 0, true);
            if (!img) img = await this.tryLoadImage(key, 0, 0, false);
            if (img) this.images[key] = img;
        }));
        if (callback) callback();
    }
    getImage(type, level) {
        if(typeof type === 'string') return this.images[type];
        const code = getCode(type, level);
        return this.images[code] || (level > 1 ? this.getImage(type, level - 1) : null);
    }
}

class Particle {
    constructor(x, y, color, type) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.color = color;
        this.size = Math.random() * 6 + 4;
        this.type = type; // 'spark', 'smoke', 'confetti'
        if (type === 'smoke') { this.vy = -Math.abs(this.vy) * 0.5; this.decay = 0.015; }
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life -= this.decay;
        if(this.type === 'smoke') this.size += 0.3;
        else this.vy += 0.2; // Gravity
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        if (this.type === 'confetti') {
            ctx.translate(this.x, this.y); ctx.rotate(this.life * 5);
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            ctx.resetTransform();
            // restore scale
            const rect = ctx.canvas.getBoundingClientRect();
            const scale = ctx.canvas.width / 1080; 
            ctx.scale(scale, scale); 
        } else if (this.type === 'smoke') {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
        ctx.globalAlpha = 1.0;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = 1080; this.height = 1920;
        this.assets = new AssetLoader();
        this.sound = new SoundManager();
        
        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null);
        this.squad2 = Array(9).fill(null);
        this.particles = [];
        
        this.lordLevel = 1; this.currentXp = 0; this.updateLevelStats();
        this.energy = this.maxEnergy; this.gold = 3000; this.gem = 50; 
        
        this.drag = null; this.hover = null; this.selectedItem = null; this.potentialDrag = null;
        this.dpr = window.devicePixelRatio || 1;

        // View Mode: 'MERGE' or 'FIELD'
        this.viewMode = 'MERGE';
        this.fieldScroll = { x: 0, y: 0 };
        this.fieldTileSize = 120; // Size of field tiles
        this.lastMouse = { x: 0, y: 0 };
        
        // Field Selection State
        this.selectedFieldTile = null; 
        this.isDraggingMap = false;

        // Squad Movement State
        this.squad1Pos = { r: 12, c: 12 }; // Starting at center (My Castle)

        this.calcLayout();
        this.initGame();
        
        setInterval(() => this.regenEnergy(), 1000);

        window.addEventListener('resize', () => { this.resize(); this.requestRender(); });
        this.resize();
        this.setupInput();
        this.initShopUI();
        
        this.assets.loadAll(() => { this.requestRender(); });
        this.loop();
        this.updateUI();
    }

    requestRender() { this.isDirty = true; }

    spawnParticles(x, y, color, count, type) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color, type));
        }
        this.isDirty = true;
    }

    regenEnergy() {
        if (this.energy < this.maxEnergy) {
            this.energyRegenAcc = (this.energyRegenAcc || 0) + 1;
            if(this.energyRegenAcc >= 5) {
                this.energy++; this.energyRegenAcc = 0; this.updateUI();
            }
        }
    }

    calcLayout() {
        const gridAvailW = this.width - (CONFIG.gridPadding * 2);
        this.gridTileSize = Math.floor(gridAvailW / CONFIG.gridCols);
        this.gridStartX = CONFIG.gridPadding;
        this.gridStartY = CONFIG.gridTopY;
        this.squadCellSize = CONFIG.squadCellSize; 
        const squadW = this.squadCellSize * 3;
        const totalSquadW = (squadW * 2) + CONFIG.squadGap;
        const squadStartX = Math.floor((this.width - totalSquadW) / 2);
        this.squad1Rect = { x: squadStartX, y: CONFIG.squadTopY, w: squadW, h: squadW };
        this.squad2Rect = { x: squadStartX + squadW + CONFIG.squadGap, y: CONFIG.squadTopY, w: squadW, h: squadW };
    }

    initGame() {
        this.refreshLockState(); 
        this.grid[3][3] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1, usage: 5 };
        this.grid[5][5] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnit: null };
    }

    refreshLockState() {
        if (!GAME_DATA) return;
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if (this.gridState[r][c] && this.gridState[r][c].type === LOCK_TYPE.OPEN) continue;
            // Access unlocked conditions from GAME_DATA
            const lvlReq = GAME_DATA.unlock_conditions.level[r] ? GAME_DATA.unlock_conditions.level[r][c] : 99;
            const goldReq = GAME_DATA.unlock_conditions.gold[r] ? GAME_DATA.unlock_conditions.gold[r][c] : 9999;
            
            if (this.lordLevel < lvlReq) this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: lvlReq };
            else if (goldReq > 0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: goldReq };
            else this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
        }
        this.requestRender();
    }

    initShopUI() {
        const list = document.getElementById('shop-list');
        list.innerHTML = "";
        SHOP_DATA.forEach(item => {
            const div = document.createElement('div');
            div.className = 'shop-item';
            div.innerHTML = `<div class="text-2xl">${item.icon}</div><div class="font-bold text-sm text-white">${item.name}</div><button class="shop-btn" onclick="game.buyBuilding(${item.type}, ${item.price})">üí∞ ${item.price}</button>`;
            list.appendChild(div);
        });
    }

    buyBuilding(type, price) {
        if (this.gold < price) { this.showToast("Í≥®Îìú Î∂ÄÏ°±!"); return; }
        const limit = BUILDING_LIMITS[type] || 999;
        const current = this.getBuildingCount(type);
        if (current >= limit) { this.showToast(`ÏµúÎåÄ Í∞úÏàò ÎèÑÎã¨! (${limit})`); return; }

        for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.gold -= price;
                const newItem = { type: type, level: 1, scale: 0 };
                if (type === ITEM_TYPE.BUILDING_CHEST) newItem.usage = 5;
                if (type === ITEM_TYPE.BUILDING_CAMP) newItem.storedUnit = null;
                this.grid[r][c] = newItem;
                this.updateUI(); this.requestRender();
                this.showToast("Í±¥ÏÑ§ ÏôÑÎ£å!");
                this.toggleShopModal(); // Close modal
                this.sound.playSpawn();
                return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }

    getBuildingCount(type) {
        let count = 0;
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) { if (this.grid[r][c] && this.grid[r][c].type === type) count++; }
        return count;
    }

    getHighestBuildingLevel(unitType) {
        let bType = -1;
        if (unitType === ITEM_TYPE.UNIT_INFANTRY) bType = ITEM_TYPE.BUILDING_BARRACKS;
        else if (unitType === ITEM_TYPE.UNIT_ARCHER) bType = ITEM_TYPE.BUILDING_RANGE;
        else if (unitType === ITEM_TYPE.UNIT_CAVALRY) bType = ITEM_TYPE.BUILDING_STABLE;
        if (bType === -1) return 10;
        let maxLvl = 0;
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) if (this.grid[r][c] && this.grid[r][c].type === bType) maxLvl = Math.max(maxLvl, this.grid[r][c].level);
        return maxLvl;
    }

    resize() {
        const wrap = document.getElementById('canvas-wrapper');
        this.canvas.width = Math.floor(wrap.clientWidth * this.dpr);
        this.canvas.height = Math.floor(wrap.clientHeight * this.dpr);
        this.canvas.style.width = `${wrap.clientWidth}px`;
        this.canvas.style.height = `${wrap.clientHeight}px`;
        this.ctx.resetTransform();
        this.ctx.scale(this.canvas.width / this.width, this.canvas.width / this.width);
        this.ctx.imageSmoothingEnabled = false;
        this.requestRender();
        
        // Center field view
        if(this.viewMode === 'FIELD') {
            this.fieldScroll.x = (25 * this.fieldTileSize - this.width) / 2;
            this.fieldScroll.y = (25 * this.fieldTileSize - this.height) / 2;
        }
    }

    addXp(amount) {
        this.currentXp += amount;
        if (this.currentXp >= this.requiredXp) this.levelUp();
        this.updateUI();
    }
    levelUp() {
        if (this.lordLevel >= 15) return;
        this.currentXp -= this.requiredXp;
        this.lordLevel++;
        this.updateLevelStats();
        this.energy = this.maxEnergy; 
        this.refreshLockState();
        document.getElementById('levelup-banner').classList.add('show');
        this.spawnParticles(this.width/2, this.height/2, "#FFD700", 100, "confetti");
        this.sound.playLevelUp();
        setTimeout(() => document.getElementById('levelup-banner').classList.remove('show'), 2000);
        if (this.currentXp >= this.requiredXp) this.levelUp();
    }
    updateLevelStats() {
        if (!GAME_DATA) return;
        const lvlKey = String(this.lordLevel);
        const xpReq = GAME_DATA.level_xp[lvlKey];
        const maxEn = GAME_DATA.level_energy[lvlKey];
        if (xpReq !== undefined) this.requiredXp = xpReq;
        if (maxEn !== undefined) this.maxEnergy = maxEn;
    }

    selectFieldTile(r, c) {
        if (r === null) {
            this.selectedFieldTile = null;
        } else {
            const code = GAME_DATA.field_map[r][c];
            this.selectedFieldTile = { r, c, code };
            this.sound.playClick();
        }
        this.updateInfoPanel();
        this.requestRender();
    }

    selectItem(item, location) {
        if (this.selectedItem?.item !== item) this.sound.playClick();
        this.selectedItem = item ? { item, location } : null;
        this.updateInfoPanel();
        this.requestRender();
    }

    updateInfoPanel() {
        const els = {
            name: document.getElementById('info-name'),
            desc: document.getElementById('info-desc'),
            cls: document.getElementById('info-class'),
            stats: document.getElementById('unit-stats-grid'),
            btn: document.getElementById('btn-action'),
            lbl: document.getElementById('action-label'),
            icon: document.getElementById('action-icon')
        };
        els.stats.classList.add('hidden'); els.cls.innerText = ""; els.btn.style.opacity = 0.5; els.lbl.innerText = "-";
        
        // Field Selection Mode
        if (this.viewMode === 'FIELD') {
            if (this.selectedFieldTile) {
                const { r, c, code } = this.selectedFieldTile;
                const tileInfo = FIELD_TILES[code] || FIELD_TILES[0];
                
                els.name.innerText = `${tileInfo.name} (${c}, ${r})`;
                els.desc.innerText = tileInfo.desc;
                
                // Movement logic: enable button if not mountain (5)
                if (code !== 5) {
                    // Check if squad is already here
                    if (this.squad1Pos.r === r && this.squad1Pos.c === c) {
                        els.lbl.innerText = "ÎåÄÍ∏∞Ï§ë";
                        els.btn.style.opacity = 0.5;
                    } else {
                        // Different logic based on tile type
                        if (code === 0) els.lbl.innerText = "Ïù¥Îèô";
                        else if (code === 1) els.lbl.innerText = "Î≥µÍ∑Ä";
                        else els.lbl.innerText = "Í≥µÍ≤©"; // For 2, 3, 4 (Road attack?? Maybe move)
                        
                        // Check if walkable (simple check for now)
                        els.btn.style.opacity = 1;
                    }
                } else {
                    els.lbl.innerText = "Ïù¥ÎèôÎ∂àÍ∞Ä";
                    els.btn.style.opacity = 0.5;
                }
            } else {
                els.name.innerText = "ÏõîÎìúÎßµ";
                els.desc.innerText = "ÌÉÄÏùºÏùÑ ÏÑ†ÌÉùÌïòÏó¨ Ï†ïÎ≥¥Î•º ÌôïÏù∏ÌïòÍ±∞ÎÇò Î∂ÄÎåÄÎ•º Ïù¥ÎèôÌïòÏÑ∏Ïöî.";
                els.lbl.innerText = "-";
            }
            return;
        }

        // Merge Selection Mode
        if (!this.selectedItem) { els.name.innerText = "ÏÑ†ÌÉùÎêú ÏóÜÏùå"; els.desc.innerText = "Ïú†ÎãõÏù¥ÎÇò Í±¥Î¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî."; return; }

        const item = this.selectedItem.item;
        const code = getCode(item.type, item.level);
        const data = getData(item.type, item.level);
        els.name.innerText = `${data.name} LV.${item.level}`;

        let descKey = "";
        if (code >= 1100 && code < 1200) descKey = "desc_11xx";
        else if (code >= 1200 && code < 1300) descKey = "desc_12xx";
        else if (code >= 1300 && code < 1400) descKey = "desc_13xx";
        else if (item.type === ITEM_TYPE.BUILDING_BARRACKS) descKey = "desc_2101";
        else if (item.type === ITEM_TYPE.BUILDING_RANGE) descKey = "desc_2201";
        else if (item.type === ITEM_TYPE.BUILDING_STABLE) descKey = "desc_2301";
        else if (item.type === ITEM_TYPE.BUILDING_CAMP) descKey = "desc_3101";
        else if (item.type === ITEM_TYPE.BUILDING_CHEST) descKey = "desc_28xx";

        if (item.type < 10) { 
            const campData = GAME_DATA.camps[code] || {capacity: 4};
            if (item.type === ITEM_TYPE.BUILDING_CHEST) els.desc.innerText = `${getText(descKey)}\n(ÎÇ®ÏùÄ ÌöüÏàò: ${item.usage}Ìöå)`;
            else if (item.type === ITEM_TYPE.BUILDING_CAMP) els.desc.innerText = `${getText(descKey)}\n(Î≥¥Í¥Ä: ${item.storedUnit ? 1 : 0} / ${campData.capacity})`;
            else {
                els.desc.innerText = getText(descKey);
                const cost = data.energy || 1;
                els.lbl.innerText = `-${cost}‚ö°`; els.btn.style.opacity = 1; els.icon.innerText = ""; 
            }
        } else if (item.type >= 20) { 
            els.desc.innerText = "ÌÅ¥Î¶≠ÌïòÏó¨ ÌöçÎìù"; els.lbl.innerText = "ÌöçÎìù"; els.btn.style.opacity = 1;
        } else { 
            els.cls.innerText = data.class;
            els.desc.innerText = getText(descKey);
            els.stats.classList.remove('hidden');
            document.getElementById('st-hp').innerText = data.hp; document.getElementById('st-atk').innerText = data.atk;
            document.getElementById('st-def').innerText = data.def; document.getElementById('st-spd').innerText = data.spd;
            document.getElementById('st-rng').innerText = data.rng; document.getElementById('st-mov').innerText = data.mov;
            els.lbl.innerText = `+${data.sell}`; els.icon.innerText = "üí∞"; els.btn.style.opacity = 1;
        }
        document.getElementById('action-label').innerText = item.type >= 10 && item.type < 20 ? getText("sell") : els.lbl.innerText;
    }

    handleAction() {
        // Field Action Logic: Squad Movement
        if (this.viewMode === 'FIELD') {
            if (this.selectedFieldTile) {
                const { r, c, code } = this.selectedFieldTile;
                
                // 1. Check if same location
                if (this.squad1Pos.r === r && this.squad1Pos.c === c) {
                    this.showToast("Ïù¥ÎØ∏ Ìï¥Îãπ ÏúÑÏπòÏóê ÏûàÏäµÎãàÎã§.");
                    return;
                }

                // 2. Check if moveable (Mountain check)
                if (code === 5) {
                    this.showToast("ÏÇ∞ÏúºÎ°úÎäî Ïù¥ÎèôÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
                    return;
                }

                // 3. Check if squad has units
                const squadPower = this.getSquadPower(this.squad1);
                if (squadPower <= 0) {
                    this.showToast("Ïä§ÏøºÎìú 1Ïóê Î∞∞ÏπòÎêú Ïú†ÎãõÏù¥ ÏóÜÏäµÎãàÎã§!");
                    return;
                }

                // 4. Move Squad
                this.squad1Pos = { r, c };
                this.sound.playSpawn(); // Use spawn sound as movement confirmation
                this.showToast("Î∂ÄÎåÄÍ∞Ä Ïù¥ÎèôÌñàÏäµÎãàÎã§!");
                
                // Visual Effect at destination
                const cx = c * this.fieldTileSize + this.fieldTileSize / 2;
                const cy = r * this.fieldTileSize + this.fieldTileSize / 2;
                this.spawnParticles(cx - this.fieldScroll.x, cy - this.fieldScroll.y, "#3498db", 20, "spark");
                
                this.updateInfoPanel();
                this.requestRender();
            }
            return;
        }

        if (!this.selectedItem) return;
        const { item, location } = this.selectedItem;
        if (item.type >= 10 && item.type < 20) { 
            if(location.zone===ZONES.GRID) this.grid[location.r][location.c]=null;
            else if(location.zone===ZONES.SQUAD1) this.squad1[location.idx]=null;
            else this.squad2[location.idx]=null;
            const val = getData(item.type, item.level).sell;
            this.gold += val; this.showToast(`+${val} G`);
            this.sound.playCollect();
            this.selectItem(null); this.updateUI(); this.requestRender();
        } else if (item.type < 10 && item.type !== ITEM_TYPE.BUILDING_CHEST && item.type !== ITEM_TYPE.BUILDING_CAMP) {
            this.produce(item); 
        }
    }

    // --- INPUT HANDLING ---
    setupInput() {
        const getPos = e => {
            const r = this.canvas.getBoundingClientRect();
            return { x: ((e.touches?e.touches[0].clientX:e.clientX)-r.left)*(this.width/r.width), y: ((e.touches?e.touches[0].clientY:e.clientY)-r.top)*(this.width/r.width) };
        };
        const start = e => {
            this.sound.resume();
            const p = getPos(e);
            this.lastMouse = p;
            this.dragStartPos = p; // Keep initial pos to detect true click vs drag
            
            if (this.viewMode === 'FIELD') {
                this.isDraggingMap = true;
                return;
            }

            const hit = this.getZoneAt(p.x, p.y);
            if (hit) {
                if (hit.zone === ZONES.GRID && this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { this.tryUnlock(hit.r, hit.c); return; }
                let item = hit.zone===ZONES.GRID ? this.grid[hit.r][hit.c] : (hit.zone===ZONES.SQUAD1 ? this.squad1[hit.idx] : this.squad2[hit.idx]);
                this.potentialDrag = { startPos: p, item, hit };
            } else this.selectItem(null);
        };
        const move = e => {
            const p = getPos(e);
            
            if (this.viewMode === 'FIELD' && this.isDraggingMap) {
                const dx = p.x - this.lastMouse.x;
                const dy = p.y - this.lastMouse.y;
                this.fieldScroll.x -= dx;
                this.fieldScroll.y -= dy;
                // Clamp scroll
                const maxScroll = (25 * this.fieldTileSize) - this.width;
                this.fieldScroll.x = Math.max(0, Math.min(this.fieldScroll.x, maxScroll > 0 ? maxScroll : 0));
                this.fieldScroll.y = Math.max(0, Math.min(this.fieldScroll.y, (25 * this.fieldTileSize) - this.height));
                this.lastMouse = p;
                this.requestRender();
                return;
            }

            if (this.potentialDrag && !this.drag) {
                if (Math.hypot(p.x-this.potentialDrag.startPos.x, p.y-this.potentialDrag.startPos.y) > 10 && this.potentialDrag.item)
                    this.startDrag(this.potentialDrag.item, this.potentialDrag.hit, p);
            }
            if (this.drag) { this.drag.x = p.x; this.drag.y = p.y; this.hover = this.getZoneAt(this.drag.x, this.drag.y); this.requestRender(); }
        };
        const end = e => {
            const p = getPos(e);
            if (this.viewMode === 'FIELD') {
                // If moved less than 10px, treat as click
                if (this.isDraggingMap && Math.hypot(p.x - this.dragStartPos.x, p.y - this.dragStartPos.y) < 10) {
                    const worldX = p.x + this.fieldScroll.x;
                    const worldY = p.y + this.fieldScroll.y;
                    const c = Math.floor(worldX / this.fieldTileSize);
                    const r = Math.floor(worldY / this.fieldTileSize);
                    
                    if (c >= 0 && c < 25 && r >= 0 && r < 25) {
                        this.selectFieldTile(r, c);
                    } else {
                        this.selectFieldTile(null);
                    }
                }
                this.isDraggingMap = false;
                return;
            }
            if (this.drag) this.endDrag();
            else if (this.potentialDrag) this.handleClick(this.potentialDrag.item, this.potentialDrag.hit);
            this.potentialDrag = null; this.drag = null;
        };
        this.canvas.onmousedown = start; window.onmousemove = move; window.onmouseup = end;
        this.canvas.ontouchstart = e => { start(e); e.preventDefault(); }; window.ontouchmove = e => { move(e); e.preventDefault(); }; window.ontouchend = end;
    }

    startDrag(item, hit, pos) {
        let cx, cy;
        if(hit.zone===ZONES.GRID) { cx = this.gridStartX+hit.c*this.gridTileSize; cy = this.gridStartY+hit.r*this.gridTileSize; }
        else if(hit.zone===ZONES.SQUAD1) { cx = this.squad1Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad1Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; }
        else { cx = this.squad2Rect.x+(hit.idx%3)*this.squadCellSize; cy = this.squad2Rect.y+Math.floor(hit.idx/3)*this.squadCellSize; }
        
        this.drag = { item, startZone: hit, x: pos.x, y: pos.y, offsetX: pos.x-cx, offsetY: pos.y-cy, size: hit.zone===ZONES.GRID?this.gridTileSize:this.squadCellSize };
        if(hit.zone===ZONES.GRID) this.grid[hit.r][hit.c]=null;
        else if(hit.zone===ZONES.SQUAD1) this.squad1[hit.idx]=null;
        else this.squad2[hit.idx]=null;
        this.selectItem(item, hit); this.requestRender();
    }

    endDrag() {
        const hit = this.getZoneAt(this.drag.x, this.drag.y);
        let returned = false;
        if (hit) {
            let target = null;
            if(hit.zone===ZONES.GRID) { if(this.gridState[hit.r][hit.c].type!==LOCK_TYPE.OPEN) returned=true; else target=this.grid[hit.r][hit.c]; }
            else if(hit.zone===ZONES.SQUAD1) target=this.squad1[hit.idx];
            else target=this.squad2[hit.idx];

            if (!returned) {
                if (!target) {
                    if(hit.zone===ZONES.GRID) this.grid[hit.r][hit.c]=this.drag.item;
                    else if(hit.zone===ZONES.SQUAD1) this.squad1[hit.idx]=this.drag.item;
                    else this.squad2[hit.idx]=this.drag.item;
                    this.selectItem(this.drag.item, hit);
                } else if (target.type===ITEM_TYPE.BUILDING_CAMP && !target.storedUnit && this.drag.item.type>=10 && this.drag.item.type<20 && hit.zone===ZONES.GRID) {
                    target.storedUnit = this.drag.item; this.showToast("Î≥¥Í¥ÄÎê®");
                    this.sound.playClick();
                } else if (target.type===this.drag.item.type && target.level===this.drag.item.level) {
                    // Merge Logic
                    const isUnit = target.type>=10 && target.type<20;
                    const maxLvl = isUnit ? 10 : 5;
                    let canMerge = true;
                    if(isUnit) {
                        const bLvl = this.getHighestBuildingLevel(target.type);
                        if(target.level >= bLvl+5) { this.showToast(`Ìï©ÏÑ± Î∂àÍ∞Ä (Í±¥Î¨º Lv.${target.level-4} ÌïÑÏöî)`); canMerge=false; returned=true; }
                    }
                    if(canMerge && target.level < maxLvl) {
                        target.level++; target.scale=1.3;
                        if(target.type===ITEM_TYPE.BUILDING_CHEST) target.usage = Math.floor((target.usage+this.drag.item.usage)/2);
                        const xp = GAME_DATA.merge_xp[String(target.level-1)] || 1;
                        this.addXp(xp); this.showFloatingImage('xp', hit.zone===ZONES.GRID ? this.gridStartX+hit.c*this.gridTileSize : this.drag.x, this.drag.y);
                        this.spawnParticles(this.drag.x, this.drag.y, "#FFD700", 30, "spark");
                        this.sound.playMerge();
                    } else if(canMerge) { this.showToast("ÏµúÎåÄ Î†àÎ≤®"); returned=true; }
                } else returned=true;
            }
        } else returned=true;

        if (returned) {
            const s=this.drag.startZone;
            if(s.zone===ZONES.GRID) this.grid[s.r][s.c]=this.drag.item;
            else if(s.zone===ZONES.SQUAD1) this.squad1[s.idx]=this.drag.item;
            else this.squad2[s.idx]=this.drag.item;
        }
        this.hover=null; this.updateUI(); this.requestRender();
    }

    handleClick(item, hit) {
        if(!item) { this.selectItem(null); return; }
        this.selectItem(item, hit);
        if(item.type>=20) this.collectResource(item, hit.r, hit.c);
        else if(item.type===ITEM_TYPE.BUILDING_CAMP) this.ejectCamp(item, hit.r, hit.c);
        else if(item.type<10 && item.type!==ITEM_TYPE.BUILDING_CAMP) {
            if(item.type===ITEM_TYPE.BUILDING_CHEST) this.produceFromChest(item, hit.r, hit.c);
            else this.produce(item);
        }
    }

    getZoneAt(x, y) {
        const check = (rect, rows, cols, size) => {
            if(x>=rect.x && x<rect.x+rect.w && y>=rect.y && y<rect.y+rect.h) {
                const c=Math.floor((x-rect.x)/size), r=Math.floor((y-rect.y)/size);
                if(c>=0 && c<cols && r>=0 && r<rows) return {c,r,idx:r*3+c};
            }
            return null;
        };
        let res = check(this.squad1Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize);
        if(res) return {zone:ZONES.SQUAD1, ...res};
        res = check(this.squad2Rect, CONFIG.squadRows, CONFIG.squadCols, this.squadCellSize);
        if(res) return {zone:ZONES.SQUAD2, ...res};
        
        if(x>=this.gridStartX && x<this.gridStartX+this.gridTileSize*CONFIG.gridCols && y>=this.gridStartY && y<this.gridStartY+this.gridTileSize*CONFIG.gridRows) {
            const c=Math.floor((x-this.gridStartX)/this.gridTileSize), r=Math.floor((y-this.gridStartY)/this.gridTileSize);
            if(c>=0 && c<CONFIG.gridCols && r>=0 && r<CONFIG.gridRows) return {zone:ZONES.GRID, r, c, idx:r*8+c};
        }
        return null;
    }

    // --- LOGIC ---
    produce(building) {
        const code = getCode(building.type, building.level);
        const stats = GAME_DATA.buildings[code];
        
        if(this.energy < stats.energy) { this.showToast(`ÏóêÎÑàÏßÄ Î∂ÄÏ°± (${stats.energy})`); return; }
        let type = ITEM_TYPE.UNIT_INFANTRY;
        if(building.type===ITEM_TYPE.BUILDING_RANGE) type=ITEM_TYPE.UNIT_ARCHER;
        else if(building.type===ITEM_TYPE.BUILDING_STABLE) type=ITEM_TYPE.UNIT_CAVALRY;
        
        let lvl=1, r=Math.random()*100, sum=0;
        const probs = stats.prob || [100,0,0,0,0];
        for(let i=0; i<probs.length; i++) { sum+=probs[i]; if(r<sum){lvl=i+1;break;} }
        
        if(this.spawnItem({type, level:lvl, scale:0})) {
            this.energy-=stats.energy; this.updateUI(); this.requestRender();
            this.sound.playSpawn();
        } else this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }

    produceFromChest(chest, r, c) {
        if(chest.usage<=0) { this.showToast("Îπà ÏÉÅÏûê (Î®∏ÏßÄ ÌïÑÏöî)"); return; }
        if(this.energy<1) { this.showToast("ÏóêÎÑàÏßÄ Î∂ÄÏ°±"); return; }
        
        const code = getCode(ITEM_TYPE.BUILDING_CHEST, chest.level);
        const chestData = GAME_DATA.chests[code];
        if(!chestData) return;

        const table = chestData.drops;
        let total=0; table.forEach(e=>total+=e.prob);
        let rnd=Math.random()*total, dropCode=table[0].code;
        for(let e of table) { if(rnd<e.prob){dropCode=e.code;break;} rnd-=e.prob; }
        
        const info = getInfoFromCode(dropCode);
        if(this.spawnItem({type:info.type, level:info.level, scale:0})) {
            this.energy--; chest.usage--; chest.scale=1.2; this.updateUI(); this.requestRender();
            this.sound.playSpawn();
        } else this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }

    spawnItem(item) {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) 
            if(this.gridState[r][c].type===LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.grid[r][c]=item; 
                const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2;
                const cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;
                this.spawnParticles(cx, cy, "#EEE", 10, "smoke");
                return true;
            }
        return false;
    }

    ejectCamp(camp, r, c) {
        if(!camp.storedUnit) { this.showToast("ÎπÑÏñ¥ÏûàÏùå"); return; }
        const moves = [[0,1],[0,-1],[1,0],[-1,0]];
        for(let m of moves) {
            const nr=r+m[0], nc=c+m[1];
            if(nr>=0 && nr<8 && nc>=0 && nc<8 && this.gridState[nr][nc].type===LOCK_TYPE.OPEN && !this.grid[nr][nc]) {
                this.grid[nr][nc]=camp.storedUnit; camp.storedUnit=null; this.requestRender(); this.sound.playClick(); return;
            }
        }
        this.showToast("Ï£ºÎ≥Ä Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }

    collectResource(item, r, c) {
        // Updated Logic to use GAME_DATA
        const code = getCode(item.type, item.level);
        const data = GAME_DATA.items[code];
        const val = data ? data.earn : 1;

        let pColor = "#fff";
        if(item.type===ITEM_TYPE.ITEM_GOLD) { this.gold+=val; this.showToast(`+${val}G`); pColor="#FFD700"; }
        else if(item.type===ITEM_TYPE.ITEM_ENERGY) { this.energy=Math.min(this.energy+val, this.maxEnergy); this.showToast(`+${val}‚ö°`); pColor="#00FFFF"; }
        else { this.gem+=val; this.showToast(`+${val}üíé`); pColor="#FF00FF"; }
        
        const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2;
        const cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;
        this.spawnParticles(cx, cy, pColor, 15, "spark");
        this.sound.playCollect();
        
        this.grid[r][c]=null; this.updateUI(); this.requestRender();
    }

    tryUnlock(r, c) {
        const l = this.gridState[r][c];
        if(l.type===LOCK_TYPE.GOLD) {
            if(this.gold>=l.value) { 
                this.gold-=l.value; this.gridState[r][c]={type:LOCK_TYPE.OPEN}; this.showToast("Ìï¥Í∏à!"); 
                const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2;
                const cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;
                this.spawnParticles(cx, cy, "#FFF", 20, "confetti");
                this.sound.playUnlock();
            }
            else { this.showToast("Í≥®Îìú Î∂ÄÏ°±"); this.sound.playError(); }
        } else if(l.type===LOCK_TYPE.LEVEL) {
            if(this.lordLevel>=l.value) { 
                this.gridState[r][c]={type:LOCK_TYPE.OPEN}; this.showToast("Ìï¥Í∏à!");
                const cx = this.gridStartX + c * this.gridTileSize + this.gridTileSize/2;
                const cy = this.gridStartY + r * this.gridTileSize + this.gridTileSize/2;
                this.spawnParticles(cx, cy, "#FFF", 20, "confetti");
                this.sound.playUnlock();
            }
            else { this.showToast(`LV.${l.value} ÌïÑÏöî`); this.sound.playError(); }
        }
        this.updateUI(); this.requestRender();
    }

    // --- DRAWING ---
    loop() {
        if(this.isDirty || this.drag) {
            this.ctx.clearRect(0,0,this.width,this.height);
            
            if (this.viewMode === 'FIELD') {
                this.drawField();
            } else {
                // Draw Merge Mode
                this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50", ZONES.SQUAD1);
                this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3", ZONES.SQUAD2);
                for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
                    const x = this.gridStartX+c*this.gridTileSize, y = this.gridStartY+r*this.gridTileSize;
                    const isHover = this.hover && this.hover.zone===ZONES.GRID && this.hover.r===r && this.hover.c===c;
                    const isSel = this.selectedItem && this.selectedItem.location.zone===ZONES.GRID && this.selectedItem.location.r===r && this.selectedItem.location.c===c;
                    this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c], isHover, isSel);
                }
                if(this.drag) this.drawItem(this.drag.x-this.drag.size/2, this.drag.y-this.drag.size/2, this.drag.size, this.drag.item, true);
            }
            
            // Update Particles
            for(let i=this.particles.length-1; i>=0; i--) {
                this.particles[i].update();
                this.particles[i].draw(this.ctx);
                if(this.particles[i].life <= 0) this.particles.splice(i, 1);
            }

            let anim = false;
            this.grid.flat().forEach(i=>{ if(i&&i.scale!==1){ i.scale+=(i.scale<1?0.1:-0.05); if(Math.abs(i.scale-1)<0.05)i.scale=1; anim=true; } });
            
            this.isDirty = anim || !!this.drag || this.particles.length > 0;
        }
        requestAnimationFrame(()=>this.loop());
    }

    drawField() {
        if (!GAME_DATA || !GAME_DATA.field_map) return;
        const rows = 25;
        const cols = 25;
        const size = this.fieldTileSize;
        
        // Draw Field Background
        this.ctx.fillStyle = "#2c3e50";
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.save();
        this.ctx.translate(-this.fieldScroll.x, -this.fieldScroll.y);

        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                const x = c * size;
                const y = r * size;
                // Basic culling
                if (x + size < this.fieldScroll.x || x > this.fieldScroll.x + this.width ||
                    y + size < this.fieldScroll.y || y > this.fieldScroll.y + this.height) continue;

                const code = GAME_DATA.field_map[r][c];
                
                // Tile Base
                this.ctx.fillStyle = (r + c) % 2 === 0 ? "#5D4037" : "#4E342E"; // Dirt pattern
                this.ctx.fillRect(x, y, size, size);
                this.ctx.strokeStyle = "#3E2723";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, size, size);

                // Highlight Selected Tile
                if (this.selectedFieldTile && this.selectedFieldTile.r === r && this.selectedFieldTile.c === c) {
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeStyle = "#00FF00"; // Green Highlight
                    this.ctx.strokeRect(x+2, y+2, size-4, size-4);
                }

                // Tile Object
                if (code > 0) {
                    this.ctx.font = `${size/2}px sans-serif`;
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    let icon = "";
                    let color = "#fff";
                    
                    if (code === 1) { icon = "üè∞"; color = "#3498db"; } // My Castle
                    else if (code === 2) { icon = "‚õ©Ô∏è"; color = "#e74c3c"; } // Gate
                    else if (code === 3) { icon = "üèØ"; color = "#e67e22"; } // Fortress
                    else if (code === 4) { icon = "üõ£Ô∏è"; } // Road
                    else { icon = "üå≤"; }

                    this.ctx.fillStyle = color;
                    this.ctx.fillText(icon, x + size/2, y + size/2);
                    
                    // Coord Debug
                    this.ctx.fillStyle = "rgba(255,255,255,0.3)";
                    this.ctx.font = "10px sans-serif";
                    this.ctx.fillText(`${c},${r}`, x + size/2, y + size - 10);
                }
            }
        }

        // Draw Squad Marker
        const sqR = this.squad1Pos.r;
        const sqC = this.squad1Pos.c;
        const sqX = sqC * size + size/2;
        const sqY = sqR * size + size/2;
        
        // Ensure Squad is visible
        if (sqX > this.fieldScroll.x && sqX < this.fieldScroll.x + this.width &&
            sqY > this.fieldScroll.y && sqY < this.fieldScroll.y + this.height) {
            
            // Pulsing effect
            const pulse = Math.sin(Date.now() / 200) * 5;
            
            this.ctx.fillStyle = "#FFD700"; // Gold
            this.ctx.beginPath();
            this.ctx.arc(sqX, sqY - 20 + pulse, 15, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.strokeStyle = "#FFF";
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            
            this.ctx.fillStyle = "#000";
            this.ctx.font = "bold 16px sans-serif";
            this.ctx.fillText("1", sqX, sqY - 20 + pulse);
            
            // Flag pole
            this.ctx.beginPath();
            this.ctx.moveTo(sqX - 10, sqY - 20 + pulse);
            this.ctx.lineTo(sqX - 10, sqY + 20);
            this.ctx.strokeStyle = "#FFF";
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
        }

        this.ctx.restore();
    }

    getSquadPower(squad) {
        let power = 0;
        for(let unit of squad) {
            if(unit && unit.type >= 10 && unit.type < 20) {
                const stats = getData(unit.type, unit.level);
                if(stats.hp) power += (stats.hp + stats.atk + stats.def);
            }
        }
        return power;
    }

    drawSquad(data, rect, label, color, zone) {
        const cp = this.getSquadPower(data);
        
        this.ctx.fillStyle = color; 
        this.ctx.font="bold 40px sans-serif"; 
        this.ctx.textAlign="center";
        this.ctx.fillText(`${label}`, rect.x+rect.w/2, rect.y-22);
        
        this.ctx.fillStyle = color+"11"; 
        this.ctx.fillRect(rect.x-5, rect.y-5, rect.w+10, rect.h+10);
        
        this.ctx.font="bold 40px sans-serif"; 
        this.ctx.fillStyle = "#fff";
        this.ctx.fillText(`‚öîÔ∏è ${cp}`, rect.x+rect.w/2, rect.y + rect.h + 39); 

        for(let i=0; i<9; i++) {
            const x = rect.x+(i%3)*this.squadCellSize, y = rect.y+Math.floor(i/3)*this.squadCellSize;
            const isHover = this.hover && this.hover.zone===zone && this.hover.idx===i;
            const isSel = this.selectedItem && this.selectedItem.location.zone===zone && this.selectedItem.location.idx===i;
            this.drawCell(x, y, this.squadCellSize, data[i], {type:LOCK_TYPE.OPEN}, isHover, isSel);
        }
    }

    drawCell(x, y, s, item, lock, isHover, isSel) {
        const p=2, size=s-p*2;
        this.ctx.fillStyle = lock.type===LOCK_TYPE.OPEN ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.5)";
        this.ctx.fillRect(x+p, y+p, size, size);
        if(isSel) { this.ctx.lineWidth=6; this.ctx.strokeStyle="#0f0"; this.ctx.strokeRect(x+p, y+p, size, size); }
        else if(isHover) { this.ctx.lineWidth=4; this.ctx.strokeStyle="#ff0"; this.ctx.strokeRect(x+p, y+p, size, size); }
        else { this.ctx.lineWidth=2; this.ctx.strokeStyle="rgba(0,0,0,0.3)"; this.ctx.strokeRect(x+p, y+p, size, size); }

        if(lock.type!==LOCK_TYPE.OPEN) {
            const img = this.assets.getImage(lock.type===LOCK_TYPE.GOLD?'1804':'lock');
            if(img && img.complete && img.naturalWidth>0) {
                const isz = size*0.6;
                this.ctx.drawImage(img, x+(s-isz)/2, y+(s-isz)/2, isz, isz);
                this.ctx.fillStyle=lock.type===LOCK_TYPE.GOLD?"#ffd700":"#fff"; this.ctx.font="bold 20px sans-serif"; this.ctx.textAlign="center";
                this.ctx.strokeStyle="black"; this.ctx.lineWidth=4;
                const txt = lock.type===LOCK_TYPE.GOLD ? `üí∞${lock.value}` : `LV.${lock.value}`;
                this.ctx.strokeText(txt, x+s/2, y+s/2); this.ctx.fillText(txt, x+s/2, y+s/2);
            }
        } else if(item && item !== this.drag?.item) {
            this.drawItem(x, y, s, item);
        }
    }

    drawItem(x, y, s, item, isDrag=false) {
        const sc=isDrag?1.1:item.scale, p=4, ds=(s-p*2)*sc, offset=(s-ds)/2;
        const img = this.assets.getImage(item.type, item.level);
        const imageScale = 1.2;
        
        if(img && img.complete && img.naturalWidth>0) {
            if(isDrag) { this.ctx.shadowColor="black"; this.ctx.shadowBlur=15; }
            const drawSize = ds * imageScale;
            const drawOffset = (s - drawSize) / 2;
            this.ctx.drawImage(img, x + drawOffset, y + drawOffset, drawSize, drawSize);
            this.ctx.shadowBlur=0;
        } else {
            let c = "#cfd8dc"; let sym = "‚ùì";
            if(item.type===ITEM_TYPE.BUILDING_BARRACKS) { c="#795548"; sym="üè†"; }
            else if(item.type===ITEM_TYPE.BUILDING_RANGE) { c="#388e3c"; sym="üéØ"; }
            else if(item.type===ITEM_TYPE.BUILDING_STABLE) { c="#1976d2"; sym="üê¥"; }
            else if(item.type===ITEM_TYPE.BUILDING_CHEST) { c="#ffa000"; sym="üéÅ"; }
            else if(item.type===ITEM_TYPE.BUILDING_CAMP) { c="#5d4037"; sym="‚õ∫"; }
            else if(item.type===ITEM_TYPE.UNIT_INFANTRY) { c="#eeeeee"; sym="üõ°Ô∏è"; }
            else if(item.type===ITEM_TYPE.UNIT_ARCHER) { c="#c8e6c9"; sym="üèπ"; }
            else if(item.type===ITEM_TYPE.UNIT_CAVALRY) { c="#bbdefb"; sym="üêé"; }
            else if(item.type===ITEM_TYPE.ITEM_GOLD) { c="#fff176"; sym="üí∞"; }
            else if(item.type===ITEM_TYPE.ITEM_ENERGY) { c="#80deea"; sym="‚ö°"; }
            else if(item.type===ITEM_TYPE.ITEM_CRYSTAL) { c="#e1bee7"; sym="üíé"; }
            
            // Define drawSize and drawOffset here for fallback rendering
            const drawSize = ds * imageScale;
            const drawOffset = (s - drawSize) / 2;

            this.ctx.fillStyle = c; 
            this.roundRect(x + drawOffset, y + drawOffset, drawSize, drawSize, 12); 
            this.ctx.fill();
            this.ctx.strokeStyle = "rgba(0,0,0,0.4)"; this.ctx.lineWidth = 2; this.ctx.stroke();
            this.ctx.fillStyle = "rgba(0,0,0,0.6)"; this.ctx.font = `${Math.floor(drawSize*0.5)}px sans-serif`;
            this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle";
            this.ctx.fillText(sym, x+s/2, y+s/2);
        }

        // Badges
        const cx = x + s/2;
        const cy = y + s - 18; 
        this.ctx.save();
        this.ctx.shadowColor = "black";
        this.ctx.shadowBlur = 4;
        this.ctx.fillStyle = "rgba(0,0,0,0.9)";
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, 15, 0, Math.PI*2); 
        this.ctx.fill();
        this.ctx.strokeStyle = "#FFD700"; 
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        this.ctx.fillStyle = "#FFF";
        this.ctx.font = "bold 20px 'Segoe UI', sans-serif"; 
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText(item.level, cx, cy + 1); 
        this.ctx.restore();

        if(item.type===ITEM_TYPE.BUILDING_CAMP && item.storedUnit) {
            this.ctx.fillStyle="#f00"; this.ctx.font="bold 16px sans-serif"; this.ctx.fillText("IN", bx, y+s/2);
        }
    }

    roundRect(x,y,w,h,r){this.ctx.beginPath();this.ctx.moveTo(x+r,y);this.ctx.arcTo(x+w,y,x+w,y+h,r);this.ctx.arcTo(x+w,y+h,x,y+h,r);this.ctx.arcTo(x,y+h,x,y,r);this.ctx.arcTo(x,y,x+w,y,r);this.ctx.closePath();}

    toggleFieldModal() { document.getElementById('field-modal').classList.toggle('open'); }
    toggleShopModal() { document.getElementById('field-modal').classList.toggle('open'); }
    toggleViewMode() {
        this.viewMode = this.viewMode === 'MERGE' ? 'FIELD' : 'MERGE';
        document.getElementById('btn-field-label').innerText = this.viewMode === 'MERGE' ? getText("field") : "ÏÑ±ÏúºÎ°ú";
        document.getElementById('view-indicator').innerText = this.viewMode === 'MERGE' ? "" : "WORLD MAP";
        document.getElementById('view-indicator').classList.toggle('show', this.viewMode === 'FIELD');
        
        // Reset selection when switching views
        if (this.viewMode === 'FIELD') {
            this.selectedItem = null;
            this.selectedFieldTile = null;
            this.updateInfoPanel();
        } else {
            this.selectedFieldTile = null;
            this.selectedItem = null;
            this.updateInfoPanel();
        }
        this.requestRender();
    }

    cheatEnergy() { this.energy = Math.min(this.energy+30, this.maxEnergy); this.updateUI(); }
    cheatLevelUp() { this.addXp(this.requiredXp-this.currentXp); }
    spawnChest() { this.spawnItem({type:ITEM_TYPE.BUILDING_CHEST, level:1, scale:0, usage:5}); this.requestRender(); }
    
    showToast(msg) {
        if (msg.includes("Î∂ÄÏ°±") || msg.includes("Î∂àÍ∞Ä")) this.sound.playError();
        const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1000);
    }
    showFloatingImage(key, x, y) {
        const img = this.assets.getImage(key);
        if(!img) return;
        const el = document.createElement('img'); el.src = img.src; el.className='float-img';
        const r = this.canvas.getBoundingClientRect();
        el.style.left = ((x/this.width)*r.width)+"px"; el.style.top = ((y/this.height)*r.height)+"px";
        document.getElementById('canvas-wrapper').appendChild(el); setTimeout(()=>el.remove(), 1000);
    }
    updateUI() {
        document.getElementById('energy-display').innerText=`${this.energy}/${this.maxEnergy}`;
        document.getElementById('gold-display').innerText=this.gold;
        document.getElementById('gem-display').innerText=this.gem;
        document.getElementById('level-display').innerText=`LORD LV.${this.lordLevel}`;
        // Button label updated in toggleViewMode mostly, but sync here too
        document.getElementById('btn-field-label').innerText = this.viewMode === 'MERGE' ? getText("field") : "ÏÑ±ÏúºÎ°ú";
        document.getElementById('xp-text').innerText=`${this.currentXp} / ${this.requiredXp}`;
        document.getElementById('xp-bar').style.width=`${(this.currentXp/this.requiredXp)*100}%`;
    }
}

// Global Game Instance
let game;
window.onload = () => {
    // Load data first, then start game
    initGameData().then(() => {
        game = new Game();
    });
};
</script>
</body>
</html>