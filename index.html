<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KOV Prototype v13 - Deploy Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a1a;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            margin: 0; padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #app-root {
            position: relative;
            background-color: #4e342e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            aspect-ratio: 9/16;
            height: 100vh;
            max-height: 100vh;
            max-width: 56.25vh; 
            display: flex;
            flex-direction: column;
        }

        #ui-header {
            flex: 0 0 13%;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            z-index: 20;
            border-bottom: 2px solid #5d4037;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #3e2723;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-footer {
            flex: 0 0 13%;
            background: rgba(30, 20, 15, 0.95);
            border-top: 4px solid #8d6e63;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 5px;
            z-index: 20;
        }

        .pill {
            background: #333; padding: 4px 10px;
            border-radius: 15px; display: flex; align-items: center; gap: 5px;
            font-size: 13px; font-weight: bold; border: 1px solid #555;
            min-width: 70px; justify-content: center;
        }
        
        .xp-container {
            width: 100%; background: #222; height: 10px; border-radius: 5px;
            margin-top: 6px; position: relative; overflow: hidden; border: 1px solid #444;
        }
        .xp-fill {
            background: linear-gradient(90deg, #42a5f5, #1565c0);
            height: 100%; width: 0%; transition: width 0.3s;
        }
        .xp-text-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 9px; color: white; text-shadow: 0 1px 2px black; pointer-events: none;
        }

        .btn {
            background: linear-gradient(to bottom, #ffb300, #ff6f00);
            color: #fff; border: none; padding: 10px 18px;
            border-radius: 8px; font-weight: bold; font-size: 13px;
            box-shadow: 0 4px 0 #e65100; cursor: pointer; margin: 0 4px;
        }
        .btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #e65100; }
        .btn-green { background: linear-gradient(to bottom, #66bb6a, #43a047); box-shadow: 0 4px 0 #2e7d32; }
        .btn-purple { background: linear-gradient(to bottom, #ab47bc, #8e24aa); box-shadow: 0 4px 0 #6a1b9a; }
        
        #toast {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: #fff; padding: 12px 24px; border-radius: 30px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100; 
            font-weight: bold; font-size: 16px; border: 2px solid #ffd700; text-align: center;
        }
    </style>
</head>
<body>

<div id="app-root">
    <!-- Header -->
    <div id="ui-header">
        <div class="flex justify-between w-full mb-1">
            <div class="pill"><span style="color:#ffeb3b">‚ö°</span> <span id="energy-display">50/50</span></div>
            <div class="pill"><span style="color:#ffd700">üí∞</span> <span id="gold-display">3000</span></div>
            <div class="pill"><span style="color:#4fc3f7">üíé</span> <span id="gem-display">50</span></div>
        </div>
        
        <!-- Level & XP Area -->
        <div class="flex flex-col w-full mt-1">
            <div class="flex justify-between items-end px-1">
                <span class="text-white font-bold text-sm" id="level-display" style="color:#ffb74d">LORD LV.1</span>
            </div>
            <div class="xp-container">
                <div class="xp-fill" id="xp-bar"></div>
                <div class="xp-text-overlay" id="xp-text">0 / 10</div>
            </div>
        </div>
    </div>

    <!-- Game View -->
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="toast">Î©îÏãúÏßÄ</div>
    </div>

    <!-- Footer -->
    <div id="ui-footer">
        <h3 id="info-title" class="text-yellow-400 font-bold text-base mb-1">Ï§ÄÎπÑ ÏôÑÎ£å</h3>
        <div class="flex">
            <button class="btn" onclick="game.cheatEnergy()">‚ö° +30</button>
            <button class="btn btn-green" onclick="game.spawnChest()">üéÅ ÏÉÅÏûê</button>
            <button class="btn btn-purple" onclick="game.spawnCamp()">‚õ∫ Ï∫†ÌîÑ</button>
        </div>
    </div>
</div>

<script>
/**
 * KOV Prototype v13
 * - Improved Fallback Graphics (for when images fail on GitHub Pages)
 * - Fixed Z-Order for Labels
 */

const LEVEL_DATA = [
    { level: 1, xp: 10, maxEnergy: 50 },
    { level: 2, xp: 22, maxEnergy: 52 },
    { level: 3, xp: 37, maxEnergy: 54 },
    { level: 4, xp: 55, maxEnergy: 56 },
    { level: 5, xp: 77, maxEnergy: 58 },
    { level: 6, xp: 103, maxEnergy: 60 },
    { level: 7, xp: 134, maxEnergy: 62 },
    { level: 8, xp: 169, maxEnergy: 64 },
    { level: 9, xp: 209, maxEnergy: 66 },
    { level: 10, xp: 254, maxEnergy: 68 },
    { level: 11, xp: 304, maxEnergy: 70 },
    { level: 12, xp: 359, maxEnergy: 72 },
    { level: 13, xp: 420, maxEnergy: 74 },
    { level: 14, xp: 486, maxEnergy: 76 },
    { level: 15, xp: 558, maxEnergy: 78 }
];

const MERGE_XP_DATA = { 1:1, 2:2, 3:4, 4:5, 5:6, 6:8, 7:10, 8:15, 9:20, 10:0 };

const ASSET_MAP = {
    '10_1': '1PkG2U9TO6M09gP-ems90YrxXZhZiHVwl',
    '10_3': '1zewPXV4yx1YNCB5dCwhesx_NnXhE4xt_',
    '10_4': '1NNx5uvJB4bPLOpXePIyCHy6mJ07xUDR0',
    '10_6': '1NDSoQsn1Pfnc0sKmMaF9-16PTFUeySWb',
    '11_3': '1Rx5W791NsIwY5og_FIA_6lkTsaR_hBCp',
    '11_6': '1Q6Txp-h7wcKFXAXrZnAypOHamMhk-6oX',
    '12_6': '1puFKeJ8jEZr-BmFajzqlHvG6Jp-6aYXs',
    '1_1': '1_-nupZ7RIpxFbPEU3_MOtO85UXe67t4C',
    '2_1': '1SAvICsvtvI49UpjHn0MIRyNmlcAHVvI_',
    '4_1': '1aoRRg3dYMofX_zkQ2RkH_rsOmeDTyWUz',
    '5_1': '18RFtqBXA3MqptmbJuaDzHnqylP_FqBg4',
    '20_1': '173wg0wb4I-kuy5RIK_emyfex_fuVfYZC',
    '21_1': '1DQ8djwy-_V51Dzwz6vCzGd8bffiZi8gl',
    '22_1': '1Fay27Ipx4GH45HAlqLV0_tQ-7yz8TAzP',
};

class AssetLoader {
    constructor() { this.images = {}; }
    loadAll(callback) {
        let loadedCount = 0;
        const keys = Object.keys(ASSET_MAP);
        if(keys.length === 0) { if(callback) callback(); return; }
        
        keys.forEach(key => {
            const img = new Image();
            // REMOVED crossOrigin to try and bypass CORS on GitHub Pages
            // img.crossOrigin = "Anonymous"; 
            img.src = `https://drive.google.com/uc?export=view&id=${ASSET_MAP[key]}`;
            img.onload = () => { this.images[key] = img; checkDone(); };
            img.onerror = () => { console.warn(`Failed: ${key}`); checkDone(); };
        });

        const checkDone = () => {
            loadedCount++;
            if(loadedCount === keys.length && callback) callback();
        };
    }
    getImage(type, level) {
        if (this.images[`${type}_${level}`]) return this.images[`${type}_${level}`];
        if (type >= 10 && type < 20) {
            for(let l=level; l>=1; l--) if(this.images[`${type}_${l}`]) return this.images[`${type}_${l}`];
        }
        if (this.images[`${type}_1`]) return this.images[`${type}_1`];
        return null;
    }
}

const CONFIG = {
    gridCols: 8, gridRows: 8, gridPadding: 10,
    squadCols: 3, squadRows: 3, squadGap: 10,
    barracksCost: 5, maxLevel: 10
};

const ITEM_TYPE = {
    EMPTY: 0,
    BUILDING_BARRACKS: 1, BUILDING_RANGE: 2, BUILDING_STABLE: 3,
    BUILDING_CHEST: 4, BUILDING_CAMP: 5,
    UNIT_INFANTRY: 10, UNIT_ARCHER: 11, UNIT_CAVALRY: 12,
    ITEM_GOLD: 20, ITEM_ENERGY: 21, ITEM_CRYSTAL: 22
};

const LOCK_TYPE = { OPEN: 0, GOLD: 1, LEVEL: 2 };
const ZONES = { GRID: 'grid', SQUAD1: 'squad1', SQUAD2: 'squad2' };

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.wrapper = document.getElementById('canvas-wrapper');
        
        this.assets = new AssetLoader();
        this.assets.loadAll(() => this.render());

        this.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.gridState = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(null));
        this.squad1 = Array(9).fill(null);
        this.squad2 = Array(9).fill(null);
        
        this.lordLevel = 1; this.currentXp = 0;
        this.updateLevelStats();
        this.energy = this.maxEnergy; 
        this.gold = 3000; this.gem = 50; 
        
        this.drag = null;
        this.initGame();
        
        window.addEventListener('resize', () => this.resize());
        this.resize();

        const start = e => this.handleInput(e, 'start');
        const move = e => this.handleInput(e, 'move');
        const end = e => this.handleInput(e, 'end');
        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        this.canvas.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end);

        this.loop();
        this.updateUI();
    }

    initGame() {
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            const isEdge = (r===0 || r===CONFIG.gridRows-1 || c===0 || c===CONFIG.gridCols-1);
            if(!isEdge) this.gridState[r][c] = { type: LOCK_TYPE.OPEN };
            else {
                if((r+c)%2===0) this.gridState[r][c] = { type: LOCK_TYPE.GOLD, value: 500 };
                else this.gridState[r][c] = { type: LOCK_TYPE.LEVEL, value: 3 };
            }
        }
        this.grid[2][2] = { type: ITEM_TYPE.BUILDING_BARRACKS, level: 1, scale: 1 };
        this.grid[2][4] = { type: ITEM_TYPE.BUILDING_RANGE, level: 1, scale: 1 };
        this.grid[2][5] = { type: ITEM_TYPE.BUILDING_STABLE, level: 1, scale: 1 };
        this.grid[3][3] = { type: ITEM_TYPE.BUILDING_CHEST, level: 1, scale: 1 };
        this.grid[4][4] = { type: ITEM_TYPE.BUILDING_CAMP, level: 1, scale: 1, storedUnit: null };
    }

    resize() {
        this.canvas.width = this.wrapper.clientWidth;
        this.canvas.height = this.wrapper.clientHeight;
        const W = this.canvas.width; const H = this.canvas.height;
        const squadAreaH = H * 0.35;
        this.squadCellSize = Math.min((W - 40) / 7, squadAreaH / 4);
        const squadW = this.squadCellSize * 3;
        const squadTotalW = squadW * 2 + 20;
        const squadStartX = (W - squadTotalW) / 2;
        const squadStartY = 20;
        this.squad1Rect = { x: squadStartX, y: squadStartY, w: squadW, h: squadW };
        this.squad2Rect = { x: squadStartX + squadW + 20, y: squadStartY, w: squadW, h: squadW };
        const gridAreaY = squadStartY + squadW + 30;
        const availH = H - gridAreaY - 10; const availW = W - 20;
        this.gridTileSize = Math.min(availW / CONFIG.gridCols, availH / CONFIG.gridRows);
        const gridTotalW = this.gridTileSize * CONFIG.gridCols;
        this.gridStartX = (W - gridTotalW) / 2;
        this.gridStartY = gridAreaY;
    }

    addXp(amount) {
        this.currentXp += amount;
        if (this.currentXp >= this.requiredXp) this.levelUp();
        this.updateUI();
    }
    levelUp() {
        if (this.lordLevel >= 15) return; 
        this.currentXp -= this.requiredXp;
        this.lordLevel++;
        this.updateLevelStats();
        this.energy = this.maxEnergy; 
        this.showToast(`LEVEL UP! LV.${this.lordLevel}`);
        if (this.currentXp >= this.requiredXp) this.levelUp();
    }
    updateLevelStats() {
        const levelData = LEVEL_DATA.find(d => d.level === this.lordLevel) || LEVEL_DATA[LEVEL_DATA.length - 1];
        this.maxEnergy = levelData.maxEnergy;
        this.requiredXp = levelData.xp;
    }

    handleInput(e, state) {
        if(state === 'start') e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        const pos = { x: cx - rect.left, y: cy - rect.top };
        if(state === 'end' && this.drag) pos.x = this.drag.x;

        if (state === 'start') {
            const hit = this.getZoneAt(pos.x, pos.y);
            if (!hit) return;
            if (hit.zone === ZONES.GRID) {
                if (this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) { this.tryUnlock(hit.r, hit.c); return; }
                const item = this.grid[hit.r][hit.c];
                if (item) {
                    if (item.type === ITEM_TYPE.BUILDING_CHEST) { this.openChest(hit.r, hit.c); return; }
                    if (item.type >= 20) { this.collectResource(item, hit.r, hit.c); return; }
                    if (item.type === ITEM_TYPE.BUILDING_CAMP) { this.ejectCamp(item, hit.r, hit.c); return; }
                    if (item.type < 10) { this.produce(item.type); return; }
                }
            }
            let item = null;
            if(hit.zone === ZONES.GRID) item = this.grid[hit.r][hit.c];
            else if(hit.zone === ZONES.SQUAD1) item = this.squad1[hit.idx];
            else if(hit.zone === ZONES.SQUAD2) item = this.squad2[hit.idx];

            if (item && item.type >= 10 && item.type < 20) {
                this.drag = { item: item, startZone: hit, x: pos.x, y: pos.y };
                if(hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = null;
                else if(hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = null;
                else if(hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = null;
            }
        }
        else if (state === 'move' && this.drag) { this.drag.x = pos.x; this.drag.y = pos.y; }
        else if (state === 'end' && this.drag) {
            const hit = this.getZoneAt(this.drag.x, this.drag.y);
            let returned = false;
            if (hit) {
                let target = null;
                if(hit.zone === ZONES.GRID) {
                    if(this.gridState[hit.r][hit.c].type !== LOCK_TYPE.OPEN) returned = true;
                    else target = this.grid[hit.r][hit.c];
                }
                else if(hit.zone === ZONES.SQUAD1) target = this.squad1[hit.idx];
                else if(hit.zone === ZONES.SQUAD2) target = this.squad2[hit.idx];

                if (!returned) {
                    if (hit.zone === ZONES.GRID && target && target.type === ITEM_TYPE.BUILDING_CAMP && !target.storedUnit) {
                        target.storedUnit = this.drag.item; this.showToast("Î≥ëÏÇ¨ Î≥¥Í¥Ä ÏôÑÎ£å");
                    }
                    else if (!target) {
                        if(hit.zone === ZONES.GRID) this.grid[hit.r][hit.c] = this.drag.item;
                        else if(hit.zone === ZONES.SQUAD1) this.squad1[hit.idx] = this.drag.item;
                        else if(hit.zone === ZONES.SQUAD2) this.squad2[hit.idx] = this.drag.item;
                    }
                    else if (target.type === this.drag.item.type && target.level === this.drag.item.level && target.level < CONFIG.maxLevel) {
                        target.level++; target.scale = 1.3;
                        const gain = MERGE_XP_DATA[target.level - 1] || 0;
                        if (gain > 0) { this.addXp(gain); this.showToast(`XP +${gain}`); } 
                        else { this.showToast("Level Up!"); }
                    }
                    else returned = true;
                }
            } else returned = true;

            if (returned) {
                const s = this.drag.startZone;
                if(s.zone === ZONES.GRID) this.grid[s.r][s.c] = this.drag.item;
                else if(s.zone === ZONES.SQUAD1) this.squad1[s.idx] = this.drag.item;
                else if(s.zone === ZONES.SQUAD2) this.squad2[s.idx] = this.drag.item;
            }
            this.drag = null; this.updateUI();
        }
    }

    getZoneAt(x, y) {
        if (x >= this.squad1Rect.x && x < this.squad1Rect.x + this.squad1Rect.w && y >= this.squad1Rect.y && y < this.squad1Rect.y + this.squad1Rect.h) {
            const c = Math.floor((x - this.squad1Rect.x) / this.squadCellSize);
            const r = Math.floor((y - this.squad1Rect.y) / this.squadCellSize);
            return { zone: ZONES.SQUAD1, idx: r * 3 + c };
        }
        if (x >= this.squad2Rect.x && x < this.squad2Rect.x + this.squad2Rect.w && y >= this.squad2Rect.y && y < this.squad2Rect.y + this.squad2Rect.h) {
            const c = Math.floor((x - this.squad2Rect.x) / this.squadCellSize);
            const r = Math.floor((y - this.squad2Rect.y) / this.squadCellSize);
            return { zone: ZONES.SQUAD2, idx: r * 3 + c };
        }
        if (x >= this.gridStartX && y >= this.gridStartY) {
            const c = Math.floor((x - this.gridStartX) / this.gridTileSize);
            const r = Math.floor((y - this.gridStartY) / this.gridTileSize);
            if (c >= 0 && c < CONFIG.gridCols && r >= 0 && r < CONFIG.gridRows) return { zone: ZONES.GRID, r, c };
        }
        return null;
    }

    produce(type) {
        if(this.energy < CONFIG.barracksCost) { this.showToast("ÏóêÎÑàÏßÄ Î∂ÄÏ°±!"); return; }
        let unitType = ITEM_TYPE.UNIT_INFANTRY;
        if(type === ITEM_TYPE.BUILDING_RANGE) unitType = ITEM_TYPE.UNIT_ARCHER;
        if(type === ITEM_TYPE.BUILDING_STABLE) unitType = ITEM_TYPE.UNIT_CAVALRY;
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            if(this.gridState[r][c].type === LOCK_TYPE.OPEN && !this.grid[r][c]) {
                this.energy -= CONFIG.barracksCost; this.grid[r][c] = { type: unitType, level: 1, scale: 0 };
                this.updateUI(); return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±!");
    }
    openChest(r, c) {
        this.grid[r][c] = null; this.showToast("ÏÉÅÏûê Ïò§Ìîà...");
        setTimeout(() => {
            const rand = Math.random();
            let reward = rand > 0.6 ? ITEM_TYPE.ITEM_ENERGY : ITEM_TYPE.ITEM_GOLD;
            this.grid[r][c] = { type: reward, level: 1, scale: 0 };
        }, 300);
    }
    collectResource(item, r, c) {
        if(item.type === ITEM_TYPE.ITEM_GOLD) this.gold += 100;
        if(item.type === ITEM_TYPE.ITEM_ENERGY) this.energy = Math.min(this.energy + 20, this.maxEnergy);
        this.grid[r][c] = null; this.updateUI();
    }
    ejectCamp(camp, r, c) {
        if(!camp.storedUnit) { this.showToast("ÎπÑÏñ¥ÏûàÏùå"); return; }
        const n = [[0,1],[0,-1],[1,0],[-1,0]];
        for(let o of n) {
            const nr=r+o[0], nc=c+o[1];
            if(nr>=0 && nr<8 && nc>=0 && nc<8 && !this.grid[nr][nc] && this.gridState[nr][nc].type===LOCK_TYPE.OPEN) {
                this.grid[nr][nc] = camp.storedUnit; camp.storedUnit = null; return;
            }
        }
        this.showToast("Í≥µÍ∞Ñ Î∂ÄÏ°±");
    }
    tryUnlock(r, c) {
        const lock = this.gridState[r][c];
        if(lock.type === LOCK_TYPE.GOLD) {
            if(this.gold >= lock.value) { this.gold -= lock.value; this.gridState[r][c] = { type: LOCK_TYPE.OPEN }; this.showToast("Ìï¥Í∏à ÏôÑÎ£å!"); }
            else this.showToast("Í≥®Îìú Î∂ÄÏ°±");
        } else if(lock.type === LOCK_TYPE.LEVEL) {
            if(this.lordLevel >= lock.value) { this.gridState[r][c] = { type: LOCK_TYPE.OPEN }; this.showToast("Ìï¥Í∏à ÏôÑÎ£å!"); }
            else this.showToast(`LV.${lock.value} ÌïÑÏöî`);
        }
        this.updateUI();
    }

    loop() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawSquad(this.squad1, this.squad1Rect, "SQUAD 1", "#4caf50");
        this.drawSquad(this.squad2, this.squad2Rect, "SQUAD 2", "#2196f3");
        for(let r=0; r<CONFIG.gridRows; r++) for(let c=0; c<CONFIG.gridCols; c++) {
            const x = this.gridStartX + c * this.gridTileSize;
            const y = this.gridStartY + r * this.gridTileSize;
            this.drawCell(x, y, this.gridTileSize, this.grid[r][c], this.gridState[r][c]);
        }
        if(this.drag) this.drawItem(this.drag.x - this.gridTileSize/2, this.drag.y - this.gridTileSize/2, this.gridTileSize, this.drag.item, true);
        
        this.grid.flat().forEach(i => i && this.anim(i));
        requestAnimationFrame(() => this.loop());
    }
    anim(i) { if(i.scale < 1) i.scale += 0.1; if(i.scale > 1) i.scale -= 0.05; }

    drawSquad(d, r, l, c) {
        this.ctx.fillStyle = c; this.ctx.font = "bold 16px sans-serif"; this.ctx.textAlign="center"; this.ctx.fillText(l, r.x + r.w/2, r.y - 8);
        this.ctx.fillStyle = c + "33"; this.ctx.fillRect(r.x-5, r.y-5, r.w+10, r.h+10);
        for(let i=0; i<9; i++) {
            const cx = r.x + (i%3)*this.squadCellSize; const cy = r.y + Math.floor(i/3)*this.squadCellSize;
            this.drawCell(cx, cy, this.squadCellSize, d[i], {type:LOCK_TYPE.OPEN});
        }
    }
    drawCell(x, y, s, i, l) {
        const p = 2; const is = s - p*2;
        this.ctx.fillStyle = (l.type !== LOCK_TYPE.OPEN) ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.1)";
        this.ctx.fillRect(x+p, y+p, is, is);
        this.ctx.strokeStyle = "rgba(0,0,0,0.3)"; this.ctx.lineWidth = 1; this.ctx.strokeRect(x+p, y+p, is, is);
        if(l.type !== LOCK_TYPE.OPEN) {
            this.ctx.fillStyle = "white"; this.ctx.font = "16px sans-serif"; this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle";
            this.ctx.fillText(l.type === LOCK_TYPE.GOLD ? `üí∞${l.value}` : `üîíLV.${l.value}`, x+s/2, y+s/2);
        } else if(i && i !== this.drag?.item) this.drawItem(x, y, s, i);
    }

    drawItem(x, y, size, item, isDrag=false) {
        const scale = isDrag ? 1.1 : item.scale;
        const pad = 4; const ds = (size - pad * 2) * scale;
        const cx = x + size / 2; const cy = y + size / 2; const dx = cx - ds/2; const dy = cy - ds/2;

        if(isDrag) { this.ctx.shadowColor = "black"; this.ctx.shadowBlur = 10; }

        const img = this.assets.getImage(item.type, item.level);
        if(img && img.complete && img.naturalWidth !== 0) {
            this.ctx.drawImage(img, dx, dy, ds, ds);
        } else {
            // IMPROVED FALLBACK GRAPHICS
            let c = "#e0e0e0"; // Default (Infantry is now gray, not white)
            let sym = "?";
            if(item.type===ITEM_TYPE.BUILDING_BARRACKS) { c="#8d6e63"; sym="üè†"; }
            if(item.type===ITEM_TYPE.BUILDING_RANGE) { c="#558b2f"; sym="üéØ"; }
            if(item.type===ITEM_TYPE.BUILDING_STABLE) { c="#1565c0"; sym="üê¥"; }
            if(item.type===ITEM_TYPE.BUILDING_CHEST) { c="#ffb300"; sym="üéÅ"; }
            if(item.type===ITEM_TYPE.BUILDING_CAMP) { c="#795548"; sym="‚õ∫"; }
            if(item.type===ITEM_TYPE.UNIT_INFANTRY) { c="#e0e0e0"; sym="üõ°Ô∏è"; }
            if(item.type===ITEM_TYPE.UNIT_ARCHER) { c="#c8e6c9"; sym="üèπ"; }
            if(item.type===ITEM_TYPE.UNIT_CAVALRY) { c="#bbdefb"; sym="üêé"; }
            if(item.type===ITEM_TYPE.ITEM_GOLD) { c="#fff176"; sym="üí∞"; }
            if(item.type===ITEM_TYPE.ITEM_ENERGY) { c="#80deea"; sym="‚ö°"; }
            if(item.type===ITEM_TYPE.ITEM_CRYSTAL) { c="#e1bee7"; sym="üíé"; }

            this.ctx.fillStyle = c; 
            this.roundRect(dx, dy, ds, ds, 8); 
            this.ctx.fill();
            this.ctx.strokeStyle="rgba(0,0,0,0.5)"; 
            this.ctx.lineWidth=2; 
            this.ctx.stroke();
            
            // Draw Symbol in Center
            this.ctx.fillStyle = "rgba(0,0,0,0.5)";
            this.ctx.font = "24px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(sym, cx, cy);
        }

        // Draw Labels (ALWAYS VISIBLE)
        this.drawLabel(item, cx, dy, ds);
        this.ctx.shadowBlur = 0;
    }

    drawLabel(item, cx, dy, ds) {
        // Name Label (Top)
        let label = "";
        if(item.type===ITEM_TYPE.BUILDING_BARRACKS) label="Î≥ëÏòÅ";
        if(item.type===ITEM_TYPE.UNIT_INFANTRY) label="Î≥¥Î≥ë";
        if(item.type===ITEM_TYPE.UNIT_ARCHER) label="Í∂ÅÎ≥ë";
        if(item.type===ITEM_TYPE.UNIT_CAVALRY) label="Í∏∞Î≥ë";
        if(item.type===ITEM_TYPE.BUILDING_CHEST) label="ÏÉÅÏûê";
        if(item.type===ITEM_TYPE.BUILDING_CAMP) label="Ï∫†ÌîÑ";
        if(item.type===ITEM_TYPE.ITEM_GOLD) label="Í≥®Îìú";
        
        if (label) {
            this.ctx.fillStyle = "rgba(0,0,0,0.7)";
            this.ctx.fillRect(cx - 20, dy + 2, 40, 14);
            this.ctx.fillStyle = "white"; 
            this.ctx.font = "bold 10px sans-serif"; 
            this.ctx.textAlign = "center"; 
            this.ctx.textBaseline = "top";
            this.ctx.fillText(label, cx, dy + 3);
        }

        // Level Badge (Bottom Right) - Only for leveled items
        if ((item.type >= 10 && item.type < 20) || (item.type < 10 && item.type > 0)) { 
            this.ctx.fillStyle = "black";
            this.ctx.beginPath(); this.ctx.arc(cx, dy + ds - 10, 9, 0, Math.PI*2); this.ctx.fill();
            this.ctx.fillStyle = "white"; 
            this.ctx.font = "bold 11px sans-serif"; 
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(item.level, cx, dy + ds - 9);
        }

        if (item.type === ITEM_TYPE.BUILDING_CAMP && item.storedUnit) {
            this.ctx.fillStyle = "red"; this.ctx.font="bold 14px sans-serif"; 
            this.ctx.fillText("IN", cx, dy + ds/2);
        }
    }

    roundRect(x,y,w,h,r){this.ctx.beginPath();this.ctx.moveTo(x+r,y);this.ctx.arcTo(x+w,y,x+w,y+h,r);this.ctx.arcTo(x+w,y+h,x,y+h,r);this.ctx.arcTo(x,y+h,x,y,r);this.ctx.arcTo(x,y,x+w,y,r);this.ctx.closePath();}
    showToast(msg){ const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1000); }
    updateUI(){ 
        document.getElementById('energy-display').innerText = `${this.energy}/${this.maxEnergy}`;
        document.getElementById('gold-display').innerText = this.gold;
        document.getElementById('level-display').innerText = `LORD LV.${this.lordLevel}`;
        document.getElementById('xp-text').innerText = `${this.currentXp} / ${this.requiredXp}`;
        document.getElementById('xp-bar').style.width = `${Math.min(100, (this.currentXp/this.requiredXp)*100)}%`;
    }
    cheatEnergy(){ this.energy = Math.min(this.energy+30, this.maxEnergy); this.updateUI(); }
    spawnChest(){ 
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(this.gridState[r][c].type===LOCK_TYPE.OPEN&&!this.grid[r][c]){
            this.grid[r][c]={type:ITEM_TYPE.BUILDING_CHEST,level:1,scale:0}; return;
        }
    }
    spawnCamp(){
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(this.gridState[r][c].type===LOCK_TYPE.OPEN&&!this.grid[r][c]){
            this.grid[r][c]={type:ITEM_TYPE.BUILDING_CAMP,level:1,scale:0}; return;
        }
    }
}

const game = new Game();
</script>
</body>
</html>